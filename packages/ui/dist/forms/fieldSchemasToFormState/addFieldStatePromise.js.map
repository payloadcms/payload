{"version":3,"file":"addFieldStatePromise.js","names":["ObjectIdImport","getBlockSelect","stripUnselectedFields","validateBlocksFilterOptions","deepCopyObjectSimple","fieldAffectsData","fieldHasSubFields","fieldIsHiddenOrDisabled","fieldIsID","fieldIsLocalized","tabHasName","resolveFilterOptions","isRowCollapsed","iterateFields","ObjectId","default","addFieldStatePromise","args","id","addErrorPathToParent","addErrorPathToParentArg","anyParentLocalized","blockData","clientFieldSchemaMap","collectionSlug","data","field","fieldSchemaMap","filter","forceFullValue","fullData","includeSchema","indexPath","mockRSCs","omitParents","operation","parentPath","parentPermissions","parentSchemaPath","passesCondition","path","preferences","previousFormState","readOnly","renderAllFields","renderFieldFn","req","schemaPath","select","selectMode","skipConditionChecks","skipValidation","state","console","warn","fieldPermissions","fieldState","lastRenderedPath","addedByServer","fieldSchema","type","name","hasPermission","read","access","siblingData","validate","undefined","validationResult","jsonError","JSON","parse","e","event","previousValue","initialValue","err","payload","logger","error","msg","errorPath","errorPaths","includes","push","valid","errorMessage","arrayValue","Array","isArray","arraySelect","promises","rows","reduce","acc","row","rowIndex","rowPath","toHexString","idKey","value","fields","find","localized","parentIndexPath","parentPassesCondition","permissions","previousRow","prevRow","newRow","isLoading","isCollapsed","collapsedPrefs","collapsed","Promise","all","length","disableFormData","blocksValue","filterOptionsValidationResult","filterOptions","blocksFilterOptions","allowedBlockSlugs","rowMetadata","i","blockTypeToMatch","blockType","block","blocks","blockReferences","slug","Error","blockSelect","blockSelectMode","invalidBlockSlugs","t","blockField","fieldKey","blockNameKey","blockName","groupSelect","relationTo","relation","query","user","hasMany","relationshipValue","map","relationship","selectFilterOptions","options","isNamedTab","tabSelect","tabField","childPermissions","shouldContinue","siblingDoc","tabPermissions","pathSegments","split","tabPassesCondition","admin","condition","tabs","tab","fieldConfig","get","endsWith","formState","previousFieldState"],"sources":["../../../src/forms/fieldSchemasToFormState/addFieldStatePromise.ts"],"sourcesContent":["import type {\n  BuildFormStateArgs,\n  ClientFieldSchemaMap,\n  Data,\n  DocumentPreferences,\n  Field,\n  FieldSchemaMap,\n  FieldState,\n  FlattenedBlock,\n  FormState,\n  FormStateWithoutComponents,\n  PayloadRequest,\n  Row,\n  SanitizedFieldPermissions,\n  SanitizedFieldsPermissions,\n  SelectMode,\n  SelectType,\n  TabAsField,\n  Validate,\n} from 'payload'\n\nimport ObjectIdImport from 'bson-objectid'\nimport { getBlockSelect, stripUnselectedFields, validateBlocksFilterOptions } from 'payload'\nimport {\n  deepCopyObjectSimple,\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldIsHiddenOrDisabled,\n  fieldIsID,\n  fieldIsLocalized,\n  tabHasName,\n} from 'payload/shared'\n\nimport type { RenderFieldMethod } from './types.js'\n\nimport { resolveFilterOptions } from '../../utilities/resolveFilterOptions.js'\nimport { isRowCollapsed } from './isRowCollapsed.js'\nimport { iterateFields } from './iterateFields.js'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport type AddFieldStatePromiseArgs = {\n  addErrorPathToParent: (fieldPath: string) => void\n  /**\n   * if all parents are localized, then the field is localized\n   */\n  anyParentLocalized?: boolean\n  /**\n   * Data of the nearest parent block, or undefined\n   */\n  blockData: Data | undefined\n  clientFieldSchemaMap?: ClientFieldSchemaMap\n  collectionSlug?: string\n  data: Data\n  field: Field | TabAsField\n  fieldIndex: number\n  fieldSchemaMap: FieldSchemaMap\n  /**\n   * You can use this to filter down to only `localized` fields that require translation (type: text, textarea, etc.). Another plugin might want to look for only `point` type fields to do some GIS function. With the filter function you can go in like a surgeon.\n   */\n  filter?: (args: AddFieldStatePromiseArgs) => boolean\n  /**\n   * Force the value of fields like arrays or blocks to be the full value instead of the length @default false\n   */\n  forceFullValue?: boolean\n  fullData: Data\n  id: number | string\n  /**\n   * Whether the field schema should be included in the state\n   */\n  includeSchema?: boolean\n  indexPath: string\n  mockRSCs?: BuildFormStateArgs['mockRSCs']\n  /**\n   * Whether to omit parent fields in the state. @default false\n   */\n  omitParents?: boolean\n  operation: 'create' | 'update'\n  parentIndexPath: string\n  parentPath: string\n  parentPermissions: SanitizedFieldsPermissions\n  parentSchemaPath: string\n  passesCondition: boolean\n  path: string\n  preferences: DocumentPreferences\n  previousFormState: FormState\n  readOnly?: boolean\n  renderAllFields: boolean\n  renderFieldFn: RenderFieldMethod\n  /**\n   * Req is used for validation and defaultValue calculation. If you don't need validation,\n   * just create your own req and pass in the locale and the user\n   */\n  req: PayloadRequest\n  schemaPath: string\n  select?: SelectType\n  selectMode?: SelectMode\n  /**\n   * Whether to skip checking the field's condition. @default false\n   */\n  skipConditionChecks?: boolean\n  /**\n   * Whether to skip validating the field. @default false\n   */\n  skipValidation?: boolean\n  state: FormStateWithoutComponents\n}\n\n/**\n * Flattens the fields schema and fields data.\n * The output is the field path (e.g. array.0.name) mapped to a FormField object.\n */\nexport const addFieldStatePromise = async (args: AddFieldStatePromiseArgs): Promise<void> => {\n  const {\n    id,\n    addErrorPathToParent: addErrorPathToParentArg,\n    anyParentLocalized = false,\n    blockData,\n    clientFieldSchemaMap,\n    collectionSlug,\n    data,\n    field,\n    fieldSchemaMap,\n    filter,\n    forceFullValue = false,\n    fullData,\n    includeSchema = false,\n    indexPath,\n    mockRSCs,\n    omitParents = false,\n    operation,\n    parentPath,\n    parentPermissions,\n    parentSchemaPath,\n    passesCondition,\n    path,\n    preferences,\n    previousFormState,\n    readOnly,\n    renderAllFields,\n    renderFieldFn,\n    req,\n    schemaPath,\n    select,\n    selectMode,\n    skipConditionChecks = false,\n    skipValidation = false,\n    state,\n  } = args\n\n  if (!args.clientFieldSchemaMap && args.renderFieldFn) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'clientFieldSchemaMap is not passed to addFieldStatePromise - this will reduce performance',\n    )\n  }\n\n  let fieldPermissions: SanitizedFieldPermissions = true\n\n  const fieldState: FieldState = {}\n\n  const lastRenderedPath = previousFormState?.[path]?.lastRenderedPath\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (lastRenderedPath) {\n    fieldState.lastRenderedPath = lastRenderedPath\n  }\n\n  // If we're rendering all fields, no need to flag this as added by server\n  const addedByServer = !renderAllFields && !previousFormState?.[path]\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (addedByServer) {\n    fieldState.addedByServer = true\n  }\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (passesCondition === false) {\n    fieldState.passesCondition = false\n  }\n\n  // Append only if true to avoid sending '$undefined' through the network\n  if (includeSchema) {\n    fieldState.fieldSchema = field\n  }\n\n  if (fieldAffectsData(field) && !fieldIsHiddenOrDisabled(field) && field.type !== 'tab') {\n    fieldPermissions =\n      parentPermissions === true\n        ? parentPermissions\n        : deepCopyObjectSimple(parentPermissions?.[field.name])\n\n    let hasPermission: boolean =\n      fieldPermissions === true || deepCopyObjectSimple(fieldPermissions?.read)\n\n    if (typeof field?.access?.read === 'function') {\n      hasPermission = await field.access.read({\n        id,\n        blockData,\n        data: fullData,\n        req,\n        siblingData: data,\n      })\n    } else {\n      hasPermission = true\n    }\n\n    if (!hasPermission) {\n      return\n    }\n\n    const validate: Validate = 'validate' in field ? field.validate : undefined\n\n    let validationResult: string | true = true\n\n    if (typeof validate === 'function' && !skipValidation && passesCondition) {\n      let jsonError\n\n      if (field.type === 'json' && typeof data[field.name] === 'string') {\n        try {\n          JSON.parse(data[field.name])\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      try {\n        validationResult = await validate(data?.[field.name], {\n          ...field,\n          id,\n          blockData,\n          collectionSlug,\n          data: fullData,\n          event: 'onChange',\n          // @AlessioGr added `jsonError` in https://github.com/payloadcms/payload/commit/c7ea62a39473408c3ea912c4fbf73e11be4b538d\n          // @ts-expect-error-next-line\n          jsonError,\n          operation,\n          preferences,\n          previousValue: previousFormState?.[path]?.initialValue,\n          req,\n          siblingData: data,\n        })\n      } catch (err) {\n        validationResult = `Error validating field at path: ${path}`\n\n        req.payload.logger.error({\n          err,\n          msg: validationResult,\n        })\n      }\n    }\n\n    /**\n     * This function adds the error **path** to the current field and all its parents. If a field is invalid, all its parents are also invalid.\n     * It does not add the error **message** to the current field, as that shouldn't apply to all parents.\n     * This is done separately below.\n     */\n    const addErrorPathToParent = (errorPath: string) => {\n      if (typeof addErrorPathToParentArg === 'function') {\n        addErrorPathToParentArg(errorPath)\n      }\n\n      if (!fieldState.errorPaths) {\n        fieldState.errorPaths = []\n      }\n\n      if (!fieldState.errorPaths.includes(errorPath)) {\n        fieldState.errorPaths.push(errorPath)\n        fieldState.valid = false\n      }\n    }\n\n    if (typeof validationResult === 'string') {\n      fieldState.errorMessage = validationResult\n      fieldState.valid = false\n      addErrorPathToParent(path)\n    }\n\n    switch (field.type) {\n      case 'array': {\n        const arrayValue = Array.isArray(data[field.name]) ? data[field.name] : []\n\n        const arraySelect = select?.[field.name]\n\n        const { promises, rows } = arrayValue.reduce(\n          (acc, row, rowIndex: number) => {\n            const rowPath = path + '.' + rowIndex\n\n            row.id = row?.id || new ObjectId().toHexString()\n\n            if (!omitParents && (!filter || filter(args))) {\n              const idKey = rowPath + '.id'\n\n              state[idKey] = {\n                initialValue: row.id,\n                value: row.id,\n              }\n\n              if (includeSchema) {\n                state[idKey].fieldSchema = field.fields.find((field) => fieldIsID(field))\n              }\n            }\n\n            acc.promises.push(\n              iterateFields({\n                id,\n                addErrorPathToParent,\n                anyParentLocalized: field.localized || anyParentLocalized,\n                blockData,\n                clientFieldSchemaMap,\n                collectionSlug,\n                data: row,\n                fields: field.fields,\n                fieldSchemaMap,\n                filter,\n                forceFullValue,\n                fullData,\n                includeSchema,\n                mockRSCs,\n                omitParents,\n                operation,\n                parentIndexPath: '',\n                parentPassesCondition: passesCondition,\n                parentPath: rowPath,\n                parentSchemaPath: schemaPath,\n                permissions:\n                  fieldPermissions === true ? fieldPermissions : fieldPermissions?.fields || {},\n                preferences,\n                previousFormState,\n                readOnly,\n                renderAllFields,\n                renderFieldFn,\n                req,\n                select: typeof arraySelect === 'object' ? arraySelect : undefined,\n                selectMode,\n                skipConditionChecks,\n                skipValidation,\n                state,\n              }),\n            )\n\n            if (!acc.rows) {\n              acc.rows = []\n            }\n\n            // First, check if `previousFormState` has a matching row\n            const previousRow: Row = (previousFormState?.[path]?.rows || []).find(\n              (prevRow) => prevRow.id === row.id,\n            )\n\n            const newRow: Row = {\n              id: row.id,\n              isLoading: false,\n            }\n\n            if (previousRow?.lastRenderedPath) {\n              newRow.lastRenderedPath = previousRow.lastRenderedPath\n            }\n\n            // add addedByServer flag\n            if (!previousRow) {\n              newRow.addedByServer = true\n            }\n\n            const isCollapsed = isRowCollapsed({\n              collapsedPrefs: preferences?.fields?.[path]?.collapsed,\n              field,\n              previousRow,\n              row,\n            })\n\n            if (isCollapsed) {\n              newRow.collapsed = true\n            }\n\n            acc.rows.push(newRow)\n\n            return acc\n          },\n          {\n            promises: [],\n            rows: [],\n          },\n        )\n\n        // Wait for all promises and update fields with the results\n        await Promise.all(promises)\n\n        if (rows) {\n          fieldState.rows = rows\n        }\n\n        // Add values to field state\n        if (data[field.name] !== null) {\n          fieldState.value = forceFullValue ? arrayValue : arrayValue.length\n          fieldState.initialValue = forceFullValue ? arrayValue : arrayValue.length\n\n          if (arrayValue.length > 0) {\n            fieldState.disableFormData = true\n          }\n        }\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksValue = Array.isArray(data[field.name]) ? data[field.name] : []\n\n        // Handle blocks filterOptions\n        let filterOptionsValidationResult: Awaited<\n          ReturnType<typeof validateBlocksFilterOptions>\n        > | null = null\n        if (field.filterOptions) {\n          filterOptionsValidationResult = await validateBlocksFilterOptions({\n            id,\n            data: fullData,\n            filterOptions: field.filterOptions,\n            req,\n            siblingData: data,\n            value: data[field.name],\n          })\n\n          fieldState.blocksFilterOptions = filterOptionsValidationResult.allowedBlockSlugs\n        }\n\n        const { promises, rowMetadata } = blocksValue.reduce(\n          (acc, row, i: number) => {\n            const blockTypeToMatch: string = row.blockType\n\n            const block =\n              req.payload.blocks[blockTypeToMatch] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (blockType) => typeof blockType !== 'string' && blockType.slug === blockTypeToMatch,\n              ) as FlattenedBlock | undefined)\n\n            if (!block) {\n              throw new Error(\n                `Block with type \"${row.blockType}\" was found in block data, but no block with that type is defined in the config for field with schema path ${schemaPath}.`,\n              )\n            }\n\n            const { blockSelect, blockSelectMode } = getBlockSelect({\n              block,\n              select: select?.[field.name],\n              selectMode,\n            })\n\n            const rowPath = path + '.' + i\n\n            if (block) {\n              row.id = row?.id || new ObjectId().toHexString()\n\n              if (!omitParents && (!filter || filter(args))) {\n                // Handle block `id` field\n                const idKey = rowPath + '.id'\n\n                state[idKey] = {\n                  initialValue: row.id,\n                  value: row.id,\n                }\n\n                // If the blocks field fails filterOptions validation, add error paths to the individual blocks that are no longer allowed\n                if (\n                  filterOptionsValidationResult?.invalidBlockSlugs?.length &&\n                  filterOptionsValidationResult.invalidBlockSlugs.includes(row.blockType)\n                ) {\n                  state[idKey].errorMessage = req.t('validation:invalidBlock', {\n                    block: row.blockType,\n                  })\n                  state[idKey].valid = false\n                  addErrorPathToParent(idKey)\n\n                  // If the error is due to block filterOptions, we want the blocks field (fieldState) to include all the filterOptions-related\n                  // error paths for each sub-block, not for the validation result of the block itself. Otherwise, say there are 2 invalid blocks,\n                  // the blocks field will have 3 instead of 2 error paths - one for itself, and one for each invalid block.\n                  // Instead, we want only the 2 error paths for the individual, invalid blocks.\n                  fieldState.errorPaths = fieldState.errorPaths.filter(\n                    (errorPath) => errorPath !== path,\n                  )\n                }\n\n                if (includeSchema) {\n                  state[idKey].fieldSchema = includeSchema\n                    ? block.fields.find((blockField) => fieldIsID(blockField))\n                    : undefined\n                }\n\n                // Handle `blockType` field\n                const fieldKey = rowPath + '.blockType'\n\n                state[fieldKey] = {\n                  initialValue: row.blockType,\n                  value: row.blockType,\n                }\n\n                if (addedByServer) {\n                  state[fieldKey].addedByServer = addedByServer\n                }\n\n                if (includeSchema) {\n                  state[fieldKey].fieldSchema = block.fields.find(\n                    (blockField) => 'name' in blockField && blockField.name === 'blockType',\n                  )\n                }\n\n                // Handle `blockName` field\n                const blockNameKey = rowPath + '.blockName'\n\n                state[blockNameKey] = {}\n\n                if (row.blockName) {\n                  state[blockNameKey].initialValue = row.blockName\n                  state[blockNameKey].value = row.blockName\n                }\n\n                if (includeSchema) {\n                  state[blockNameKey].fieldSchema = block.fields.find(\n                    (blockField) => 'name' in blockField && blockField.name === 'blockName',\n                  )\n                }\n              }\n\n              acc.promises.push(\n                iterateFields({\n                  id,\n                  addErrorPathToParent,\n                  anyParentLocalized: field.localized || anyParentLocalized,\n                  blockData: row,\n                  clientFieldSchemaMap,\n                  collectionSlug,\n                  data: row,\n                  fields: block.fields,\n                  fieldSchemaMap,\n                  filter,\n                  forceFullValue,\n                  fullData,\n                  includeSchema,\n                  mockRSCs,\n                  omitParents,\n                  operation,\n                  parentIndexPath: '',\n                  parentPassesCondition: passesCondition,\n                  parentPath: rowPath,\n                  parentSchemaPath: schemaPath + '.' + block.slug,\n                  permissions:\n                    fieldPermissions === true\n                      ? fieldPermissions\n                      : parentPermissions?.[field.name]?.blocks?.[block.slug] === true\n                        ? true\n                        : parentPermissions?.[field.name]?.blocks?.[block.slug]?.fields || {},\n                  preferences,\n                  previousFormState,\n                  readOnly,\n                  renderAllFields,\n                  renderFieldFn,\n                  req,\n                  select: typeof blockSelect === 'object' ? blockSelect : undefined,\n                  selectMode: blockSelectMode,\n                  skipConditionChecks,\n                  skipValidation,\n                  state,\n                }),\n              )\n\n              // First, check if `previousFormState` has a matching row\n              const previousRow: Row = (previousFormState?.[path]?.rows || []).find(\n                (prevRow) => prevRow.id === row.id,\n              )\n\n              const newRow: Row = {\n                id: row.id,\n                blockType: row.blockType,\n                isLoading: false,\n              }\n\n              if (previousRow?.lastRenderedPath) {\n                newRow.lastRenderedPath = previousRow.lastRenderedPath\n              }\n\n              acc.rowMetadata.push(newRow)\n\n              const isCollapsed = isRowCollapsed({\n                collapsedPrefs: preferences?.fields?.[path]?.collapsed,\n                field,\n                previousRow,\n                row,\n              })\n\n              if (isCollapsed) {\n                acc.rowMetadata[acc.rowMetadata.length - 1].collapsed = true\n              }\n            }\n\n            return acc\n          },\n          {\n            promises: [],\n            rowMetadata: [],\n          },\n        )\n\n        await Promise.all(promises)\n\n        // Add values to field state\n        if (data[field.name] === null) {\n          fieldState.value = null\n          fieldState.initialValue = null\n        } else {\n          fieldState.value = forceFullValue ? blocksValue : blocksValue.length\n          fieldState.initialValue = forceFullValue ? blocksValue : blocksValue.length\n\n          if (blocksValue.length > 0) {\n            fieldState.disableFormData = true\n          }\n        }\n\n        fieldState.rows = rowMetadata\n\n        // Add field to state\n        if (!omitParents && (!filter || filter(args))) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      case 'group': {\n        if (!filter || filter(args)) {\n          fieldState.disableFormData = true\n          state[path] = fieldState\n        }\n\n        const groupSelect = select?.[field.name]\n\n        await iterateFields({\n          id,\n          addErrorPathToParent,\n          anyParentLocalized: field.localized || anyParentLocalized,\n          blockData,\n          clientFieldSchemaMap,\n          collectionSlug,\n          data: data?.[field.name] || {},\n          fields: field.fields,\n          fieldSchemaMap,\n          filter,\n          forceFullValue,\n          fullData,\n          includeSchema,\n          mockRSCs,\n          omitParents,\n          operation,\n          parentIndexPath: '',\n          parentPassesCondition: passesCondition,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          permissions:\n            typeof fieldPermissions === 'boolean' ? fieldPermissions : fieldPermissions?.fields,\n          preferences,\n          previousFormState,\n          readOnly,\n          renderAllFields,\n          renderFieldFn,\n          req,\n          select: typeof groupSelect === 'object' ? groupSelect : undefined,\n          selectMode,\n          skipConditionChecks,\n          skipValidation,\n          state,\n        })\n\n        break\n      }\n\n      case 'relationship':\n      case 'upload': {\n        if (field.filterOptions) {\n          if (typeof field.filterOptions === 'object') {\n            if (typeof field.relationTo === 'string') {\n              fieldState.filterOptions = {\n                [field.relationTo]: field.filterOptions,\n              }\n            } else {\n              fieldState.filterOptions = field.relationTo.reduce((acc, relation) => {\n                acc[relation] = field.filterOptions\n                return acc\n              }, {})\n            }\n          }\n\n          if (typeof field.filterOptions === 'function') {\n            const query = await resolveFilterOptions(field.filterOptions, {\n              id,\n              blockData,\n              data: fullData,\n              relationTo: field.relationTo,\n              req,\n              siblingData: data,\n              user: req.user,\n            })\n\n            fieldState.filterOptions = query\n          }\n        }\n\n        if (field.hasMany) {\n          const relationshipValue = Array.isArray(data[field.name])\n            ? data[field.name].map((relationship) => {\n                if (Array.isArray(field.relationTo)) {\n                  return {\n                    relationTo: relationship.relationTo,\n                    value:\n                      relationship.value && typeof relationship.value === 'object'\n                        ? relationship.value?.id\n                        : relationship.value,\n                  }\n                }\n                if (typeof relationship === 'object' && relationship !== null) {\n                  return relationship.id\n                }\n                return relationship\n              })\n            : undefined\n\n          fieldState.value = relationshipValue\n          fieldState.initialValue = relationshipValue\n        } else if (Array.isArray(field.relationTo)) {\n          if (\n            data[field.name] &&\n            typeof data[field.name] === 'object' &&\n            'relationTo' in data[field.name] &&\n            'value' in data[field.name]\n          ) {\n            const value =\n              typeof data[field.name]?.value === 'object' &&\n              data[field.name]?.value &&\n              'id' in data[field.name].value\n                ? data[field.name].value.id\n                : data[field.name].value\n            const relationshipValue = {\n              relationTo: data[field.name]?.relationTo,\n              value,\n            }\n            fieldState.value = relationshipValue\n            fieldState.initialValue = relationshipValue\n          }\n        } else {\n          const relationshipValue =\n            data[field.name] && typeof data[field.name] === 'object' && 'id' in data[field.name]\n              ? data[field.name].id\n              : data[field.name]\n          fieldState.value = relationshipValue\n          fieldState.initialValue = relationshipValue\n        }\n\n        if (!filter || filter(args)) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      case 'select': {\n        if (typeof field.filterOptions === 'function') {\n          fieldState.selectFilterOptions = field.filterOptions({\n            data: fullData,\n            options: field.options,\n            req,\n            siblingData: data,\n          })\n        }\n\n        if (data[field.name] !== undefined) {\n          fieldState.value = data[field.name]\n          fieldState.initialValue = data[field.name]\n        }\n\n        if (!filter || filter(args)) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n\n      default: {\n        if (data[field.name] !== undefined) {\n          fieldState.value = data[field.name]\n          fieldState.initialValue = data[field.name]\n        }\n\n        // Add field to state\n        if (!filter || filter(args)) {\n          state[path] = fieldState\n        }\n\n        break\n      }\n    }\n  } else if (fieldHasSubFields(field) && !fieldAffectsData(field)) {\n    // Handle field types that do not use names (row, collapsible, unnamed group etc)\n\n    if (!filter || filter(args)) {\n      state[path] = {\n        disableFormData: true,\n      }\n\n      if (passesCondition === false) {\n        state[path].passesCondition = false\n      }\n    }\n\n    await iterateFields({\n      id,\n      mockRSCs,\n      select,\n      selectMode,\n      // passthrough parent functionality\n      addErrorPathToParent: addErrorPathToParentArg,\n      anyParentLocalized: fieldIsLocalized(field) || anyParentLocalized,\n      blockData,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data,\n      fields: field.fields,\n      fieldSchemaMap,\n      filter,\n      forceFullValue,\n      fullData,\n      includeSchema,\n      omitParents,\n      operation,\n      parentIndexPath: indexPath,\n      parentPassesCondition: passesCondition,\n      parentPath: path,\n      parentSchemaPath: schemaPath,\n      permissions: parentPermissions, // TODO: Verify this is correct\n      preferences,\n      previousFormState,\n      readOnly,\n      renderAllFields,\n      renderFieldFn,\n      req,\n      skipConditionChecks,\n      skipValidation,\n      state,\n    })\n  } else if (field.type === 'tab') {\n    const isNamedTab = tabHasName(field)\n    let tabSelect: SelectType | undefined\n\n    const tabField: TabAsField = {\n      ...field,\n      type: 'tab',\n    }\n\n    let childPermissions: SanitizedFieldsPermissions = undefined\n\n    if (isNamedTab) {\n      const shouldContinue = stripUnselectedFields({\n        field: tabField,\n        select,\n        selectMode,\n        siblingDoc: data?.[field.name] || {},\n      })\n\n      if (!shouldContinue) {\n        return\n      }\n\n      if (parentPermissions === true) {\n        childPermissions = true\n      } else {\n        const tabPermissions = parentPermissions?.[field.name]\n        if (tabPermissions === true) {\n          childPermissions = true\n        } else {\n          childPermissions = tabPermissions?.fields\n        }\n      }\n\n      if (typeof select?.[field.name] === 'object') {\n        tabSelect = select?.[field.name] as SelectType\n      }\n    } else {\n      childPermissions = parentPermissions\n      tabSelect = select\n    }\n\n    const pathSegments = path ? path.split('.') : []\n\n    // If passesCondition is false then this should always result to false\n    // If the tab has no admin.condition provided then fallback to passesCondition and let that decide the result\n    let tabPassesCondition = passesCondition\n\n    if (passesCondition && typeof field.admin?.condition === 'function') {\n      tabPassesCondition = field.admin.condition(fullData, data, {\n        blockData,\n        operation,\n        path: pathSegments,\n        user: req.user,\n      })\n    }\n\n    if (field?.id) {\n      state[field.id] = {\n        passesCondition: tabPassesCondition,\n      }\n    }\n\n    return iterateFields({\n      id,\n      addErrorPathToParent: addErrorPathToParentArg,\n      anyParentLocalized: field.localized || anyParentLocalized,\n      blockData,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data: isNamedTab ? data?.[field.name] || {} : data,\n      fields: field.fields,\n      fieldSchemaMap,\n      filter,\n      forceFullValue,\n      fullData,\n      includeSchema,\n      mockRSCs,\n      omitParents,\n      operation,\n      parentIndexPath: indexPath,\n      parentPassesCondition: tabPassesCondition,\n      parentPath: path,\n      parentSchemaPath: schemaPath,\n      permissions: childPermissions,\n      preferences,\n      previousFormState,\n      readOnly,\n      renderAllFields,\n      renderFieldFn,\n      req,\n      select: tabSelect,\n      selectMode,\n      skipConditionChecks,\n      skipValidation,\n      state,\n    })\n  } else if (field.type === 'tabs') {\n    return iterateFields({\n      id,\n      addErrorPathToParent: addErrorPathToParentArg,\n      anyParentLocalized: fieldIsLocalized(field) || anyParentLocalized,\n      blockData,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data,\n      fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n      fieldSchemaMap,\n      filter,\n      forceFullValue,\n      fullData,\n      includeSchema,\n      omitParents,\n      operation,\n      parentIndexPath: indexPath,\n      parentPassesCondition: passesCondition,\n      parentPath: path,\n      parentSchemaPath: schemaPath,\n      permissions: parentPermissions,\n      preferences,\n      previousFormState,\n      renderAllFields,\n      renderFieldFn,\n      req,\n      select,\n      selectMode,\n      skipConditionChecks,\n      skipValidation,\n      state,\n    })\n  } else if (field.type === 'ui') {\n    if (!filter || filter(args)) {\n      state[path] = fieldState\n      state[path].disableFormData = true\n    }\n  }\n\n  if (renderFieldFn && !fieldIsHiddenOrDisabled(field)) {\n    const fieldConfig = fieldSchemaMap.get(schemaPath)\n\n    if (!fieldConfig && !mockRSCs) {\n      if (schemaPath.endsWith('.blockType')) {\n        return\n      } else {\n        throw new Error(`Field config not found for ${schemaPath}`)\n      }\n    }\n\n    if (!state[path]) {\n      // Some fields (ie `Tab`) do not live in form state\n      // therefore we cannot attach customComponents to them\n      return\n    }\n\n    if (addedByServer) {\n      state[path].addedByServer = addedByServer\n    }\n\n    renderFieldFn({\n      id,\n      clientFieldSchemaMap,\n      collectionSlug,\n      data: fullData,\n      fieldConfig: fieldConfig as Field,\n      fieldSchemaMap,\n      fieldState: state[path],\n      formState: state,\n      indexPath,\n      lastRenderedPath,\n      mockRSCs,\n      operation,\n      parentPath,\n      parentSchemaPath,\n      path,\n      permissions: fieldPermissions,\n      preferences,\n      previousFieldState: previousFormState?.[path],\n      readOnly,\n      renderAllFields,\n      req,\n      schemaPath,\n      siblingData: data,\n    })\n  }\n}\n"],"mappings":"AAqBA,OAAOA,cAAA,MAAoB;AAC3B,SAASC,cAAc,EAAEC,qBAAqB,EAAEC,2BAA2B,QAAQ;AACnF,SACEC,oBAAoB,EACpBC,gBAAgB,EAChBC,iBAAiB,EACjBC,uBAAuB,EACvBC,SAAS,EACTC,gBAAgB,EAChBC,UAAU,QACL;AAIP,SAASC,oBAAoB,QAAQ;AACrC,SAASC,cAAc,QAAQ;AAC/B,SAASC,aAAa,QAAQ;AAE9B,MAAMC,QAAA,GAAW,aAAad,cAAA,GAAiBA,cAAA,CAAee,OAAO,GAAGf,cAAA;AAqExE;;;;AAIA,OAAO,MAAMgB,oBAAA,GAAuB,MAAOC,IAAA;EACzC,MAAM;IACJC,EAAE;IACFC,oBAAA,EAAsBC,uBAAuB;IAC7CC,kBAAA,GAAqB,KAAK;IAC1BC,SAAS;IACTC,oBAAoB;IACpBC,cAAc;IACdC,IAAI;IACJC,KAAK;IACLC,cAAc;IACdC,MAAM;IACNC,cAAA,GAAiB,KAAK;IACtBC,QAAQ;IACRC,aAAA,GAAgB,KAAK;IACrBC,SAAS;IACTC,QAAQ;IACRC,WAAA,GAAc,KAAK;IACnBC,SAAS;IACTC,UAAU;IACVC,iBAAiB;IACjBC,gBAAgB;IAChBC,eAAe;IACfC,IAAI;IACJC,WAAW;IACXC,iBAAiB;IACjBC,QAAQ;IACRC,eAAe;IACfC,aAAa;IACbC,GAAG;IACHC,UAAU;IACVC,MAAM;IACNC,UAAU;IACVC,mBAAA,GAAsB,KAAK;IAC3BC,cAAA,GAAiB,KAAK;IACtBC;EAAK,CACN,GAAGnC,IAAA;EAEJ,IAAI,CAACA,IAAA,CAAKM,oBAAoB,IAAIN,IAAA,CAAK4B,aAAa,EAAE;IACpD;IACAQ,OAAA,CAAQC,IAAI,CACV;EAEJ;EAEA,IAAIC,gBAAA,GAA8C;EAElD,MAAMC,UAAA,GAAyB,CAAC;EAEhC,MAAMC,gBAAA,GAAmBf,iBAAA,GAAoBF,IAAA,CAAK,EAAEiB,gBAAA;EAEpD;EACA,IAAIA,gBAAA,EAAkB;IACpBD,UAAA,CAAWC,gBAAgB,GAAGA,gBAAA;EAChC;EAEA;EACA,MAAMC,aAAA,GAAgB,CAACd,eAAA,IAAmB,CAACF,iBAAA,GAAoBF,IAAA,CAAK;EAEpE;EACA,IAAIkB,aAAA,EAAe;IACjBF,UAAA,CAAWE,aAAa,GAAG;EAC7B;EAEA;EACA,IAAInB,eAAA,KAAoB,OAAO;IAC7BiB,UAAA,CAAWjB,eAAe,GAAG;EAC/B;EAEA;EACA,IAAIR,aAAA,EAAe;IACjByB,UAAA,CAAWG,WAAW,GAAGjC,KAAA;EAC3B;EAEA,IAAIrB,gBAAA,CAAiBqB,KAAA,KAAU,CAACnB,uBAAA,CAAwBmB,KAAA,KAAUA,KAAA,CAAMkC,IAAI,KAAK,OAAO;IACtFL,gBAAA,GACElB,iBAAA,KAAsB,OAClBA,iBAAA,GACAjC,oBAAA,CAAqBiC,iBAAA,GAAoBX,KAAA,CAAMmC,IAAI,CAAC;IAE1D,IAAIC,aAAA,GACFP,gBAAA,KAAqB,QAAQnD,oBAAA,CAAqBmD,gBAAA,EAAkBQ,IAAA;IAEtE,IAAI,OAAOrC,KAAA,EAAOsC,MAAA,EAAQD,IAAA,KAAS,YAAY;MAC7CD,aAAA,GAAgB,MAAMpC,KAAA,CAAMsC,MAAM,CAACD,IAAI,CAAC;QACtC7C,EAAA;QACAI,SAAA;QACAG,IAAA,EAAMK,QAAA;QACNgB,GAAA;QACAmB,WAAA,EAAaxC;MACf;IACF,OAAO;MACLqC,aAAA,GAAgB;IAClB;IAEA,IAAI,CAACA,aAAA,EAAe;MAClB;IACF;IAEA,MAAMI,QAAA,GAAqB,cAAcxC,KAAA,GAAQA,KAAA,CAAMwC,QAAQ,GAAGC,SAAA;IAElE,IAAIC,gBAAA,GAAkC;IAEtC,IAAI,OAAOF,QAAA,KAAa,cAAc,CAACf,cAAA,IAAkBZ,eAAA,EAAiB;MACxE,IAAI8B,SAAA;MAEJ,IAAI3C,KAAA,CAAMkC,IAAI,KAAK,UAAU,OAAOnC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,KAAK,UAAU;QACjE,IAAI;UACFS,IAAA,CAAKC,KAAK,CAAC9C,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC;QAC7B,EAAE,OAAOW,CAAA,EAAG;UACVH,SAAA,GAAYG,CAAA;QACd;MACF;MAEA,IAAI;QACFJ,gBAAA,GAAmB,MAAMF,QAAA,CAASzC,IAAA,GAAOC,KAAA,CAAMmC,IAAI,CAAC,EAAE;UACpD,GAAGnC,KAAK;UACRR,EAAA;UACAI,SAAA;UACAE,cAAA;UACAC,IAAA,EAAMK,QAAA;UACN2C,KAAA,EAAO;UACP;UACA;UACAJ,SAAA;UACAlC,SAAA;UACAM,WAAA;UACAiC,aAAA,EAAehC,iBAAA,GAAoBF,IAAA,CAAK,EAAEmC,YAAA;UAC1C7B,GAAA;UACAmB,WAAA,EAAaxC;QACf;MACF,EAAE,OAAOmD,GAAA,EAAK;QACZR,gBAAA,GAAmB,mCAAmC5B,IAAA,EAAM;QAE5DM,GAAA,CAAI+B,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;UACvBH,GAAA;UACAI,GAAA,EAAKZ;QACP;MACF;IACF;IAEA;;;;;IAKA,MAAMjD,oBAAA,GAAwB8D,SAAA;MAC5B,IAAI,OAAO7D,uBAAA,KAA4B,YAAY;QACjDA,uBAAA,CAAwB6D,SAAA;MAC1B;MAEA,IAAI,CAACzB,UAAA,CAAW0B,UAAU,EAAE;QAC1B1B,UAAA,CAAW0B,UAAU,GAAG,EAAE;MAC5B;MAEA,IAAI,CAAC1B,UAAA,CAAW0B,UAAU,CAACC,QAAQ,CAACF,SAAA,GAAY;QAC9CzB,UAAA,CAAW0B,UAAU,CAACE,IAAI,CAACH,SAAA;QAC3BzB,UAAA,CAAW6B,KAAK,GAAG;MACrB;IACF;IAEA,IAAI,OAAOjB,gBAAA,KAAqB,UAAU;MACxCZ,UAAA,CAAW8B,YAAY,GAAGlB,gBAAA;MAC1BZ,UAAA,CAAW6B,KAAK,GAAG;MACnBlE,oBAAA,CAAqBqB,IAAA;IACvB;IAEA,QAAQd,KAAA,CAAMkC,IAAI;MAChB,KAAK;QAAS;UACZ,MAAM2B,UAAA,GAAaC,KAAA,CAAMC,OAAO,CAAChE,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,IAAIpC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,GAAG,EAAE;UAE1E,MAAM6B,WAAA,GAAc1C,MAAA,GAAStB,KAAA,CAAMmC,IAAI,CAAC;UAExC,MAAM;YAAE8B,QAAQ;YAAEC;UAAI,CAAE,GAAGL,UAAA,CAAWM,MAAM,CAC1C,CAACC,GAAA,EAAKC,GAAA,EAAKC,QAAA;YACT,MAAMC,OAAA,GAAUzD,IAAA,GAAO,MAAMwD,QAAA;YAE7BD,GAAA,CAAI7E,EAAE,GAAG6E,GAAA,EAAK7E,EAAA,IAAM,IAAIJ,QAAA,GAAWoF,WAAW;YAE9C,IAAI,CAAChE,WAAA,KAAgB,CAACN,MAAA,IAAUA,MAAA,CAAOX,IAAA,CAAI,GAAI;cAC7C,MAAMkF,KAAA,GAAQF,OAAA,GAAU;cAExB7C,KAAK,CAAC+C,KAAA,CAAM,GAAG;gBACbxB,YAAA,EAAcoB,GAAA,CAAI7E,EAAE;gBACpBkF,KAAA,EAAOL,GAAA,CAAI7E;cACb;cAEA,IAAIa,aAAA,EAAe;gBACjBqB,KAAK,CAAC+C,KAAA,CAAM,CAACxC,WAAW,GAAGjC,KAAA,CAAM2E,MAAM,CAACC,IAAI,CAAE5E,KAAA,IAAUlB,SAAA,CAAUkB,KAAA;cACpE;YACF;YAEAoE,GAAA,CAAIH,QAAQ,CAACP,IAAI,CACfvE,aAAA,CAAc;cACZK,EAAA;cACAC,oBAAA;cACAE,kBAAA,EAAoBK,KAAA,CAAM6E,SAAS,IAAIlF,kBAAA;cACvCC,SAAA;cACAC,oBAAA;cACAC,cAAA;cACAC,IAAA,EAAMsE,GAAA;cACNM,MAAA,EAAQ3E,KAAA,CAAM2E,MAAM;cACpB1E,cAAA;cACAC,MAAA;cACAC,cAAA;cACAC,QAAA;cACAC,aAAA;cACAE,QAAA;cACAC,WAAA;cACAC,SAAA;cACAqE,eAAA,EAAiB;cACjBC,qBAAA,EAAuBlE,eAAA;cACvBH,UAAA,EAAY6D,OAAA;cACZ3D,gBAAA,EAAkBS,UAAA;cAClB2D,WAAA,EACEnD,gBAAA,KAAqB,OAAOA,gBAAA,GAAmBA,gBAAA,EAAkB8C,MAAA,IAAU,CAAC;cAC9E5D,WAAA;cACAC,iBAAA;cACAC,QAAA;cACAC,eAAA;cACAC,aAAA;cACAC,GAAA;cACAE,MAAA,EAAQ,OAAO0C,WAAA,KAAgB,WAAWA,WAAA,GAAcvB,SAAA;cACxDlB,UAAA;cACAC,mBAAA;cACAC,cAAA;cACAC;YACF;YAGF,IAAI,CAAC0C,GAAA,CAAIF,IAAI,EAAE;cACbE,GAAA,CAAIF,IAAI,GAAG,EAAE;YACf;YAEA;YACA,MAAMe,WAAA,GAAmB,CAACjE,iBAAA,GAAoBF,IAAA,CAAK,EAAEoD,IAAA,IAAQ,EAAE,EAAEU,IAAI,CAClEM,OAAA,IAAYA,OAAA,CAAQ1F,EAAE,KAAK6E,GAAA,CAAI7E,EAAE;YAGpC,MAAM2F,MAAA,GAAc;cAClB3F,EAAA,EAAI6E,GAAA,CAAI7E,EAAE;cACV4F,SAAA,EAAW;YACb;YAEA,IAAIH,WAAA,EAAalD,gBAAA,EAAkB;cACjCoD,MAAA,CAAOpD,gBAAgB,GAAGkD,WAAA,CAAYlD,gBAAgB;YACxD;YAEA;YACA,IAAI,CAACkD,WAAA,EAAa;cAChBE,MAAA,CAAOnD,aAAa,GAAG;YACzB;YAEA,MAAMqD,WAAA,GAAcnG,cAAA,CAAe;cACjCoG,cAAA,EAAgBvE,WAAA,EAAa4D,MAAA,GAAS7D,IAAA,CAAK,EAAEyE,SAAA;cAC7CvF,KAAA;cACAiF,WAAA;cACAZ;YACF;YAEA,IAAIgB,WAAA,EAAa;cACfF,MAAA,CAAOI,SAAS,GAAG;YACrB;YAEAnB,GAAA,CAAIF,IAAI,CAACR,IAAI,CAACyB,MAAA;YAEd,OAAOf,GAAA;UACT,GACA;YACEH,QAAA,EAAU,EAAE;YACZC,IAAA,EAAM;UACR;UAGF;UACA,MAAMsB,OAAA,CAAQC,GAAG,CAACxB,QAAA;UAElB,IAAIC,IAAA,EAAM;YACRpC,UAAA,CAAWoC,IAAI,GAAGA,IAAA;UACpB;UAEA;UACA,IAAInE,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,KAAK,MAAM;YAC7BL,UAAA,CAAW4C,KAAK,GAAGvE,cAAA,GAAiB0D,UAAA,GAAaA,UAAA,CAAW6B,MAAM;YAClE5D,UAAA,CAAWmB,YAAY,GAAG9C,cAAA,GAAiB0D,UAAA,GAAaA,UAAA,CAAW6B,MAAM;YAEzE,IAAI7B,UAAA,CAAW6B,MAAM,GAAG,GAAG;cACzB5D,UAAA,CAAW6D,eAAe,GAAG;YAC/B;UACF;UAEA;UACA,IAAI,CAACnF,WAAA,KAAgB,CAACN,MAAA,IAAUA,MAAA,CAAOX,IAAA,CAAI,GAAI;YAC7CmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;MAEA,KAAK;QAAU;UACb,MAAM8D,WAAA,GAAc9B,KAAA,CAAMC,OAAO,CAAChE,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,IAAIpC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,GAAG,EAAE;UAE3E;UACA,IAAI0D,6BAAA,GAEO;UACX,IAAI7F,KAAA,CAAM8F,aAAa,EAAE;YACvBD,6BAAA,GAAgC,MAAMpH,2BAAA,CAA4B;cAChEe,EAAA;cACAO,IAAA,EAAMK,QAAA;cACN0F,aAAA,EAAe9F,KAAA,CAAM8F,aAAa;cAClC1E,GAAA;cACAmB,WAAA,EAAaxC,IAAA;cACb2E,KAAA,EAAO3E,IAAI,CAACC,KAAA,CAAMmC,IAAI;YACxB;YAEAL,UAAA,CAAWiE,mBAAmB,GAAGF,6BAAA,CAA8BG,iBAAiB;UAClF;UAEA,MAAM;YAAE/B,QAAQ;YAAEgC;UAAW,CAAE,GAAGL,WAAA,CAAYzB,MAAM,CAClD,CAACC,GAAA,EAAKC,GAAA,EAAK6B,CAAA;YACT,MAAMC,gBAAA,GAA2B9B,GAAA,CAAI+B,SAAS;YAE9C,MAAMC,KAAA,GACJjF,GAAA,CAAI+B,OAAO,CAACmD,MAAM,CAACH,gBAAA,CAAiB,IACnC,CAACnG,KAAA,CAAMuG,eAAe,IAAIvG,KAAA,CAAMsG,MAAM,EAAE1B,IAAI,CAC1CwB,SAAA,IAAc,OAAOA,SAAA,KAAc,YAAYA,SAAA,CAAUI,IAAI,KAAKL,gBAAA;YAGvE,IAAI,CAACE,KAAA,EAAO;cACV,MAAM,IAAII,KAAA,CACR,oBAAoBpC,GAAA,CAAI+B,SAAS,8GAA8G/E,UAAA,GAAa;YAEhK;YAEA,MAAM;cAAEqF,WAAW;cAAEC;YAAe,CAAE,GAAGpI,cAAA,CAAe;cACtD8H,KAAA;cACA/E,MAAA,EAAQA,MAAA,GAAStB,KAAA,CAAMmC,IAAI,CAAC;cAC5BZ;YACF;YAEA,MAAMgD,OAAA,GAAUzD,IAAA,GAAO,MAAMoF,CAAA;YAE7B,IAAIG,KAAA,EAAO;cACThC,GAAA,CAAI7E,EAAE,GAAG6E,GAAA,EAAK7E,EAAA,IAAM,IAAIJ,QAAA,GAAWoF,WAAW;cAE9C,IAAI,CAAChE,WAAA,KAAgB,CAACN,MAAA,IAAUA,MAAA,CAAOX,IAAA,CAAI,GAAI;gBAC7C;gBACA,MAAMkF,KAAA,GAAQF,OAAA,GAAU;gBAExB7C,KAAK,CAAC+C,KAAA,CAAM,GAAG;kBACbxB,YAAA,EAAcoB,GAAA,CAAI7E,EAAE;kBACpBkF,KAAA,EAAOL,GAAA,CAAI7E;gBACb;gBAEA;gBACA,IACEqG,6BAAA,EAA+Be,iBAAA,EAAmBlB,MAAA,IAClDG,6BAAA,CAA8Be,iBAAiB,CAACnD,QAAQ,CAACY,GAAA,CAAI+B,SAAS,GACtE;kBACA1E,KAAK,CAAC+C,KAAA,CAAM,CAACb,YAAY,GAAGxC,GAAA,CAAIyF,CAAC,CAAC,2BAA2B;oBAC3DR,KAAA,EAAOhC,GAAA,CAAI+B;kBACb;kBACA1E,KAAK,CAAC+C,KAAA,CAAM,CAACd,KAAK,GAAG;kBACrBlE,oBAAA,CAAqBgF,KAAA;kBAErB;kBACA;kBACA;kBACA;kBACA3C,UAAA,CAAW0B,UAAU,GAAG1B,UAAA,CAAW0B,UAAU,CAACtD,MAAM,CACjDqD,SAAA,IAAcA,SAAA,KAAczC,IAAA;gBAEjC;gBAEA,IAAIT,aAAA,EAAe;kBACjBqB,KAAK,CAAC+C,KAAA,CAAM,CAACxC,WAAW,GAAG5B,aAAA,GACvBgG,KAAA,CAAM1B,MAAM,CAACC,IAAI,CAAEkC,UAAA,IAAehI,SAAA,CAAUgI,UAAA,KAC5CrE,SAAA;gBACN;gBAEA;gBACA,MAAMsE,QAAA,GAAWxC,OAAA,GAAU;gBAE3B7C,KAAK,CAACqF,QAAA,CAAS,GAAG;kBAChB9D,YAAA,EAAcoB,GAAA,CAAI+B,SAAS;kBAC3B1B,KAAA,EAAOL,GAAA,CAAI+B;gBACb;gBAEA,IAAIpE,aAAA,EAAe;kBACjBN,KAAK,CAACqF,QAAA,CAAS,CAAC/E,aAAa,GAAGA,aAAA;gBAClC;gBAEA,IAAI3B,aAAA,EAAe;kBACjBqB,KAAK,CAACqF,QAAA,CAAS,CAAC9E,WAAW,GAAGoE,KAAA,CAAM1B,MAAM,CAACC,IAAI,CAC5CkC,UAAA,IAAe,UAAUA,UAAA,IAAcA,UAAA,CAAW3E,IAAI,KAAK;gBAEhE;gBAEA;gBACA,MAAM6E,YAAA,GAAezC,OAAA,GAAU;gBAE/B7C,KAAK,CAACsF,YAAA,CAAa,GAAG,CAAC;gBAEvB,IAAI3C,GAAA,CAAI4C,SAAS,EAAE;kBACjBvF,KAAK,CAACsF,YAAA,CAAa,CAAC/D,YAAY,GAAGoB,GAAA,CAAI4C,SAAS;kBAChDvF,KAAK,CAACsF,YAAA,CAAa,CAACtC,KAAK,GAAGL,GAAA,CAAI4C,SAAS;gBAC3C;gBAEA,IAAI5G,aAAA,EAAe;kBACjBqB,KAAK,CAACsF,YAAA,CAAa,CAAC/E,WAAW,GAAGoE,KAAA,CAAM1B,MAAM,CAACC,IAAI,CAChDkC,UAAA,IAAe,UAAUA,UAAA,IAAcA,UAAA,CAAW3E,IAAI,KAAK;gBAEhE;cACF;cAEAiC,GAAA,CAAIH,QAAQ,CAACP,IAAI,CACfvE,aAAA,CAAc;gBACZK,EAAA;gBACAC,oBAAA;gBACAE,kBAAA,EAAoBK,KAAA,CAAM6E,SAAS,IAAIlF,kBAAA;gBACvCC,SAAA,EAAWyE,GAAA;gBACXxE,oBAAA;gBACAC,cAAA;gBACAC,IAAA,EAAMsE,GAAA;gBACNM,MAAA,EAAQ0B,KAAA,CAAM1B,MAAM;gBACpB1E,cAAA;gBACAC,MAAA;gBACAC,cAAA;gBACAC,QAAA;gBACAC,aAAA;gBACAE,QAAA;gBACAC,WAAA;gBACAC,SAAA;gBACAqE,eAAA,EAAiB;gBACjBC,qBAAA,EAAuBlE,eAAA;gBACvBH,UAAA,EAAY6D,OAAA;gBACZ3D,gBAAA,EAAkBS,UAAA,GAAa,MAAMgF,KAAA,CAAMG,IAAI;gBAC/CxB,WAAA,EACEnD,gBAAA,KAAqB,OACjBA,gBAAA,GACAlB,iBAAA,GAAoBX,KAAA,CAAMmC,IAAI,CAAC,EAAEmE,MAAA,GAASD,KAAA,CAAMG,IAAI,CAAC,KAAK,OACxD,OACA7F,iBAAA,GAAoBX,KAAA,CAAMmC,IAAI,CAAC,EAAEmE,MAAA,GAASD,KAAA,CAAMG,IAAI,CAAC,EAAE7B,MAAA,IAAU,CAAC;gBAC1E5D,WAAA;gBACAC,iBAAA;gBACAC,QAAA;gBACAC,eAAA;gBACAC,aAAA;gBACAC,GAAA;gBACAE,MAAA,EAAQ,OAAOoF,WAAA,KAAgB,WAAWA,WAAA,GAAcjE,SAAA;gBACxDlB,UAAA,EAAYoF,eAAA;gBACZnF,mBAAA;gBACAC,cAAA;gBACAC;cACF;cAGF;cACA,MAAMuD,WAAA,GAAmB,CAACjE,iBAAA,GAAoBF,IAAA,CAAK,EAAEoD,IAAA,IAAQ,EAAE,EAAEU,IAAI,CAClEM,OAAA,IAAYA,OAAA,CAAQ1F,EAAE,KAAK6E,GAAA,CAAI7E,EAAE;cAGpC,MAAM2F,MAAA,GAAc;gBAClB3F,EAAA,EAAI6E,GAAA,CAAI7E,EAAE;gBACV4G,SAAA,EAAW/B,GAAA,CAAI+B,SAAS;gBACxBhB,SAAA,EAAW;cACb;cAEA,IAAIH,WAAA,EAAalD,gBAAA,EAAkB;gBACjCoD,MAAA,CAAOpD,gBAAgB,GAAGkD,WAAA,CAAYlD,gBAAgB;cACxD;cAEAqC,GAAA,CAAI6B,WAAW,CAACvC,IAAI,CAACyB,MAAA;cAErB,MAAME,WAAA,GAAcnG,cAAA,CAAe;gBACjCoG,cAAA,EAAgBvE,WAAA,EAAa4D,MAAA,GAAS7D,IAAA,CAAK,EAAEyE,SAAA;gBAC7CvF,KAAA;gBACAiF,WAAA;gBACAZ;cACF;cAEA,IAAIgB,WAAA,EAAa;gBACfjB,GAAA,CAAI6B,WAAW,CAAC7B,GAAA,CAAI6B,WAAW,CAACP,MAAM,GAAG,EAAE,CAACH,SAAS,GAAG;cAC1D;YACF;YAEA,OAAOnB,GAAA;UACT,GACA;YACEH,QAAA,EAAU,EAAE;YACZgC,WAAA,EAAa;UACf;UAGF,MAAMT,OAAA,CAAQC,GAAG,CAACxB,QAAA;UAElB;UACA,IAAIlE,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,KAAK,MAAM;YAC7BL,UAAA,CAAW4C,KAAK,GAAG;YACnB5C,UAAA,CAAWmB,YAAY,GAAG;UAC5B,OAAO;YACLnB,UAAA,CAAW4C,KAAK,GAAGvE,cAAA,GAAiByF,WAAA,GAAcA,WAAA,CAAYF,MAAM;YACpE5D,UAAA,CAAWmB,YAAY,GAAG9C,cAAA,GAAiByF,WAAA,GAAcA,WAAA,CAAYF,MAAM;YAE3E,IAAIE,WAAA,CAAYF,MAAM,GAAG,GAAG;cAC1B5D,UAAA,CAAW6D,eAAe,GAAG;YAC/B;UACF;UAEA7D,UAAA,CAAWoC,IAAI,GAAG+B,WAAA;UAElB;UACA,IAAI,CAACzF,WAAA,KAAgB,CAACN,MAAA,IAAUA,MAAA,CAAOX,IAAA,CAAI,GAAI;YAC7CmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;MAEA,KAAK;QAAS;UACZ,IAAI,CAAC5B,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;YAC3BuC,UAAA,CAAW6D,eAAe,GAAG;YAC7BjE,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA,MAAMoF,WAAA,GAAc5F,MAAA,GAAStB,KAAA,CAAMmC,IAAI,CAAC;UAExC,MAAMhD,aAAA,CAAc;YAClBK,EAAA;YACAC,oBAAA;YACAE,kBAAA,EAAoBK,KAAA,CAAM6E,SAAS,IAAIlF,kBAAA;YACvCC,SAAA;YACAC,oBAAA;YACAC,cAAA;YACAC,IAAA,EAAMA,IAAA,GAAOC,KAAA,CAAMmC,IAAI,CAAC,IAAI,CAAC;YAC7BwC,MAAA,EAAQ3E,KAAA,CAAM2E,MAAM;YACpB1E,cAAA;YACAC,MAAA;YACAC,cAAA;YACAC,QAAA;YACAC,aAAA;YACAE,QAAA;YACAC,WAAA;YACAC,SAAA;YACAqE,eAAA,EAAiB;YACjBC,qBAAA,EAAuBlE,eAAA;YACvBH,UAAA,EAAYI,IAAA;YACZF,gBAAA,EAAkBS,UAAA;YAClB2D,WAAA,EACE,OAAOnD,gBAAA,KAAqB,YAAYA,gBAAA,GAAmBA,gBAAA,EAAkB8C,MAAA;YAC/E5D,WAAA;YACAC,iBAAA;YACAC,QAAA;YACAC,eAAA;YACAC,aAAA;YACAC,GAAA;YACAE,MAAA,EAAQ,OAAO4F,WAAA,KAAgB,WAAWA,WAAA,GAAczE,SAAA;YACxDlB,UAAA;YACAC,mBAAA;YACAC,cAAA;YACAC;UACF;UAEA;QACF;MAEA,KAAK;MACL,KAAK;QAAU;UACb,IAAI1B,KAAA,CAAM8F,aAAa,EAAE;YACvB,IAAI,OAAO9F,KAAA,CAAM8F,aAAa,KAAK,UAAU;cAC3C,IAAI,OAAO9F,KAAA,CAAMmH,UAAU,KAAK,UAAU;gBACxCrF,UAAA,CAAWgE,aAAa,GAAG;kBACzB,CAAC9F,KAAA,CAAMmH,UAAU,GAAGnH,KAAA,CAAM8F;gBAC5B;cACF,OAAO;gBACLhE,UAAA,CAAWgE,aAAa,GAAG9F,KAAA,CAAMmH,UAAU,CAAChD,MAAM,CAAC,CAACC,GAAA,EAAKgD,QAAA;kBACvDhD,GAAG,CAACgD,QAAA,CAAS,GAAGpH,KAAA,CAAM8F,aAAa;kBACnC,OAAO1B,GAAA;gBACT,GAAG,CAAC;cACN;YACF;YAEA,IAAI,OAAOpE,KAAA,CAAM8F,aAAa,KAAK,YAAY;cAC7C,MAAMuB,KAAA,GAAQ,MAAMpI,oBAAA,CAAqBe,KAAA,CAAM8F,aAAa,EAAE;gBAC5DtG,EAAA;gBACAI,SAAA;gBACAG,IAAA,EAAMK,QAAA;gBACN+G,UAAA,EAAYnH,KAAA,CAAMmH,UAAU;gBAC5B/F,GAAA;gBACAmB,WAAA,EAAaxC,IAAA;gBACbuH,IAAA,EAAMlG,GAAA,CAAIkG;cACZ;cAEAxF,UAAA,CAAWgE,aAAa,GAAGuB,KAAA;YAC7B;UACF;UAEA,IAAIrH,KAAA,CAAMuH,OAAO,EAAE;YACjB,MAAMC,iBAAA,GAAoB1D,KAAA,CAAMC,OAAO,CAAChE,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,IACpDpC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,CAACsF,GAAG,CAAEC,YAAA;cACpB,IAAI5D,KAAA,CAAMC,OAAO,CAAC/D,KAAA,CAAMmH,UAAU,GAAG;gBACnC,OAAO;kBACLA,UAAA,EAAYO,YAAA,CAAaP,UAAU;kBACnCzC,KAAA,EACEgD,YAAA,CAAahD,KAAK,IAAI,OAAOgD,YAAA,CAAahD,KAAK,KAAK,WAChDgD,YAAA,CAAahD,KAAK,EAAElF,EAAA,GACpBkI,YAAA,CAAahD;gBACrB;cACF;cACA,IAAI,OAAOgD,YAAA,KAAiB,YAAYA,YAAA,KAAiB,MAAM;gBAC7D,OAAOA,YAAA,CAAalI,EAAE;cACxB;cACA,OAAOkI,YAAA;YACT,KACAjF,SAAA;YAEJX,UAAA,CAAW4C,KAAK,GAAG8C,iBAAA;YACnB1F,UAAA,CAAWmB,YAAY,GAAGuE,iBAAA;UAC5B,OAAO,IAAI1D,KAAA,CAAMC,OAAO,CAAC/D,KAAA,CAAMmH,UAAU,GAAG;YAC1C,IACEpH,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,IAChB,OAAOpC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,KAAK,YAC5B,gBAAgBpC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,IAChC,WAAWpC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,EAC3B;cACA,MAAMuC,KAAA,GACJ,OAAO3E,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,EAAEuC,KAAA,KAAU,YACnC3E,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,EAAEuC,KAAA,IAClB,QAAQ3E,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,CAACuC,KAAK,GAC1B3E,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,CAACuC,KAAK,CAAClF,EAAE,GACzBO,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,CAACuC,KAAK;cAC5B,MAAM8C,iBAAA,GAAoB;gBACxBL,UAAA,EAAYpH,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,EAAEgF,UAAA;gBAC9BzC;cACF;cACA5C,UAAA,CAAW4C,KAAK,GAAG8C,iBAAA;cACnB1F,UAAA,CAAWmB,YAAY,GAAGuE,iBAAA;YAC5B;UACF,OAAO;YACL,MAAMA,iBAAA,GACJzH,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,IAAI,OAAOpC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,KAAK,YAAY,QAAQpC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,GAChFpC,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,CAAC3C,EAAE,GACnBO,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC;YACtBL,UAAA,CAAW4C,KAAK,GAAG8C,iBAAA;YACnB1F,UAAA,CAAWmB,YAAY,GAAGuE,iBAAA;UAC5B;UAEA,IAAI,CAACtH,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;YAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;MAEA,KAAK;QAAU;UACb,IAAI,OAAO9B,KAAA,CAAM8F,aAAa,KAAK,YAAY;YAC7ChE,UAAA,CAAW6F,mBAAmB,GAAG3H,KAAA,CAAM8F,aAAa,CAAC;cACnD/F,IAAA,EAAMK,QAAA;cACNwH,OAAA,EAAS5H,KAAA,CAAM4H,OAAO;cACtBxG,GAAA;cACAmB,WAAA,EAAaxC;YACf;UACF;UAEA,IAAIA,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,KAAKM,SAAA,EAAW;YAClCX,UAAA,CAAW4C,KAAK,GAAG3E,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC;YACnCL,UAAA,CAAWmB,YAAY,GAAGlD,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC;UAC5C;UAEA,IAAI,CAACjC,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;YAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;MAEA;QAAS;UACP,IAAI/B,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC,KAAKM,SAAA,EAAW;YAClCX,UAAA,CAAW4C,KAAK,GAAG3E,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC;YACnCL,UAAA,CAAWmB,YAAY,GAAGlD,IAAI,CAACC,KAAA,CAAMmC,IAAI,CAAC;UAC5C;UAEA;UACA,IAAI,CAACjC,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;YAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;UAChB;UAEA;QACF;IACF;EACF,OAAO,IAAIlD,iBAAA,CAAkBoB,KAAA,KAAU,CAACrB,gBAAA,CAAiBqB,KAAA,GAAQ;IAC/D;IAEA,IAAI,CAACE,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;MAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAG;QACZ6E,eAAA,EAAiB;MACnB;MAEA,IAAI9E,eAAA,KAAoB,OAAO;QAC7Ba,KAAK,CAACZ,IAAA,CAAK,CAACD,eAAe,GAAG;MAChC;IACF;IAEA,MAAM1B,aAAA,CAAc;MAClBK,EAAA;MACAe,QAAA;MACAe,MAAA;MACAC,UAAA;MACA;MACA9B,oBAAA,EAAsBC,uBAAA;MACtBC,kBAAA,EAAoBZ,gBAAA,CAAiBiB,KAAA,KAAUL,kBAAA;MAC/CC,SAAA;MACAC,oBAAA;MACAC,cAAA;MACAC,IAAA;MACA4E,MAAA,EAAQ3E,KAAA,CAAM2E,MAAM;MACpB1E,cAAA;MACAC,MAAA;MACAC,cAAA;MACAC,QAAA;MACAC,aAAA;MACAG,WAAA;MACAC,SAAA;MACAqE,eAAA,EAAiBxE,SAAA;MACjByE,qBAAA,EAAuBlE,eAAA;MACvBH,UAAA,EAAYI,IAAA;MACZF,gBAAA,EAAkBS,UAAA;MAClB2D,WAAA,EAAarE,iBAAA;MACbI,WAAA;MACAC,iBAAA;MACAC,QAAA;MACAC,eAAA;MACAC,aAAA;MACAC,GAAA;MACAI,mBAAA;MACAC,cAAA;MACAC;IACF;EACF,OAAO,IAAI1B,KAAA,CAAMkC,IAAI,KAAK,OAAO;IAC/B,MAAM2F,UAAA,GAAa7I,UAAA,CAAWgB,KAAA;IAC9B,IAAI8H,SAAA;IAEJ,MAAMC,QAAA,GAAuB;MAC3B,GAAG/H,KAAK;MACRkC,IAAA,EAAM;IACR;IAEA,IAAI8F,gBAAA,GAA+CvF,SAAA;IAEnD,IAAIoF,UAAA,EAAY;MACd,MAAMI,cAAA,GAAiBzJ,qBAAA,CAAsB;QAC3CwB,KAAA,EAAO+H,QAAA;QACPzG,MAAA;QACAC,UAAA;QACA2G,UAAA,EAAYnI,IAAA,GAAOC,KAAA,CAAMmC,IAAI,CAAC,IAAI,CAAC;MACrC;MAEA,IAAI,CAAC8F,cAAA,EAAgB;QACnB;MACF;MAEA,IAAItH,iBAAA,KAAsB,MAAM;QAC9BqH,gBAAA,GAAmB;MACrB,OAAO;QACL,MAAMG,cAAA,GAAiBxH,iBAAA,GAAoBX,KAAA,CAAMmC,IAAI,CAAC;QACtD,IAAIgG,cAAA,KAAmB,MAAM;UAC3BH,gBAAA,GAAmB;QACrB,OAAO;UACLA,gBAAA,GAAmBG,cAAA,EAAgBxD,MAAA;QACrC;MACF;MAEA,IAAI,OAAOrD,MAAA,GAAStB,KAAA,CAAMmC,IAAI,CAAC,KAAK,UAAU;QAC5C2F,SAAA,GAAYxG,MAAA,GAAStB,KAAA,CAAMmC,IAAI,CAAC;MAClC;IACF,OAAO;MACL6F,gBAAA,GAAmBrH,iBAAA;MACnBmH,SAAA,GAAYxG,MAAA;IACd;IAEA,MAAM8G,YAAA,GAAetH,IAAA,GAAOA,IAAA,CAAKuH,KAAK,CAAC,OAAO,EAAE;IAEhD;IACA;IACA,IAAIC,kBAAA,GAAqBzH,eAAA;IAEzB,IAAIA,eAAA,IAAmB,OAAOb,KAAA,CAAMuI,KAAK,EAAEC,SAAA,KAAc,YAAY;MACnEF,kBAAA,GAAqBtI,KAAA,CAAMuI,KAAK,CAACC,SAAS,CAACpI,QAAA,EAAUL,IAAA,EAAM;QACzDH,SAAA;QACAa,SAAA;QACAK,IAAA,EAAMsH,YAAA;QACNd,IAAA,EAAMlG,GAAA,CAAIkG;MACZ;IACF;IAEA,IAAItH,KAAA,EAAOR,EAAA,EAAI;MACbkC,KAAK,CAAC1B,KAAA,CAAMR,EAAE,CAAC,GAAG;QAChBqB,eAAA,EAAiByH;MACnB;IACF;IAEA,OAAOnJ,aAAA,CAAc;MACnBK,EAAA;MACAC,oBAAA,EAAsBC,uBAAA;MACtBC,kBAAA,EAAoBK,KAAA,CAAM6E,SAAS,IAAIlF,kBAAA;MACvCC,SAAA;MACAC,oBAAA;MACAC,cAAA;MACAC,IAAA,EAAM8H,UAAA,GAAa9H,IAAA,GAAOC,KAAA,CAAMmC,IAAI,CAAC,IAAI,CAAC,IAAIpC,IAAA;MAC9C4E,MAAA,EAAQ3E,KAAA,CAAM2E,MAAM;MACpB1E,cAAA;MACAC,MAAA;MACAC,cAAA;MACAC,QAAA;MACAC,aAAA;MACAE,QAAA;MACAC,WAAA;MACAC,SAAA;MACAqE,eAAA,EAAiBxE,SAAA;MACjByE,qBAAA,EAAuBuD,kBAAA;MACvB5H,UAAA,EAAYI,IAAA;MACZF,gBAAA,EAAkBS,UAAA;MAClB2D,WAAA,EAAagD,gBAAA;MACbjH,WAAA;MACAC,iBAAA;MACAC,QAAA;MACAC,eAAA;MACAC,aAAA;MACAC,GAAA;MACAE,MAAA,EAAQwG,SAAA;MACRvG,UAAA;MACAC,mBAAA;MACAC,cAAA;MACAC;IACF;EACF,OAAO,IAAI1B,KAAA,CAAMkC,IAAI,KAAK,QAAQ;IAChC,OAAO/C,aAAA,CAAc;MACnBK,EAAA;MACAC,oBAAA,EAAsBC,uBAAA;MACtBC,kBAAA,EAAoBZ,gBAAA,CAAiBiB,KAAA,KAAUL,kBAAA;MAC/CC,SAAA;MACAC,oBAAA;MACAC,cAAA;MACAC,IAAA;MACA4E,MAAA,EAAQ3E,KAAA,CAAMyI,IAAI,CAAChB,GAAG,CAAEiB,GAAA,KAAS;QAAE,GAAGA,GAAG;QAAExG,IAAA,EAAM;MAAM;MACvDjC,cAAA;MACAC,MAAA;MACAC,cAAA;MACAC,QAAA;MACAC,aAAA;MACAG,WAAA;MACAC,SAAA;MACAqE,eAAA,EAAiBxE,SAAA;MACjByE,qBAAA,EAAuBlE,eAAA;MACvBH,UAAA,EAAYI,IAAA;MACZF,gBAAA,EAAkBS,UAAA;MAClB2D,WAAA,EAAarE,iBAAA;MACbI,WAAA;MACAC,iBAAA;MACAE,eAAA;MACAC,aAAA;MACAC,GAAA;MACAE,MAAA;MACAC,UAAA;MACAC,mBAAA;MACAC,cAAA;MACAC;IACF;EACF,OAAO,IAAI1B,KAAA,CAAMkC,IAAI,KAAK,MAAM;IAC9B,IAAI,CAAChC,MAAA,IAAUA,MAAA,CAAOX,IAAA,GAAO;MAC3BmC,KAAK,CAACZ,IAAA,CAAK,GAAGgB,UAAA;MACdJ,KAAK,CAACZ,IAAA,CAAK,CAAC6E,eAAe,GAAG;IAChC;EACF;EAEA,IAAIxE,aAAA,IAAiB,CAACtC,uBAAA,CAAwBmB,KAAA,GAAQ;IACpD,MAAM2I,WAAA,GAAc1I,cAAA,CAAe2I,GAAG,CAACvH,UAAA;IAEvC,IAAI,CAACsH,WAAA,IAAe,CAACpI,QAAA,EAAU;MAC7B,IAAIc,UAAA,CAAWwH,QAAQ,CAAC,eAAe;QACrC;MACF,OAAO;QACL,MAAM,IAAIpC,KAAA,CAAM,8BAA8BpF,UAAA,EAAY;MAC5D;IACF;IAEA,IAAI,CAACK,KAAK,CAACZ,IAAA,CAAK,EAAE;MAChB;MACA;MACA;IACF;IAEA,IAAIkB,aAAA,EAAe;MACjBN,KAAK,CAACZ,IAAA,CAAK,CAACkB,aAAa,GAAGA,aAAA;IAC9B;IAEAb,aAAA,CAAc;MACZ3B,EAAA;MACAK,oBAAA;MACAC,cAAA;MACAC,IAAA,EAAMK,QAAA;MACNuI,WAAA,EAAaA,WAAA;MACb1I,cAAA;MACA6B,UAAA,EAAYJ,KAAK,CAACZ,IAAA,CAAK;MACvBgI,SAAA,EAAWpH,KAAA;MACXpB,SAAA;MACAyB,gBAAA;MACAxB,QAAA;MACAE,SAAA;MACAC,UAAA;MACAE,gBAAA;MACAE,IAAA;MACAkE,WAAA,EAAanD,gBAAA;MACbd,WAAA;MACAgI,kBAAA,EAAoB/H,iBAAA,GAAoBF,IAAA,CAAK;MAC7CG,QAAA;MACAC,eAAA;MACAE,GAAA;MACAC,UAAA;MACAkB,WAAA,EAAaxC;IACf;EACF;AACF","ignoreList":[]}