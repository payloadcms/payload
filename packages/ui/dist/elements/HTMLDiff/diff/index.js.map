{"version":3,"file":"index.js","names":["htmlStartTagReg","htmlTagWithNameReg","htmlTagReg","htmlImgTagReg","htmlVideoTagReg","HtmlDiff","config","leastCommonLength","Infinity","matchedBlockList","newTokens","oldTokens","operationList","sideBySideContents","unifiedContent","constructor","oldHtml","newHtml","classNames","createBlock","createInline","deleteBlock","deleteInline","greedyBoundary","greedyMatch","minMatchedSize","tokenizeByCharacter","trim","equalSequence","content","replace","match","name","tagNameLength","length","slice","tokenizeFn","tokenizeByWord","getMatchedBlockList","getOperationList","computeBestMatchedBlock","oldStart","oldEnd","newStart","newEnd","bestMatchedBlock","i","len","Math","min","ret","slideBestMatchedBlock","size","j","computeMatchedBlockList","matchBlock","push","dressUpBlockTag","type","token","dressUpDiffContent","tokens","tokensLength","result","textStartIndex","isMatchElement","includes","isMatchExplicitlyDisabled","isHtmlTag","dressUpText","newToken","dressupMatchEnabledHtmlTag","dressUpInlineTag","tagName","groups","matchType","text","join","n1","n2","start","end","e1","e2","commonLength","floor","unshift","walkIndexOld","walkIndexNew","matchedBlock","isOldStartIndexMatched","isNewStartIndexMatched","operationBase","Object","assign","maxIndexOld","maxIndexNew","tailOperationBase","isOldFinished","isNewFinished","addA","addB","maxSize","continuousSize","html","currentPos","tagRegex","exec","beforeTag","substring","index","char","remaining","getSideBySideContents","undefined","forEach","operation","deletedTokens","equalTokens","equalString","startTagMatch","console","error","String","getUnifiedContent","olds","news","createdTokens","createIndex","deleteIndex","deletedToken","matchTagResultD","some","item","splice","isTagInNewFind","tempCreateIndex","createdToken","matchTagResultC","isEnd"],"sources":["../../../../src/elements/HTMLDiff/diff/index.ts"],"sourcesContent":["// Taken and modified from https://github.com/Arman19941113/html-diff/blob/master/packages/html-diff/src/index.ts\n\ninterface MatchedBlock {\n  newEnd: number\n  newStart: number\n  oldEnd: number\n  oldStart: number\n  size: number\n}\n\ninterface Operation {\n  /**\n   * Index of entry in tokenized token list\n   */\n  newEnd: number\n  newStart: number\n  oldEnd: number\n  oldStart: number\n  type: 'create' | 'delete' | 'equal' | 'replace'\n}\n\ntype BaseOpType = 'create' | 'delete'\n\ninterface HtmlDiffConfig {\n  classNames: {\n    createBlock: string\n    createInline: string\n    deleteBlock: string\n    deleteInline: string\n  }\n  greedyBoundary: number\n  greedyMatch: boolean\n  minMatchedSize: number\n}\n\nexport interface HtmlDiffOptions {\n  /**\n   * The classNames for wrapper DOM.\n   * Use this to configure your own styles without importing the built-in CSS file\n   */\n  classNames?: Partial<{\n    createBlock?: string\n    createInline?: string\n    deleteBlock?: string\n    deleteInline?: string\n  }>\n  /**\n   * @defaultValue 1000\n   */\n  greedyBoundary?: number\n  /**\n   * When greedyMatch is enabled, if the length of the sub-tokens exceeds greedyBoundary,\n   * we will use the matched sub-tokens that are sufficiently good, even if they are not optimal, to enhance performance.\n   * @defaultValue true\n   */\n  greedyMatch?: boolean\n  /**\n   * Determine the minimum threshold for calculating common sub-tokens.\n   * You may adjust it to a value larger than 2, but not lower, due to the potential inclusion of HTML tags in the count.\n   * @defaultValue 2\n   */\n  minMatchedSize?: number\n  /**\n   * Whether to tokenize by character or by word.\n   * @defaultValue false\n   */\n  tokenizeByCharacter?: boolean\n}\n\n// eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/optimal-quantifier-concatenation\nconst htmlStartTagReg = /^<(?<name>[^\\s/>]+)[^>]*>$/\n// eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/optimal-quantifier-concatenation\nconst htmlTagWithNameReg = /^<(?<isEnd>\\/)?(?<name>[^\\s>]+)[^>]*>$/\n\nconst htmlTagReg = /^<[^>]+>/\nconst htmlImgTagReg = /^<img[^>]*>$/\nconst htmlVideoTagReg = /^<video[^>]*>.*?<\\/video>$/ms\n\nexport class HtmlDiff {\n  private readonly config: HtmlDiffConfig\n  private leastCommonLength: number = Infinity\n  private readonly matchedBlockList: MatchedBlock[] = []\n  private readonly newTokens: string[] = []\n  private readonly oldTokens: string[] = []\n  private readonly operationList: Operation[] = []\n  private sideBySideContents?: [string, string]\n  private unifiedContent?: string\n\n  constructor(\n    oldHtml: string,\n    newHtml: string,\n    {\n      classNames = {\n        createBlock: 'html-diff-create-block-wrapper',\n        createInline: 'html-diff-create-inline-wrapper',\n        deleteBlock: 'html-diff-delete-block-wrapper',\n        deleteInline: 'html-diff-delete-inline-wrapper',\n      },\n      greedyBoundary = 1000,\n      greedyMatch = true,\n      minMatchedSize = 2,\n      tokenizeByCharacter = false,\n    }: HtmlDiffOptions = {},\n  ) {\n    // init config\n    this.config = {\n      classNames: {\n        createBlock: 'html-diff-create-block-wrapper',\n        createInline: 'html-diff-create-inline-wrapper',\n        deleteBlock: 'html-diff-delete-block-wrapper',\n        deleteInline: 'html-diff-delete-inline-wrapper',\n        ...classNames,\n      },\n      greedyBoundary,\n      greedyMatch,\n      minMatchedSize,\n    }\n    // white space is junk\n    oldHtml = oldHtml.trim()\n    newHtml = newHtml.trim()\n\n    // no need to diff\n    if (oldHtml === newHtml) {\n      this.unifiedContent = oldHtml\n      let equalSequence = 0\n      // eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/optimal-quantifier-concatenation\n      const content = oldHtml.replace(/<([^\\s/>]+)[^>]*>/g, (match: string, name: string) => {\n        const tagNameLength = name.length + 1\n        return `${match.slice(0, tagNameLength)} data-seq=\"${++equalSequence}\"${match.slice(tagNameLength)}`\n      })\n      this.sideBySideContents = [content, content]\n      return\n    }\n\n    // step1: split HTML to tokens(atomic tokens)\n    const tokenizeFn = tokenizeByCharacter ? this.tokenizeByCharacter : this.tokenizeByWord\n    this.oldTokens = tokenizeFn(oldHtml)\n    this.newTokens = tokenizeFn(newHtml)\n    // step2: find matched blocks\n    this.matchedBlockList = this.getMatchedBlockList()\n\n    // step3: generate operation list\n    this.operationList = this.getOperationList()\n  }\n\n  // Find the longest matched block between tokens\n  private computeBestMatchedBlock(\n    oldStart: number,\n    oldEnd: number,\n    newStart: number,\n    newEnd: number,\n  ): MatchedBlock | null {\n    let bestMatchedBlock = null\n    for (let i = oldStart; i < oldEnd; i++) {\n      const len = Math.min(oldEnd - i, newEnd - newStart)\n      const ret = this.slideBestMatchedBlock(i, newStart, len)\n      if (ret && (!bestMatchedBlock || ret.size > bestMatchedBlock.size)) {\n        bestMatchedBlock = ret\n        if (ret.size > this.leastCommonLength) {\n          return bestMatchedBlock\n        }\n      }\n    }\n    for (let j = newStart; j < newEnd; j++) {\n      const len = Math.min(oldEnd - oldStart, newEnd - j)\n      const ret = this.slideBestMatchedBlock(oldStart, j, len)\n      if (ret && (!bestMatchedBlock || ret.size > bestMatchedBlock.size)) {\n        bestMatchedBlock = ret\n        if (ret.size > this.leastCommonLength) {\n          return bestMatchedBlock\n        }\n      }\n    }\n    return bestMatchedBlock\n  }\n\n  private computeMatchedBlockList(\n    oldStart: number,\n    oldEnd: number,\n    newStart: number,\n    newEnd: number,\n    matchedBlockList: MatchedBlock[] = [],\n  ): MatchedBlock[] {\n    const matchBlock = this.computeBestMatchedBlock(oldStart, oldEnd, newStart, newEnd)\n\n    if (!matchBlock) {\n      return []\n    }\n\n    if (oldStart < matchBlock.oldStart && newStart < matchBlock.newStart) {\n      this.computeMatchedBlockList(\n        oldStart,\n        matchBlock.oldStart,\n        newStart,\n        matchBlock.newStart,\n        matchedBlockList,\n      )\n    }\n    matchedBlockList.push(matchBlock)\n    if (oldEnd > matchBlock.oldEnd && newEnd > matchBlock.newEnd) {\n      this.computeMatchedBlockList(\n        matchBlock.oldEnd,\n        oldEnd,\n        matchBlock.newEnd,\n        newEnd,\n        matchedBlockList,\n      )\n    }\n    return matchedBlockList\n  }\n\n  private dressUpBlockTag(type: BaseOpType, token: string): string {\n    if (type === 'create') {\n      return `<div class=\"${this.config.classNames.createBlock}\">${token}</div>`\n    }\n    if (type === 'delete') {\n      return `<div class=\"${this.config.classNames.deleteBlock}\">${token}</div>`\n    }\n    return ''\n  }\n\n  private dressUpDiffContent(type: BaseOpType, tokens: string[]): string {\n    const tokensLength = tokens.length\n    if (!tokensLength) {\n      return ''\n    }\n\n    let result = ''\n    let textStartIndex = 0\n    let i = -1\n    for (const token of tokens) {\n      i++\n\n      // If this is true, this HTML should be diffed as well - not just its children\n      const isMatchElement = token.includes('data-enable-match=\"true\"')\n      const isMatchExplicitlyDisabled = token.includes('data-enable-match=\"false\"')\n      const isHtmlTag = !!token.match(htmlTagReg)?.length\n\n      if (isMatchExplicitlyDisabled) {\n        textStartIndex = i + 1\n        result += token\n      }\n      // this token is html tag\n      else if (!isMatchElement && isHtmlTag) {\n        // handle text tokens before\n        if (i > textStartIndex) {\n          result += this.dressUpText(type, tokens.slice(textStartIndex, i))\n        }\n        // handle this tag\n        textStartIndex = i + 1\n        if (token.match(htmlVideoTagReg)) {\n          result += this.dressUpBlockTag(type, token)\n        } /* else if ([htmlImgTagReg].some((item) => token.match(item))) {\n          result += this.dressUpInlineTag(type, token)\n        }*/ else {\n          result += token\n        }\n      } else if (isMatchElement && isHtmlTag) {\n        // handle text tokens before\n        if (i > textStartIndex) {\n          result += this.dressUpText(type, tokens.slice(textStartIndex, i))\n        }\n\n        // handle this tag\n        textStartIndex = i + 1\n        // Add data-match-type to the tag that can be styled\n        const newToken = this.dressupMatchEnabledHtmlTag(type, token)\n\n        result += newToken\n      }\n    }\n    if (textStartIndex < tokensLength) {\n      result += this.dressUpText(type, tokens.slice(textStartIndex))\n    }\n    return result\n  }\n\n  private dressUpInlineTag(type: BaseOpType, token: string): string {\n    if (type === 'create') {\n      return `<span class=\"${this.config.classNames.createInline}\">${token}</span>`\n    }\n    if (type === 'delete') {\n      return `<span class=\"${this.config.classNames.deleteInline}\">${token}</span>`\n    }\n    return ''\n  }\n\n  private dressupMatchEnabledHtmlTag(type: BaseOpType, token: string): string {\n    // token is a single html tag, e.g. <a data-enable-match=\"true\" href=\"https://2\" rel=undefined target=undefined>\n    // add data-match-type to the tag\n    const tagName = token.match(htmlStartTagReg)?.groups?.name\n    if (!tagName) {\n      return token\n    }\n    const tagNameLength = tagName.length + 1\n    const matchType = type === 'create' ? 'create' : 'delete'\n    return `${token.slice(0, tagNameLength)} data-match-type=\"${matchType}\"${token.slice(\n      tagNameLength,\n      token.length,\n    )}`\n  }\n\n  private dressUpText(type: BaseOpType, tokens: string[]): string {\n    const text = tokens.join('')\n    if (!text.trim()) {\n      return ''\n    }\n    if (type === 'create') {\n      return `<span data-match-type=\"create\">${text}</span>`\n    }\n    if (type === 'delete') {\n      return `<span data-match-type=\"delete\">${text}</span>`\n    }\n    return ''\n  }\n\n  /**\n   * Generates a list of token entries that are matched between the old and new HTML. This list will not\n   * include token ranges that differ.\n   */\n  private getMatchedBlockList(): MatchedBlock[] {\n    const n1 = this.oldTokens.length\n    const n2 = this.newTokens.length\n\n    // 1. sync from start\n    let start: MatchedBlock | null = null\n    let i = 0\n    while (i < n1 && i < n2 && this.oldTokens[i] === this.newTokens[i]) {\n      i++\n    }\n    if (i >= this.config.minMatchedSize) {\n      start = {\n        newEnd: i,\n        newStart: 0,\n        oldEnd: i,\n        oldStart: 0,\n        size: i,\n      }\n    }\n\n    // 2. sync from end\n    let end: MatchedBlock | null = null\n    let e1 = n1 - 1\n    let e2 = n2 - 1\n    while (i <= e1 && i <= e2 && this.oldTokens[e1] === this.newTokens[e2]) {\n      e1--\n      e2--\n    }\n    const size = n1 - 1 - e1\n    if (size >= this.config.minMatchedSize) {\n      end = {\n        newEnd: n2,\n        newStart: e2 + 1,\n        oldEnd: n1,\n        oldStart: e1 + 1,\n        size,\n      }\n    }\n\n    // 3. handle rest\n    const oldStart = start ? i : 0\n    const oldEnd = end ? e1 + 1 : n1\n    const newStart = start ? i : 0\n    const newEnd = end ? e2 + 1 : n2\n    // optimize for large tokens\n    if (this.config.greedyMatch) {\n      const commonLength = Math.min(oldEnd - oldStart, newEnd - newStart)\n      if (commonLength > this.config.greedyBoundary) {\n        this.leastCommonLength = Math.floor(commonLength / 3)\n      }\n    }\n    const ret = this.computeMatchedBlockList(oldStart, oldEnd, newStart, newEnd)\n    if (start) {\n      ret.unshift(start)\n    }\n    if (end) {\n      ret.push(end)\n    }\n\n    return ret\n  }\n\n  // Generate operation list by matchedBlockList\n  private getOperationList(): Operation[] {\n    const operationList: Operation[] = []\n    let walkIndexOld = 0\n    let walkIndexNew = 0\n    for (const matchedBlock of this.matchedBlockList) {\n      const isOldStartIndexMatched = walkIndexOld === matchedBlock.oldStart\n      const isNewStartIndexMatched = walkIndexNew === matchedBlock.newStart\n      const operationBase = {\n        newEnd: matchedBlock.newStart,\n        newStart: walkIndexNew,\n        oldEnd: matchedBlock.oldStart,\n        oldStart: walkIndexOld,\n      }\n      if (!isOldStartIndexMatched && !isNewStartIndexMatched) {\n        operationList.push(Object.assign(operationBase, { type: 'replace' as const }))\n      } else if (isOldStartIndexMatched && !isNewStartIndexMatched) {\n        operationList.push(Object.assign(operationBase, { type: 'create' as const }))\n      } else if (!isOldStartIndexMatched && isNewStartIndexMatched) {\n        operationList.push(Object.assign(operationBase, { type: 'delete' as const }))\n      }\n\n      operationList.push({\n        type: 'equal',\n        newEnd: matchedBlock.newEnd,\n        newStart: matchedBlock.newStart,\n        oldEnd: matchedBlock.oldEnd,\n        oldStart: matchedBlock.oldStart,\n      })\n      walkIndexOld = matchedBlock.oldEnd\n      walkIndexNew = matchedBlock.newEnd\n    }\n    // handle the tail content\n    const maxIndexOld = this.oldTokens.length\n    const maxIndexNew = this.newTokens.length\n    const tailOperationBase = {\n      newEnd: maxIndexNew,\n      newStart: walkIndexNew,\n      oldEnd: maxIndexOld,\n      oldStart: walkIndexOld,\n    }\n    const isOldFinished = walkIndexOld === maxIndexOld\n    const isNewFinished = walkIndexNew === maxIndexNew\n    if (!isOldFinished && !isNewFinished) {\n      operationList.push(Object.assign(tailOperationBase, { type: 'replace' as const }))\n    } else if (isOldFinished && !isNewFinished) {\n      operationList.push(Object.assign(tailOperationBase, { type: 'create' as const }))\n    } else if (!isOldFinished && isNewFinished) {\n      operationList.push(Object.assign(tailOperationBase, { type: 'delete' as const }))\n    }\n    return operationList\n  }\n\n  private slideBestMatchedBlock(addA: number, addB: number, len: number): MatchedBlock | null {\n    let maxSize = 0\n    let bestMatchedBlock: MatchedBlock | null = null\n\n    let continuousSize = 0\n    for (let i = 0; i < len; i++) {\n      if (this.oldTokens[addA + i] === this.newTokens[addB + i]) {\n        continuousSize++\n      } else {\n        continuousSize = 0\n      }\n      if (continuousSize > maxSize) {\n        maxSize = continuousSize\n        bestMatchedBlock = {\n          newEnd: addB + i + 1,\n          newStart: addB + i - continuousSize + 1,\n          oldEnd: addA + i + 1,\n          oldStart: addA + i - continuousSize + 1,\n          size: continuousSize,\n        }\n      }\n    }\n\n    return maxSize >= this.config.minMatchedSize ? bestMatchedBlock : null\n  }\n\n  /**\n   * Convert HTML to tokens at character level, preserving HTML tags as complete tokens\n   * @example\n   * tokenize(\"<a> Hello World </a>\")\n   * [\"<a>\", \" \", \"H\", \"e\", \"l\", \"l\", \"o\", \" \", \"W\", \"o\", \"r\", \"l\", \"d\", \" \", \"</a>\"]\n   */\n  private tokenizeByCharacter(html: string): string[] {\n    // First, identify HTML tags and preserve them as complete tokens\n    const tokens: string[] = []\n    let currentPos = 0\n\n    // Regular expression to match HTML tags (including picture and video tags with content)\n    const tagRegex = /<picture[^>]*>.*?<\\/picture>|<video[^>]*>.*?<\\/video>|<[^>]+>/gs\n    let match: null | RegExpExecArray\n\n    while ((match = tagRegex.exec(html)) !== null) {\n      // Add characters before the tag\n      const beforeTag = html.substring(currentPos, match.index)\n      if (beforeTag) {\n        // Split non-tag content into individual characters\n        for (const char of beforeTag) {\n          tokens.push(char)\n        }\n      }\n\n      // Add the complete tag as a single token\n      tokens.push(match[0])\n      currentPos = match.index + match[0].length\n    }\n\n    // Add any remaining characters after the last tag\n    const remaining = html.substring(currentPos)\n    for (const char of remaining) {\n      tokens.push(char)\n    }\n\n    return tokens\n  }\n\n  /**\n   * convert HTML to tokens\n   * @example\n   * tokenize(\"<a> Hello World </a>\")\n   * [\"<a>\",\" \", \"Hello\", \" \", \"World\", \" \", \"</a>\"]\n   */\n  private tokenizeByWord(html: string): string[] {\n    // atomic token: html tag、continuous numbers or letters、blank spaces、other symbol\n    return (\n      html.match(\n        /<picture[^>]*>.*?<\\/picture>|<video[^>]*>.*?<\\/video>|<[^>]+>|\\w+\\b|\\s+|[^<>\\w]/gs,\n      ) || []\n    )\n  }\n\n  public getSideBySideContents(): string[] {\n    if (this.sideBySideContents !== undefined) {\n      return this.sideBySideContents\n    }\n\n    let oldHtml = ''\n    let newHtml = ''\n    let equalSequence = 0\n    this.operationList.forEach((operation) => {\n      switch (operation.type) {\n        case 'create': {\n          newHtml += this.dressUpDiffContent(\n            'create',\n            this.newTokens.slice(operation.newStart, operation.newEnd),\n          )\n          break\n        }\n\n        case 'delete': {\n          const deletedTokens = this.oldTokens.slice(operation.oldStart, operation.oldEnd)\n          oldHtml += this.dressUpDiffContent('delete', deletedTokens)\n          break\n        }\n        case 'equal': {\n          const equalTokens = this.newTokens.slice(operation.newStart, operation.newEnd)\n          let equalString = ''\n          for (const token of equalTokens) {\n            // find start tags and add data-seq to enable sync scroll\n            const startTagMatch = token.match(htmlStartTagReg)\n            if (startTagMatch) {\n              equalSequence += 1\n              const tagNameLength = (startTagMatch?.groups?.name?.length ?? 0) + 1\n              equalString += `${token.slice(0, tagNameLength)} data-seq=\"${equalSequence}\"${token.slice(tagNameLength)}`\n            } else {\n              equalString += token\n            }\n          }\n          oldHtml += equalString\n          newHtml += equalString\n          break\n        }\n\n        case 'replace': {\n          oldHtml += this.dressUpDiffContent(\n            'delete',\n            this.oldTokens.slice(operation.oldStart, operation.oldEnd),\n          )\n          newHtml += this.dressUpDiffContent(\n            'create',\n            this.newTokens.slice(operation.newStart, operation.newEnd),\n          )\n          break\n        }\n\n        default: {\n          // eslint-disable-next-line no-console\n          console.error('Richtext diff error - invalid operation: ' + String(operation.type))\n        }\n      }\n    })\n\n    const result: [string, string] = [oldHtml, newHtml]\n    this.sideBySideContents = result\n    return result\n  }\n\n  public getUnifiedContent(): string {\n    if (this.unifiedContent !== undefined) {\n      return this.unifiedContent\n    }\n\n    let result = ''\n    this.operationList.forEach((operation) => {\n      switch (operation.type) {\n        case 'create': {\n          result += this.dressUpDiffContent(\n            'create',\n            this.newTokens.slice(operation.newStart, operation.newEnd),\n          )\n          break\n        }\n\n        case 'delete': {\n          result += this.dressUpDiffContent(\n            'delete',\n            this.oldTokens.slice(operation.oldStart, operation.oldEnd),\n          )\n          break\n        }\n\n        case 'equal': {\n          for (const token of this.newTokens.slice(operation.newStart, operation.newEnd)) {\n            result += token\n          }\n          break\n        }\n\n        case 'replace': {\n          // handle specially tag replace\n          const olds = this.oldTokens.slice(operation.oldStart, operation.oldEnd)\n          const news = this.newTokens.slice(operation.newStart, operation.newEnd)\n          if (\n            olds.length === 1 &&\n            news.length === 1 &&\n            olds[0]?.match(htmlTagReg) &&\n            news[0]?.match(htmlTagReg)\n          ) {\n            result += news[0]\n            break\n          }\n\n          const deletedTokens: string[] = []\n          const createdTokens: string[] = []\n          let createIndex = operation.newStart\n          for (\n            let deleteIndex = operation.oldStart;\n            deleteIndex < operation.oldEnd;\n            deleteIndex++\n          ) {\n            const deletedToken = this.oldTokens[deleteIndex]\n\n            if (!deletedToken) {\n              continue\n            }\n\n            const matchTagResultD = deletedToken?.match(htmlTagWithNameReg)\n            if (matchTagResultD) {\n              // handle replaced tag token\n\n              // skip special tag\n              if ([htmlImgTagReg, htmlVideoTagReg].some((item) => deletedToken?.match(item))) {\n                deletedTokens.push(deletedToken)\n                continue\n              }\n\n              // handle normal tag\n              result += this.dressUpDiffContent('delete', deletedTokens)\n              deletedTokens.splice(0)\n              let isTagInNewFind = false\n              for (\n                let tempCreateIndex = createIndex;\n                tempCreateIndex < operation.newEnd;\n                tempCreateIndex++\n              ) {\n                const createdToken = this.newTokens[tempCreateIndex]\n                if (!createdToken) {\n                  continue\n                }\n                const matchTagResultC = createdToken?.match(htmlTagWithNameReg)\n                if (\n                  matchTagResultC &&\n                  matchTagResultC.groups?.name === matchTagResultD.groups?.name &&\n                  matchTagResultC.groups?.isEnd === matchTagResultD.groups?.isEnd\n                ) {\n                  // find first matched tag, but not maybe the expected tag(to optimize)\n                  isTagInNewFind = true\n                  result += this.dressUpDiffContent('create', createdTokens)\n                  result += createdToken\n                  createdTokens.splice(0)\n                  createIndex = tempCreateIndex + 1\n                  break\n                } else {\n                  createdTokens.push(createdToken)\n                }\n              }\n              if (!isTagInNewFind) {\n                result += deletedToken\n                createdTokens.splice(0)\n              }\n            } else {\n              // token is not a tag\n              deletedTokens.push(deletedToken)\n            }\n          }\n          if (createIndex < operation.newEnd) {\n            createdTokens.push(...this.newTokens.slice(createIndex, operation.newEnd))\n          }\n          result += this.dressUpDiffContent('delete', deletedTokens)\n          result += this.dressUpDiffContent('create', createdTokens)\n          break\n        }\n\n        default: {\n          // eslint-disable-next-line no-console\n          console.error('Richtext diff error - invalid operation: ' + String(operation.type))\n        }\n      }\n    })\n    this.unifiedContent = result\n    return result\n  }\n}\n"],"mappings":"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","ignoreList":[]}