{"version":3,"file":"buildFormState.js","names":["canAccessAdmin","formatErrors","UnauthorizedError","getSelectMode","reduceFieldsToValues","fieldSchemasToFormState","renderField","getClientConfig","getClientSchemaMap","getSchemaMap","handleFormStateLocking","handleLivePreview","handlePreview","buildFormStateHandler","args","req","res","buildFormState","err","payload","logger","error","msg","message","id","idFromArgs","collectionSlug","data","incomingData","docPermissions","docPreferences","documentFormState","formState","globalSlug","initialBlockData","initialBlockFormState","mockRSCs","operation","readOnly","renderAllFields","i18n","config","returnLivePreviewURL","returnLockStatus","returnPreviewURL","schemaPath","select","skipClientConfigAuth","skipValidation","updateLastEdited","selectMode","undefined","Error","schemaMap","clientSchemaMap","importMap","user","fieldOrEntityConfig","get","fields","length","type","documentData","blockData","Array","isArray","formStateResult","clientFieldSchemaMap","fieldSchemaMap","permissions","preferences","previousFormState","renderFieldFn","collections","upload","file","lockedStateResult","lockedState","state","livePreviewURL","previewURL"],"sources":["../../src/utilities/buildFormState.ts"],"sourcesContent":["import type {\n  BuildFormStateArgs,\n  ClientConfig,\n  ClientUser,\n  ErrorResult,\n  FormState,\n  ServerFunction,\n} from 'payload'\n\nimport { canAccessAdmin, formatErrors, UnauthorizedError } from 'payload'\nimport { getSelectMode, reduceFieldsToValues } from 'payload/shared'\n\nimport { fieldSchemasToFormState } from '../forms/fieldSchemasToFormState/index.js'\nimport { renderField } from '../forms/fieldSchemasToFormState/renderField.js'\nimport { getClientConfig } from './getClientConfig.js'\nimport { getClientSchemaMap } from './getClientSchemaMap.js'\nimport { getSchemaMap } from './getSchemaMap.js'\nimport { handleFormStateLocking } from './handleFormStateLocking.js'\nimport { handleLivePreview } from './handleLivePreview.js'\nimport { handlePreview } from './handlePreview.js'\n\nexport type LockedState = {\n  isLocked: boolean\n  lastEditedAt: string\n  user: ClientUser | number | string\n}\n\ntype BuildFormStateSuccessResult = {\n  clientConfig?: ClientConfig\n  errors?: never\n  indexPath?: string\n  livePreviewURL?: string\n  lockedState?: LockedState\n  previewURL?: string\n  state: FormState\n}\n\ntype BuildFormStateErrorResult = {\n  livePreviewURL?: never\n  lockedState?: never\n  previewURL?: never\n  state?: never\n} & (\n  | {\n      message: string\n    }\n  | ErrorResult\n)\n\nexport type BuildFormStateResult = BuildFormStateErrorResult | BuildFormStateSuccessResult\n\nexport const buildFormStateHandler: ServerFunction<\n  BuildFormStateArgs,\n  Promise<BuildFormStateResult>\n> = async (args) => {\n  const { req } = args\n\n  try {\n    await canAccessAdmin({ req })\n    const res = await buildFormState(args)\n\n    return res\n  } catch (err) {\n    req.payload.logger.error({ err, msg: `There was an error building form state` })\n\n    if (err.message === 'Could not find field schema for given path') {\n      return {\n        message: err.message,\n      }\n    }\n\n    if (err.message === 'Unauthorized') {\n      throw new UnauthorizedError()\n    }\n\n    return formatErrors(err)\n  }\n}\n\nexport const buildFormState = async (\n  args: BuildFormStateArgs,\n): Promise<BuildFormStateSuccessResult> => {\n  const {\n    id: idFromArgs,\n    collectionSlug,\n    data: incomingData,\n    docPermissions,\n    docPreferences,\n    documentFormState,\n    formState,\n    globalSlug,\n    initialBlockData,\n    initialBlockFormState,\n    mockRSCs,\n    operation,\n    readOnly,\n    renderAllFields,\n    req,\n    req: {\n      i18n,\n      payload,\n      payload: { config },\n    },\n    returnLivePreviewURL,\n    returnLockStatus,\n    returnPreviewURL,\n    schemaPath = collectionSlug || globalSlug,\n    select,\n    skipClientConfigAuth,\n    skipValidation,\n    updateLastEdited,\n  } = args\n\n  const selectMode = select ? getSelectMode(select) : undefined\n\n  if (!collectionSlug && !globalSlug) {\n    throw new Error('Either collectionSlug or globalSlug must be provided')\n  }\n\n  const schemaMap = getSchemaMap({\n    collectionSlug,\n    config,\n    globalSlug,\n    i18n,\n  })\n\n  const clientSchemaMap = getClientSchemaMap({\n    collectionSlug,\n    config: getClientConfig({\n      config,\n      i18n,\n      importMap: req.payload.importMap,\n      user: skipClientConfigAuth ? true : req.user,\n    }),\n    globalSlug,\n    i18n,\n    payload,\n    schemaMap,\n  })\n\n  const id = collectionSlug ? idFromArgs : undefined\n  const fieldOrEntityConfig = schemaMap.get(schemaPath)\n\n  if (!fieldOrEntityConfig) {\n    throw new Error(`Could not find \"${schemaPath}\" in the fieldSchemaMap`)\n  }\n\n  if (\n    (!('fields' in fieldOrEntityConfig) ||\n      !fieldOrEntityConfig.fields ||\n      !fieldOrEntityConfig.fields.length) &&\n    'type' in fieldOrEntityConfig &&\n    fieldOrEntityConfig.type !== 'blocks'\n  ) {\n    throw new Error(\n      `The field found in fieldSchemaMap for \"${schemaPath}\" does not contain any subfields.`,\n    )\n  }\n\n  // If there is form state but no data, deduce data from that form state, e.g. on initial load\n  // Otherwise, use the incoming data as the source of truth, e.g. on subsequent saves\n  const data = incomingData || reduceFieldsToValues(formState, true)\n\n  let documentData = undefined\n\n  if (documentFormState) {\n    documentData = reduceFieldsToValues(documentFormState, true)\n  }\n\n  let blockData = initialBlockData\n\n  if (initialBlockFormState) {\n    blockData = reduceFieldsToValues(initialBlockFormState, true)\n  }\n\n  /**\n   * When building state for sub schemas we need to adjust:\n   * - `fields`\n   * - `parentSchemaPath`\n   * - `parentPath`\n   *\n   * Type assertion is fine because we wrap sub schemas in an array\n   * so we can safely map over them within `fieldSchemasToFormState`\n   */\n  const fields = Array.isArray(fieldOrEntityConfig)\n    ? fieldOrEntityConfig\n    : 'fields' in fieldOrEntityConfig\n      ? fieldOrEntityConfig.fields\n      : [fieldOrEntityConfig]\n\n  // Ensure data.id is present during form state requests, where the data\n  // is passed from the client as an argument, without the ID\n  if (!data.id && id) {\n    data.id = id\n  }\n\n  const formStateResult = await fieldSchemasToFormState({\n    id,\n    clientFieldSchemaMap: clientSchemaMap,\n    collectionSlug,\n    data,\n    documentData,\n    fields,\n    fieldSchemaMap: schemaMap,\n    initialBlockData: blockData,\n    mockRSCs,\n    operation,\n    permissions: docPermissions?.fields || {},\n    preferences: docPreferences || { fields: {} },\n    previousFormState: formState,\n    readOnly,\n    renderAllFields,\n    renderFieldFn: renderField,\n    req,\n    schemaPath,\n    select,\n    selectMode,\n    skipValidation,\n  })\n\n  // Maintain form state of auth / upload fields\n  if (collectionSlug && formState) {\n    if (payload.collections[collectionSlug]?.config?.upload && formState.file) {\n      formStateResult.file = formState.file\n    }\n  }\n\n  let lockedStateResult\n\n  if (returnLockStatus) {\n    lockedStateResult = await handleFormStateLocking({\n      id,\n      collectionSlug,\n      globalSlug,\n      req,\n      updateLastEdited,\n    })\n  }\n\n  const res: BuildFormStateSuccessResult = {\n    lockedState: lockedStateResult,\n    state: formStateResult,\n  }\n\n  if (returnLivePreviewURL) {\n    const { livePreviewURL } = await handleLivePreview({\n      collectionSlug,\n      config,\n      data,\n      globalSlug,\n      req,\n    })\n\n    // Important: only set this when not undefined,\n    // Otherwise it will travel through the network as `$undefined`\n    if (livePreviewURL) {\n      res.livePreviewURL = livePreviewURL\n    }\n  }\n\n  if (returnPreviewURL) {\n    const { previewURL } = await handlePreview({\n      collectionSlug,\n      config,\n      data,\n      globalSlug,\n      req,\n    })\n\n    // Important: only set this when not undefined,\n    // Otherwise it will travel through the network as `$undefined`\n    if (previewURL) {\n      res.previewURL = previewURL\n    }\n  }\n\n  return res\n}\n"],"mappings":"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","ignoreList":[]}