{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type { KVAdapter, KVAdapterResult, KVStoreValue } from 'payload'\n\nimport { Redis } from 'ioredis'\n\nexport class RedisKVAdapter implements KVAdapter {\n  redisClient: Redis\n\n  constructor(\n    readonly keyPrefix: string,\n    redisURL: string,\n  ) {\n    this.redisClient = new Redis(redisURL)\n  }\n\n  async clear(): Promise<void> {\n    const keys = await this.redisClient.keys(`${this.keyPrefix}*`)\n\n    if (keys.length > 0) {\n      await this.redisClient.del(keys)\n    }\n  }\n\n  async delete(key: string): Promise<void> {\n    await this.redisClient.del(`${this.keyPrefix}${key}`)\n  }\n\n  async get<T extends KVStoreValue>(key: string): Promise<null | T> {\n    const data = await this.redisClient.get(`${this.keyPrefix}${key}`)\n\n    if (data === null) {\n      return null\n    }\n\n    return JSON.parse(data)\n  }\n\n  async has(key: string): Promise<boolean> {\n    const exists = await this.redisClient.exists(`${this.keyPrefix}${key}`)\n    return exists === 1\n  }\n\n  async keys(): Promise<string[]> {\n    const prefixedKeys = await this.redisClient.keys(`${this.keyPrefix}*`)\n\n    if (this.keyPrefix) {\n      return prefixedKeys.map((key) => key.replace(this.keyPrefix, ''))\n    }\n\n    return prefixedKeys\n  }\n\n  async set(key: string, data: KVStoreValue): Promise<void> {\n    await this.redisClient.set(`${this.keyPrefix}${key}`, JSON.stringify(data))\n  }\n}\n\nexport type RedisKVAdapterOptions = {\n  /**\n   * Optional prefix for Redis keys to isolate the store\n   *\n   * @default 'payload-kv:'\n   */\n  keyPrefix?: string\n  /** Redis connection URL (e.g., 'redis://localhost:6379'). Defaults to process.env.REDIS_URL */\n  redisURL?: string\n}\n\nexport const redisKVAdapter = (options: RedisKVAdapterOptions = {}): KVAdapterResult => {\n  const keyPrefix = options.keyPrefix ?? 'payload-kv:'\n  const redisURL = options.redisURL ?? process.env.REDIS_URL\n\n  if (!redisURL) {\n    throw new Error('redisURL or REDIS_URL env variable is required')\n  }\n\n  return {\n    init: () => new RedisKVAdapter(keyPrefix, redisURL),\n  }\n}\n"],"names":["Redis","RedisKVAdapter","redisClient","keyPrefix","redisURL","clear","keys","length","del","delete","key","get","data","JSON","parse","has","exists","prefixedKeys","map","replace","set","stringify","redisKVAdapter","options","process","env","REDIS_URL","Error","init"],"mappings":"AAEA,SAASA,KAAK,QAAQ,UAAS;AAE/B,OAAO,MAAMC;;IACXC,YAAkB;IAElB,YACE,AAASC,SAAiB,EAC1BC,QAAgB,CAChB;aAFSD,YAAAA;QAGT,IAAI,CAACD,WAAW,GAAG,IAAIF,MAAMI;IAC/B;IAEA,MAAMC,QAAuB;QAC3B,MAAMC,OAAO,MAAM,IAAI,CAACJ,WAAW,CAACI,IAAI,CAAC,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC,CAAC;QAE7D,IAAIG,KAAKC,MAAM,GAAG,GAAG;YACnB,MAAM,IAAI,CAACL,WAAW,CAACM,GAAG,CAACF;QAC7B;IACF;IAEA,MAAMG,OAAOC,GAAW,EAAiB;QACvC,MAAM,IAAI,CAACR,WAAW,CAACM,GAAG,CAAC,GAAG,IAAI,CAACL,SAAS,GAAGO,KAAK;IACtD;IAEA,MAAMC,IAA4BD,GAAW,EAAqB;QAChE,MAAME,OAAO,MAAM,IAAI,CAACV,WAAW,CAACS,GAAG,CAAC,GAAG,IAAI,CAACR,SAAS,GAAGO,KAAK;QAEjE,IAAIE,SAAS,MAAM;YACjB,OAAO;QACT;QAEA,OAAOC,KAAKC,KAAK,CAACF;IACpB;IAEA,MAAMG,IAAIL,GAAW,EAAoB;QACvC,MAAMM,SAAS,MAAM,IAAI,CAACd,WAAW,CAACc,MAAM,CAAC,GAAG,IAAI,CAACb,SAAS,GAAGO,KAAK;QACtE,OAAOM,WAAW;IACpB;IAEA,MAAMV,OAA0B;QAC9B,MAAMW,eAAe,MAAM,IAAI,CAACf,WAAW,CAACI,IAAI,CAAC,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC,CAAC;QAErE,IAAI,IAAI,CAACA,SAAS,EAAE;YAClB,OAAOc,aAAaC,GAAG,CAAC,CAACR,MAAQA,IAAIS,OAAO,CAAC,IAAI,CAAChB,SAAS,EAAE;QAC/D;QAEA,OAAOc;IACT;IAEA,MAAMG,IAAIV,GAAW,EAAEE,IAAkB,EAAiB;QACxD,MAAM,IAAI,CAACV,WAAW,CAACkB,GAAG,CAAC,GAAG,IAAI,CAACjB,SAAS,GAAGO,KAAK,EAAEG,KAAKQ,SAAS,CAACT;IACvE;AACF;AAaA,OAAO,MAAMU,iBAAiB,CAACC,UAAiC,CAAC,CAAC;IAChE,MAAMpB,YAAYoB,QAAQpB,SAAS,IAAI;IACvC,MAAMC,WAAWmB,QAAQnB,QAAQ,IAAIoB,QAAQC,GAAG,CAACC,SAAS;IAE1D,IAAI,CAACtB,UAAU;QACb,MAAM,IAAIuB,MAAM;IAClB;IAEA,OAAO;QACLC,MAAM,IAAM,IAAI3B,eAAeE,WAAWC;IAC5C;AACF,EAAC"}