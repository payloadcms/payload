{"version":3,"sources":["../src/handleMessage.ts"],"sourcesContent":["import type { CollectionPopulationRequestHandler, LivePreviewMessageEvent } from './types.js'\n\nimport { isLivePreviewEvent } from './isLivePreviewEvent.js'\nimport { mergeData } from './mergeData.js'\n\nconst _payloadLivePreview: {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  previousData: any\n} = {\n  /**\n   * Each time the data is merged, cache the result as a `previousData` variable\n   * This will ensure changes compound overtop of each other\n   */\n  previousData: undefined,\n}\n\n// Reset the internal cached merged data. This is useful when navigating\n// between routes where a new subscription should not inherit prior data.\nexport const resetCache = (): void => {\n  _payloadLivePreview.previousData = undefined\n}\n\nexport const handleMessage = async <T extends Record<string, any>>(args: {\n  apiRoute?: string\n  depth?: number\n  event: LivePreviewMessageEvent<T>\n  initialData: T\n  requestHandler?: CollectionPopulationRequestHandler\n  serverURL: string\n}): Promise<T> => {\n  const { apiRoute, depth, event, initialData, requestHandler, serverURL } = args\n\n  if (isLivePreviewEvent(event, serverURL)) {\n    const { collectionSlug, data, globalSlug, locale } = event.data\n\n    // Only attempt to merge when we have a clear target\n    // Either a collectionSlug or a globalSlug must be present\n    if (!collectionSlug && !globalSlug) {\n      return initialData\n    }\n\n    const mergedData = await mergeData<T>({\n      apiRoute,\n      collectionSlug,\n      depth,\n      globalSlug,\n      incomingData: data,\n      initialData: _payloadLivePreview?.previousData || initialData,\n      locale,\n      requestHandler,\n      serverURL,\n    })\n\n    _payloadLivePreview.previousData = mergedData\n\n    return mergedData\n  }\n\n  if (!_payloadLivePreview.previousData) {\n    _payloadLivePreview.previousData = initialData\n  }\n\n  return _payloadLivePreview.previousData as T\n}\n"],"names":["isLivePreviewEvent","mergeData","_payloadLivePreview","previousData","undefined","resetCache","handleMessage","args","apiRoute","depth","event","initialData","requestHandler","serverURL","collectionSlug","data","globalSlug","locale","mergedData","incomingData"],"mappings":"AAEA,SAASA,kBAAkB,QAAQ,0BAAyB;AAC5D,SAASC,SAAS,QAAQ,iBAAgB;AAE1C,MAAMC,sBAGF;IACF;;;GAGC,GACDC,cAAcC;AAChB;AAEA,wEAAwE;AACxE,yEAAyE;AACzE,OAAO,MAAMC,aAAa;IACxBH,oBAAoBC,YAAY,GAAGC;AACrC,EAAC;AAED,OAAO,MAAME,gBAAgB,OAAsCC;IAQjE,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,KAAK,EAAEC,WAAW,EAAEC,cAAc,EAAEC,SAAS,EAAE,GAAGN;IAE3E,IAAIP,mBAAmBU,OAAOG,YAAY;QACxC,MAAM,EAAEC,cAAc,EAAEC,IAAI,EAAEC,UAAU,EAAEC,MAAM,EAAE,GAAGP,MAAMK,IAAI;QAE/D,oDAAoD;QACpD,0DAA0D;QAC1D,IAAI,CAACD,kBAAkB,CAACE,YAAY;YAClC,OAAOL;QACT;QAEA,MAAMO,aAAa,MAAMjB,UAAa;YACpCO;YACAM;YACAL;YACAO;YACAG,cAAcJ;YACdJ,aAAaT,qBAAqBC,gBAAgBQ;YAClDM;YACAL;YACAC;QACF;QAEAX,oBAAoBC,YAAY,GAAGe;QAEnC,OAAOA;IACT;IAEA,IAAI,CAAChB,oBAAoBC,YAAY,EAAE;QACrCD,oBAAoBC,YAAY,GAAGQ;IACrC;IAEA,OAAOT,oBAAoBC,YAAY;AACzC,EAAC"}