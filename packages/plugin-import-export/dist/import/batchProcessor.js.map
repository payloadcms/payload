{"version":3,"sources":["../../src/import/batchProcessor.ts"],"sourcesContent":["import type { PayloadRequest, TypedUser } from 'payload'\n\nimport type { ImportMode, ImportResult } from './createImport.js'\n\nimport {\n  type BatchError,\n  categorizeError,\n  createBatches,\n  extractErrorMessage,\n} from '../utilities/useBatchProcessor.js'\n\n/**\n * Import-specific batch processor options\n */\nexport interface ImportBatchProcessorOptions {\n  batchSize?: number\n  defaultVersionStatus?: 'draft' | 'published'\n}\n\n/**\n * Import-specific error type extending the generic BatchError\n */\nexport interface ImportError extends BatchError<Record<string, unknown>> {\n  documentData: Record<string, unknown>\n  field?: string\n  fieldLabel?: string\n  rowNumber: number // 1-indexed for user clarity\n}\n\n/**\n * Result from processing a single import batch\n */\nexport interface ImportBatchResult {\n  failed: Array<ImportError>\n  successful: Array<{\n    document: Record<string, unknown>\n    index: number\n    operation?: 'created' | 'updated'\n    result: Record<string, unknown>\n  }>\n}\n\n/**\n * Options for processing an import operation\n */\nexport interface ImportProcessOptions {\n  collectionSlug: string\n  documents: Record<string, unknown>[]\n  importMode: ImportMode\n  matchField?: string\n  req: PayloadRequest\n  user?: TypedUser\n}\n\n// Helper function to handle multi-locale data\nfunction extractMultiLocaleData(\n  data: Record<string, unknown>,\n  configuredLocales?: string[],\n): {\n  flatData: Record<string, unknown>\n  hasMultiLocale: boolean\n  localeUpdates: Record<string, Record<string, unknown>>\n} {\n  const flatData: Record<string, unknown> = {}\n  const localeUpdates: Record<string, Record<string, unknown>> = {}\n  let hasMultiLocale = false\n\n  // If no locales configured, skip multi-locale processing\n  if (!configuredLocales || configuredLocales.length === 0) {\n    return { flatData: { ...data }, hasMultiLocale: false, localeUpdates: {} }\n  }\n\n  const localeSet = new Set(configuredLocales)\n\n  for (const [key, value] of Object.entries(data)) {\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n      const valueObj = value as Record<string, unknown>\n      // Check if this object has keys matching configured locales\n      const localeKeys = Object.keys(valueObj).filter((k) => localeSet.has(k))\n      if (localeKeys.length > 0) {\n        hasMultiLocale = true\n        // This is a localized field with explicit locale keys\n        // Use the first locale for initial creation, then update others\n        const firstLocale = localeKeys[0]\n        if (firstLocale) {\n          flatData[key] = valueObj[firstLocale]\n          // Store other locales for later update\n          for (const locale of localeKeys) {\n            if (locale !== firstLocale) {\n              if (!localeUpdates[locale]) {\n                localeUpdates[locale] = {}\n              }\n              localeUpdates[locale][key] = valueObj[locale]\n            }\n          }\n        }\n      } else {\n        // Not locale data, keep as is\n        flatData[key] = value\n      }\n    } else {\n      // Not an object, keep as is. this includes localized fields without locale suffix; ie default locale\n      flatData[key] = value\n    }\n  }\n\n  return { flatData, hasMultiLocale, localeUpdates }\n}\n\ntype ProcessImportBatchOptions = {\n  batch: Record<string, unknown>[]\n  batchIndex: number\n  collectionSlug: string\n  importMode: ImportMode\n  matchField: string | undefined\n  options: { batchSize: number; defaultVersionStatus: 'draft' | 'published' }\n  req: PayloadRequest\n  user?: TypedUser\n}\n\nasync function processImportBatch({\n  batch,\n  batchIndex,\n  collectionSlug,\n  importMode,\n  matchField,\n  options,\n  req,\n  user,\n}: ProcessImportBatchOptions): Promise<ImportBatchResult> {\n  const result: ImportBatchResult = {\n    failed: [],\n    successful: [],\n  }\n\n  // Check if the collection has versions enabled\n  const collectionConfig = req.payload.collections[collectionSlug]?.config\n  const collectionHasVersions = Boolean(collectionConfig?.versions)\n\n  // Get configured locales for multi-locale data detection\n  const configuredLocales = req.payload.config.localization\n    ? req.payload.config.localization.localeCodes\n    : undefined\n\n  // Calculate the starting row number for this batch\n  const startingRowNumber = batchIndex * options.batchSize\n\n  for (let i = 0; i < batch.length; i++) {\n    const document = batch[i]\n    if (!document) {\n      continue\n    }\n    const rowNumber = startingRowNumber + i + 1\n\n    try {\n      let processedDoc: Record<string, unknown> | undefined\n      let existing: { docs: Array<Record<string, unknown>> } | undefined\n\n      if (importMode === 'create') {\n        // Remove ID field when creating new document\n        const createData = { ...document }\n        delete createData.id\n\n        // Only handle _status for versioned collections\n        let draftOption: boolean | undefined\n        if (collectionHasVersions) {\n          // Check if _status is set - use defaultVersionStatus from config\n          // If no _status field provided, use the configured default\n          const statusValue = createData._status || options.defaultVersionStatus\n          const isPublished = statusValue !== 'draft'\n          draftOption = !isPublished\n\n          // Debug: log status handling\n          if (req.payload.config.debug) {\n            req.payload.logger.info({\n              _status: createData._status,\n              isPublished,\n              msg: 'Status handling in create',\n              willSetDraft: draftOption,\n            })\n          }\n\n          delete createData._status // Remove _status from data - it's controlled via draft option\n        }\n\n        // Debug: log what we're about to create\n        if (req.payload.config.debug && 'title' in createData) {\n          req.payload.logger.info({\n            msg: 'Creating document',\n            title: createData.title,\n            titleIsNull: createData.title === null,\n            titleType: typeof createData.title,\n          })\n        }\n\n        // Check if we have multi-locale data and extract it\n        const { flatData, hasMultiLocale, localeUpdates } = extractMultiLocaleData(\n          createData,\n          configuredLocales,\n        )\n\n        if (hasMultiLocale) {\n          // Create with default locale data\n          processedDoc = await req.payload.create({\n            collection: collectionSlug,\n            data: flatData,\n            draft: draftOption,\n            overrideAccess: false,\n            req,\n            user,\n          })\n\n          // Update for other locales\n          if (processedDoc && Object.keys(localeUpdates).length > 0) {\n            for (const [locale, localeData] of Object.entries(localeUpdates)) {\n              try {\n                const localeReq = { ...req, locale }\n                await req.payload.update({\n                  id: processedDoc.id as number | string,\n                  collection: collectionSlug,\n                  data: localeData,\n                  draft: collectionHasVersions ? false : undefined,\n                  overrideAccess: false,\n                  req: localeReq,\n                  user,\n                })\n              } catch (error) {\n                // Log but don't fail the entire import if a locale update fails\n                req.payload.logger.error({\n                  err: error,\n                  msg: `Failed to update locale ${locale} for document ${String(processedDoc.id)}`,\n                })\n              }\n            }\n          }\n        } else {\n          // No multi-locale data, create normally\n          processedDoc = await req.payload.create({\n            collection: collectionSlug,\n            data: createData,\n            draft: draftOption,\n            overrideAccess: false,\n            req,\n            user,\n          })\n        }\n      } else if (importMode === 'update' || importMode === 'upsert') {\n        const matchValue = document[matchField || 'id']\n        if (!matchValue) {\n          throw new Error(`Match field \"${matchField || 'id'}\" not found in document`)\n        }\n\n        // Special handling for ID field with MongoDB\n        // If matching by 'id' and it's not a valid ObjectID format, handle specially\n        const isMatchingById = (matchField || 'id') === 'id'\n\n        // Check if it's a valid MongoDB ObjectID format (24 hex chars)\n        // Note: matchValue could be string, number, or ObjectID object\n        let matchValueStr: string\n        if (typeof matchValue === 'object' && matchValue !== null) {\n          matchValueStr = JSON.stringify(matchValue)\n        } else if (typeof matchValue === 'string') {\n          matchValueStr = matchValue\n        } else if (typeof matchValue === 'number') {\n          matchValueStr = matchValue.toString()\n        } else {\n          // For other types, use JSON.stringify\n          matchValueStr = JSON.stringify(matchValue)\n        }\n        const isValidObjectIdFormat = /^[0-9a-f]{24}$/i.test(matchValueStr)\n\n        // Try to search normally first, catch errors for invalid IDs\n        try {\n          existing = await req.payload.find({\n            collection: collectionSlug,\n            depth: 0,\n            limit: 1,\n            overrideAccess: false,\n            req,\n            user,\n            where: {\n              [matchField || 'id']: {\n                equals: matchValue,\n              },\n            },\n          })\n        } catch (error) {\n          // If we get an error when searching by ID (e.g., invalid ObjectID format)\n          // and we're in upsert mode, treat as non-existent\n          if (isMatchingById && importMode === 'upsert' && !isValidObjectIdFormat) {\n            existing = { docs: [] }\n          } else if (isMatchingById && importMode === 'update' && !isValidObjectIdFormat) {\n            // For update mode with invalid ID, this should fail\n            throw new Error(`Invalid ID format for update: ${matchValueStr}`)\n          } else {\n            // Re-throw other errors\n            throw error\n          }\n        }\n\n        if (existing.docs.length > 0) {\n          // Update existing\n          const existingDoc = existing.docs[0]\n          if (!existingDoc) {\n            throw new Error(`Document not found`)\n          }\n\n          // Debug: log what we found\n          if (req.payload.config.debug) {\n            req.payload.logger.info({\n              existingId: existingDoc.id,\n              existingStatus: existingDoc._status,\n              existingTitle: existingDoc.title,\n              incomingDocument: document,\n              mode: importMode,\n              msg: 'Found existing document for update',\n            })\n          }\n\n          const updateData = { ...document }\n          // Remove ID and internal fields from update data\n          delete updateData.id\n          delete updateData._id\n          delete updateData.createdAt\n          delete updateData.updatedAt\n\n          // Check if we have multi-locale data and extract it\n          const { flatData, hasMultiLocale, localeUpdates } = extractMultiLocaleData(\n            updateData,\n            configuredLocales,\n          )\n\n          if (req.payload.config.debug) {\n            req.payload.logger.info({\n              existingId: existingDoc.id,\n              hasMultiLocale,\n              mode: importMode,\n              msg: 'Updating document in upsert/update mode',\n              updateData: Object.keys(hasMultiLocale ? flatData : updateData).reduce(\n                (acc, key) => {\n                  const val = (hasMultiLocale ? flatData : updateData)[key]\n                  acc[key] =\n                    typeof val === 'string' && val.length > 50 ? val.substring(0, 50) + '...' : val\n                  return acc\n                },\n                {} as Record<string, unknown>,\n              ),\n            })\n          }\n\n          if (hasMultiLocale) {\n            // Update with default locale data\n            processedDoc = await req.payload.update({\n              id: existingDoc.id as number | string,\n              collection: collectionSlug,\n              data: flatData,\n              depth: 0,\n              // Don't specify draft - this creates a new draft for versioned collections\n              overrideAccess: false,\n              req,\n              user,\n            })\n\n            // Update for other locales\n            if (processedDoc && Object.keys(localeUpdates).length > 0) {\n              for (const [locale, localeData] of Object.entries(localeUpdates)) {\n                try {\n                  // Clone the request with the specific locale\n                  const localeReq = { ...req, locale }\n                  await req.payload.update({\n                    id: existingDoc.id as number | string,\n                    collection: collectionSlug,\n                    data: localeData,\n                    depth: 0,\n                    // Don't specify draft - this creates a new draft for versioned collections\n                    overrideAccess: false,\n                    req: localeReq,\n                    user,\n                  })\n                } catch (error) {\n                  // Log but don't fail the entire import if a locale update fails\n                  req.payload.logger.error({\n                    err: error,\n                    msg: `Failed to update locale ${locale} for document ${String(existingDoc.id)}`,\n                  })\n                }\n              }\n            }\n          } else {\n            // No multi-locale data, update normally\n            try {\n              // Extra debug: log before update\n              if (req.payload.config.debug) {\n                req.payload.logger.info({\n                  existingId: existingDoc.id,\n                  existingTitle: existingDoc.title,\n                  msg: 'About to update document',\n                  newData: updateData,\n                })\n              }\n\n              // Update the document - don't specify draft to let Payload handle versions properly\n              // This will create a new draft version for collections with versions enabled\n              processedDoc = await req.payload.update({\n                id: existingDoc.id as number | string,\n                collection: collectionSlug,\n                data: updateData,\n                depth: 0,\n                // Don't specify draft - this creates a new draft for versioned collections\n                overrideAccess: false,\n                req,\n                user,\n              })\n\n              // Debug: log what was returned\n              if (req.payload.config.debug && processedDoc) {\n                req.payload.logger.info({\n                  id: processedDoc.id,\n                  msg: 'Update completed',\n                  status: processedDoc._status,\n                  title: processedDoc.title,\n                })\n              }\n            } catch (updateError) {\n              req.payload.logger.error({\n                id: existingDoc.id,\n                err: updateError,\n                msg: 'Update failed',\n              })\n              throw updateError\n            }\n          }\n        } else if (importMode === 'upsert') {\n          // Create new in upsert mode\n          if (req.payload.config.debug) {\n            req.payload.logger.info({\n              document,\n              matchField: matchField || 'id',\n              matchValue: document[matchField || 'id'],\n              msg: 'No existing document found, creating new in upsert mode',\n            })\n          }\n\n          const createData = { ...document }\n          delete createData.id\n\n          // Only handle _status for versioned collections\n          let draftOption: boolean | undefined\n          if (collectionHasVersions) {\n            // Use defaultVersionStatus from config if _status not provided\n            const statusValue = createData._status || options.defaultVersionStatus\n            const isPublished = statusValue !== 'draft'\n            draftOption = !isPublished\n            delete createData._status // Remove _status from data - it's controlled via draft option\n          }\n\n          // Check if we have multi-locale data and extract it\n          const { flatData, hasMultiLocale, localeUpdates } = extractMultiLocaleData(\n            createData,\n            configuredLocales,\n          )\n\n          if (hasMultiLocale) {\n            // Create with default locale data\n            processedDoc = await req.payload.create({\n              collection: collectionSlug,\n              data: flatData,\n              draft: draftOption,\n              overrideAccess: false,\n              req,\n              user,\n            })\n\n            // Update for other locales\n            if (processedDoc && Object.keys(localeUpdates).length > 0) {\n              for (const [locale, localeData] of Object.entries(localeUpdates)) {\n                try {\n                  // Clone the request with the specific locale\n                  const localeReq = { ...req, locale }\n                  await req.payload.update({\n                    id: processedDoc.id as number | string,\n                    collection: collectionSlug,\n                    data: localeData,\n                    draft: collectionHasVersions ? false : undefined,\n                    overrideAccess: false,\n                    req: localeReq,\n                  })\n                } catch (error) {\n                  // Log but don't fail the entire import if a locale update fails\n                  req.payload.logger.error({\n                    err: error,\n                    msg: `Failed to update locale ${locale} for document ${String(processedDoc.id)}`,\n                  })\n                }\n              }\n            }\n          } else {\n            // No multi-locale data, create normally\n            processedDoc = await req.payload.create({\n              collection: collectionSlug,\n              data: createData,\n              draft: draftOption,\n              overrideAccess: false,\n              req,\n              user,\n            })\n          }\n        } else {\n          // Update mode but document not found\n          let matchValueDisplay: string\n          if (typeof matchValue === 'object' && matchValue !== null) {\n            matchValueDisplay = JSON.stringify(matchValue)\n          } else if (typeof matchValue === 'string') {\n            matchValueDisplay = matchValue\n          } else if (typeof matchValue === 'number') {\n            matchValueDisplay = matchValue.toString()\n          } else {\n            // For other types, use JSON.stringify to avoid [object Object]\n            matchValueDisplay = JSON.stringify(matchValue)\n          }\n          throw new Error(`Document with ${matchField || 'id'}=\"${matchValueDisplay}\" not found`)\n        }\n      } else {\n        throw new Error(`Unknown import mode: ${String(importMode)}`)\n      }\n\n      if (processedDoc) {\n        // Determine operation type for proper counting\n        let operation: 'created' | 'updated' | undefined\n        if (importMode === 'create') {\n          operation = 'created'\n        } else if (importMode === 'update') {\n          operation = 'updated'\n        } else if (importMode === 'upsert') {\n          // In upsert mode, check if we found an existing document\n          if (existing && existing.docs.length > 0) {\n            operation = 'updated'\n          } else {\n            operation = 'created'\n          }\n        }\n\n        result.successful.push({\n          document,\n          index: rowNumber - 1, // Store as 0-indexed\n          operation,\n          result: processedDoc,\n        })\n      }\n    } catch (error) {\n      const importError: ImportError = {\n        type: categorizeError(error),\n        documentData: document || {},\n        error: extractErrorMessage(error),\n        item: document || {},\n        itemIndex: rowNumber - 1,\n        rowNumber,\n      }\n\n      // Try to extract field information from validation errors\n      if (error && typeof error === 'object' && 'data' in error) {\n        const errorData = error as { data?: { errors?: Array<{ path?: string }> } }\n        if (errorData.data?.errors && Array.isArray(errorData.data.errors)) {\n          const firstError = errorData.data.errors[0]\n          if (firstError?.path) {\n            importError.field = firstError.path\n          }\n        }\n      }\n\n      result.failed.push(importError)\n      // Always continue processing all rows\n    }\n  }\n\n  return result\n}\n\nexport function createImportBatchProcessor(options: ImportBatchProcessorOptions = {}) {\n  const processorOptions = {\n    batchSize: options.batchSize ?? 100,\n    defaultVersionStatus: options.defaultVersionStatus ?? 'published',\n  }\n\n  const processImport = async (processOptions: ImportProcessOptions): Promise<ImportResult> => {\n    const { collectionSlug, documents, importMode, matchField, req, user } = processOptions\n    const batches = createBatches(documents, processorOptions.batchSize)\n\n    const result: ImportResult = {\n      errors: [],\n      imported: 0,\n      total: documents.length,\n      updated: 0,\n    }\n\n    for (let i = 0; i < batches.length; i++) {\n      const currentBatch = batches[i]\n      if (!currentBatch) {\n        continue\n      }\n\n      const batchResult = await processImportBatch({\n        batch: currentBatch,\n        batchIndex: i,\n        collectionSlug,\n        importMode,\n        matchField,\n        options: processorOptions,\n        req,\n        user,\n      })\n\n      // Update results\n      for (const success of batchResult.successful) {\n        if (success.operation === 'created') {\n          result.imported++\n        } else if (success.operation === 'updated') {\n          result.updated++\n        } else {\n          // Fallback\n          if (importMode === 'create') {\n            result.imported++\n          } else {\n            result.updated++\n          }\n        }\n      }\n\n      for (const error of batchResult.failed) {\n        result.errors.push({\n          doc: error.documentData,\n          error: error.error,\n          index: error.rowNumber - 1, // Convert back to 0-indexed\n        })\n      }\n    }\n\n    return result\n  }\n\n  return {\n    processImport,\n  }\n}\n"],"names":["categorizeError","createBatches","extractErrorMessage","extractMultiLocaleData","data","configuredLocales","flatData","localeUpdates","hasMultiLocale","length","localeSet","Set","key","value","Object","entries","Array","isArray","valueObj","localeKeys","keys","filter","k","has","firstLocale","locale","processImportBatch","batch","batchIndex","collectionSlug","importMode","matchField","options","req","user","result","failed","successful","collectionConfig","payload","collections","config","collectionHasVersions","Boolean","versions","localization","localeCodes","undefined","startingRowNumber","batchSize","i","document","rowNumber","processedDoc","existing","createData","id","draftOption","statusValue","_status","defaultVersionStatus","isPublished","debug","logger","info","msg","willSetDraft","title","titleIsNull","titleType","create","collection","draft","overrideAccess","localeData","localeReq","update","error","err","String","matchValue","Error","isMatchingById","matchValueStr","JSON","stringify","toString","isValidObjectIdFormat","test","find","depth","limit","where","equals","docs","existingDoc","existingId","existingStatus","existingTitle","incomingDocument","mode","updateData","_id","createdAt","updatedAt","reduce","acc","val","substring","newData","status","updateError","matchValueDisplay","operation","push","index","importError","type","documentData","item","itemIndex","errorData","errors","firstError","path","field","createImportBatchProcessor","processorOptions","processImport","processOptions","documents","batches","imported","total","updated","currentBatch","batchResult","success","doc"],"mappings":"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"}