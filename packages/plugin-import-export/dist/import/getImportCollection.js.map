{"version":3,"sources":["../../src/import/getImportCollection.ts"],"sourcesContent":["import type {\n  CollectionAfterChangeHook,\n  CollectionBeforeOperationHook,\n  CollectionConfig,\n  Config,\n} from 'payload'\n\nimport fs from 'fs'\nimport path from 'path'\n\nimport type { ImportConfig, ImportExportPluginConfig } from '../types.js'\nimport type { ImportTaskInput } from './getCreateImportCollectionTask.js'\n\nimport { createImport } from './createImport.js'\nimport { getFields } from './getFields.js'\nimport { handlePreview } from './handlePreview.js'\n\nexport const getImportCollection = ({\n  config,\n  importConfig,\n  pluginConfig,\n}: {\n  config: Config\n  importConfig?: ImportConfig\n  pluginConfig: ImportExportPluginConfig\n}): CollectionConfig => {\n  const beforeOperation: CollectionBeforeOperationHook[] = []\n  const afterChange: CollectionAfterChangeHook[] = []\n\n  // Extract import-specific settings\n  const disableJobsQueue = importConfig?.disableJobsQueue ?? false\n  const batchSize = importConfig?.batchSize ?? 100\n  const defaultVersionStatus = importConfig?.defaultVersionStatus ?? 'published'\n\n  // Get collection slugs for the dropdown\n  const collectionSlugs = pluginConfig.collections?.map((c) => c.slug)\n\n  const collection: CollectionConfig = {\n    slug: 'imports',\n    access: {\n      update: () => false,\n    },\n    admin: {\n      components: {\n        edit: {\n          SaveButton: '@payloadcms/plugin-import-export/rsc#ImportSaveButton',\n        },\n      },\n      disableCopyToLocale: true,\n      group: false,\n      useAsTitle: 'filename',\n    },\n    disableDuplicate: true,\n    endpoints: [\n      {\n        handler: handlePreview,\n        method: 'post',\n        path: '/preview-data',\n      },\n    ],\n    fields: getFields(config, { collectionSlugs }),\n    hooks: {\n      afterChange,\n      beforeOperation,\n    },\n    lockDocuments: false,\n    upload: {\n      filesRequiredOnCreate: true,\n      hideFileInputOnCreate: false,\n      hideRemoveFile: true,\n      mimeTypes: ['text/csv', 'application/json'],\n    },\n  }\n\n  if (disableJobsQueue) {\n    // Process the import synchronously after the document (with file) has been created\n    afterChange.push(async ({ collection: collectionConfig, doc, operation, req }) => {\n      if (operation !== 'create' || doc.status !== 'pending') {\n        return doc\n      }\n\n      const debug = pluginConfig.debug || false\n\n      try {\n        // Get file data from the uploaded document\n        let fileData: Buffer\n        let fileMimetype: string\n\n        if (doc.url && doc.url.startsWith('http')) {\n          // File has been uploaded to external storage (S3, etc.) - fetch it\n          const response = await fetch(doc.url)\n          if (!response.ok) {\n            throw new Error(`Failed to fetch file from URL: ${doc.url}`)\n          }\n          fileData = Buffer.from(await response.arrayBuffer())\n          fileMimetype = doc.mimeType || 'text/csv'\n        } else {\n          // File is stored locally - read from filesystem\n          const filePath = doc.filename\n          // Get upload config from the actual sanitized collection config\n          const uploadConfig =\n            typeof collectionConfig?.upload === 'object' ? collectionConfig.upload : undefined\n          const uploadDir = uploadConfig?.staticDir || './uploads'\n          const fullPath = path.resolve(uploadDir, filePath)\n          fileData = await fs.promises.readFile(fullPath)\n          fileMimetype = doc.mimeType || 'text/csv'\n        }\n\n        const result = await createImport({\n          id: doc.id,\n          name: doc.filename || 'import',\n          batchSize,\n          collectionSlug: doc.collectionSlug,\n          debug,\n          defaultVersionStatus,\n          file: {\n            name: doc.filename,\n            data: fileData,\n            mimetype: fileMimetype,\n          },\n          format: fileMimetype === 'text/csv' ? 'csv' : 'json',\n          importMode: doc.importMode || 'create',\n          matchField: doc.matchField,\n          req,\n          userCollection: req?.user?.collection || req?.user?.user?.collection,\n          userID: req?.user?.id || req?.user?.user?.id,\n        })\n\n        // Determine status\n        let status: 'completed' | 'failed' | 'partial'\n        if (result.errors.length === 0) {\n          status = 'completed'\n        } else if (result.imported + result.updated === 0) {\n          status = 'failed'\n        } else {\n          status = 'partial'\n        }\n\n        const summary = {\n          imported: result.imported,\n          issueDetails:\n            result.errors.length > 0\n              ? result.errors.map((e) => ({\n                  data: e.doc,\n                  error: e.error,\n                  row: e.index + 1,\n                }))\n              : undefined,\n          issues: result.errors.length,\n          total: result.total,\n          updated: result.updated,\n        }\n\n        // Try to update the document with results (may fail due to transaction timing)\n        try {\n          await req.payload.update({\n            id: doc.id,\n            collection: collectionConfig.slug,\n            data: {\n              status,\n              summary,\n            },\n            overrideAccess: true,\n            req,\n          })\n        } catch (updateErr) {\n          // Update may fail if document not yet committed, log but continue\n          if (debug) {\n            req.payload.logger.error({\n              err: updateErr,\n              msg: `Failed to update import document ${doc.id} with results`,\n            })\n          }\n        }\n\n        // Return updated doc for immediate response\n        return {\n          ...doc,\n          status,\n          summary,\n        }\n      } catch (err) {\n        const summary = {\n          imported: 0,\n          issueDetails: [\n            {\n              data: {},\n              error: err instanceof Error ? err.message : String(err),\n              row: 0,\n            },\n          ],\n          issues: 1,\n          total: 0,\n          updated: 0,\n        }\n\n        // Try to update document with error status\n        try {\n          await req.payload.update({\n            id: doc.id,\n            collection: collectionConfig.slug,\n            data: {\n              status: 'failed',\n              summary,\n            },\n            overrideAccess: true,\n            req,\n          })\n        } catch (updateErr) {\n          // Update may fail if document not yet committed, log but continue\n          if (debug) {\n            req.payload.logger.error({\n              err: updateErr,\n              msg: `Failed to update import document ${doc.id} with error status`,\n            })\n          }\n        }\n\n        if (debug) {\n          req.payload.logger.error({\n            err,\n            msg: 'Import processing failed',\n          })\n        }\n\n        // Return error status for immediate response\n        return {\n          ...doc,\n          status: 'failed',\n          summary,\n        }\n      }\n    })\n  } else {\n    // When jobs queue is enabled, queue the import as a job\n    afterChange.push(async ({ collection: collectionConfig, doc, operation, req }) => {\n      if (operation !== 'create') {\n        return\n      }\n\n      try {\n        // Get file data for job - need to read from disk/URL since req.file is not available in afterChange\n        let fileData: Buffer\n        if (doc.url && doc.url.startsWith('http')) {\n          const response = await fetch(doc.url)\n          if (!response.ok) {\n            throw new Error(`Failed to fetch file from URL: ${doc.url}`)\n          }\n          fileData = Buffer.from(await response.arrayBuffer())\n        } else {\n          const filePath = doc.filename\n          // Get upload config from the actual sanitized collection config\n          const uploadConfig =\n            typeof collectionConfig?.upload === 'object' ? collectionConfig.upload : undefined\n          const uploadDir = uploadConfig?.staticDir || './uploads'\n          const fullPath = path.resolve(uploadDir, filePath)\n          fileData = await fs.promises.readFile(fullPath)\n        }\n\n        const input: ImportTaskInput = {\n          name: doc.filename,\n          batchSize,\n          collectionSlug: doc.collectionSlug,\n          debug: pluginConfig.debug,\n          defaultVersionStatus,\n          file: {\n            name: doc.filename,\n            // Convert to base64 for job serialization - will be converted back to Buffer in task handler\n            data: fileData.toString('base64') as unknown as Buffer,\n            mimetype: doc.mimeType || 'text/csv',\n          },\n          format: doc.mimeType === 'text/csv' ? 'csv' : 'json',\n          importId: doc.id,\n          importMode: doc.importMode || 'create',\n          importsCollection: collectionConfig.slug,\n          matchField: doc.matchField,\n          userCollection: req.user?.collection || req?.user?.user?.collection,\n          userID: req?.user?.id || req?.user?.user?.id,\n        }\n\n        await req.payload.jobs.queue({\n          input,\n          task: 'createCollectionImport',\n        })\n      } catch (err) {\n        req.payload.logger.error({\n          err,\n          msg: `Failed to queue import job for document ${doc.id}`,\n        })\n      }\n    })\n  }\n\n  return collection\n}\n"],"names":["fs","path","createImport","getFields","handlePreview","getImportCollection","config","importConfig","pluginConfig","beforeOperation","afterChange","disableJobsQueue","batchSize","defaultVersionStatus","collectionSlugs","collections","map","c","slug","collection","access","update","admin","components","edit","SaveButton","disableCopyToLocale","group","useAsTitle","disableDuplicate","endpoints","handler","method","fields","hooks","lockDocuments","upload","filesRequiredOnCreate","hideFileInputOnCreate","hideRemoveFile","mimeTypes","push","collectionConfig","doc","operation","req","status","debug","fileData","fileMimetype","url","startsWith","response","fetch","ok","Error","Buffer","from","arrayBuffer","mimeType","filePath","filename","uploadConfig","undefined","uploadDir","staticDir","fullPath","resolve","promises","readFile","result","id","name","collectionSlug","file","data","mimetype","format","importMode","matchField","userCollection","user","userID","errors","length","imported","updated","summary","issueDetails","e","error","row","index","issues","total","payload","overrideAccess","updateErr","logger","err","msg","message","String","input","toString","importId","importsCollection","jobs","queue","task"],"mappings":"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"}