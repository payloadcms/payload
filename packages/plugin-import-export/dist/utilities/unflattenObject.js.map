{"version":3,"sources":["../../src/utilities/unflattenObject.ts"],"sourcesContent":["import type { FlattenedField, PayloadRequest } from 'payload'\n\nimport type { FromCSVFunction } from '../types.js'\n\nimport { processRichTextField } from './processRichTextField.js'\n\ntype UnflattenArgs = {\n  data: Record<string, unknown>\n  fields: FlattenedField[]\n  fromCSVFunctions?: Record<string, FromCSVFunction>\n  req: PayloadRequest\n}\n\nexport const unflattenObject = ({\n  data,\n  fields,\n  fromCSVFunctions = {},\n  req,\n}: UnflattenArgs): Record<string, unknown> => {\n  if (!data || typeof data !== 'object') {\n    return {}\n  }\n\n  const result: Record<string, unknown> = {}\n\n  // Sort keys to ensure array indices are processed in order\n  const sortedKeys = Object.keys(data).sort((a, b) => {\n    // Extract array indices from flattened keys (e.g., \"field_0_subfield\" -> \"0\")\n    const aMatch = a.match(/_(\\d+)(?:_|$)/)\n    const bMatch = b.match(/_(\\d+)(?:_|$)/)\n\n    if (aMatch && bMatch && aMatch.index !== undefined && bMatch.index !== undefined) {\n      const aBase = a.substring(0, aMatch.index)\n      const bBase = b.substring(0, bMatch.index)\n\n      if (aBase === bBase) {\n        return (parseInt(aMatch?.[1] ?? '0', 10) || 0) - (parseInt(bMatch?.[1] ?? '0', 10) || 0)\n      }\n    }\n\n    return a.localeCompare(b)\n  })\n\n  for (const flatKey of sortedKeys) {\n    let value = data[flatKey]\n\n    // Skip undefined values but keep null for required field validation\n    if (value === undefined) {\n      continue\n    }\n\n    // Check if this is a _relationTo key for a polymorphic relationship\n    if (flatKey.endsWith('_relationTo')) {\n      const baseKey = flatKey.replace(/_relationTo$/, '')\n      const idKey = `${baseKey}_id`\n\n      // Check if this is a polymorphic relationship field\n      const isPolymorphic = fields.some(\n        (field) =>\n          field.name === baseKey &&\n          field.type === 'relationship' &&\n          'relationTo' in field &&\n          Array.isArray(field.relationTo),\n      )\n\n      if (isPolymorphic) {\n        // Check if we've already processed this field\n        if (baseKey in result) {\n          // Skipping because already processed\n          continue\n        }\n\n        // If the corresponding _id key is undefined, skip processing entirely\n        // This prevents creating empty objects when we should preserve existing data\n        if (!(idKey in data) || data[idKey] === undefined) {\n          continue\n        }\n      }\n    }\n\n    // Check if this is a _id key for a polymorphic relationship where _relationTo is undefined\n    if (flatKey.endsWith('_id')) {\n      const baseKey = flatKey.replace(/_id$/, '')\n      const relationToKey = `${baseKey}_relationTo`\n\n      // Check if this is a polymorphic relationship field\n      const isPolymorphic = fields.some(\n        (field) =>\n          field.name === baseKey &&\n          field.type === 'relationship' &&\n          'relationTo' in field &&\n          Array.isArray(field.relationTo),\n      )\n\n      if (isPolymorphic) {\n        // If the corresponding _relationTo key is undefined, skip processing entirely\n        // This prevents creating empty objects when we should preserve existing data\n        if (!(relationToKey in data) || data[relationToKey] === undefined) {\n          continue\n        }\n      }\n    }\n\n    // Apply fromCSV function if available\n    if (fromCSVFunctions[flatKey]) {\n      value = fromCSVFunctions[flatKey]({\n        columnName: flatKey,\n        data,\n        value,\n      })\n    }\n\n    // Parse the flat key into segments\n    // Example: \"blocks_0_content_text\" -> [\"blocks\", \"0\", \"content\", \"text\"]\n    const segments = flatKey.split('_')\n    let current: Record<string, unknown> = result\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i]\n      if (!segment) {\n        continue\n      } // Skip empty segments\n\n      const nextSegment = segments[i + 1]\n      const isLast = i === segments.length - 1\n\n      // Check if next segment is a numeric array index (e.g., \"0\", \"1\", \"2\")\n      const isArrayIndex = nextSegment !== undefined && /^\\d+$/.test(nextSegment)\n\n      if (isLast) {\n        // Special handling for blockType suffix in blocks\n        if (segment === 'blockType' && i >= 3) {\n          // Pattern: blocks_0_hero_blockType -> set blockType on the block\n          const blockFieldName = segments[0] // 'blocks'\n          const isBlockField = fields.some(\n            (field) => field.name === blockFieldName && field.type === 'blocks',\n          )\n\n          if (isBlockField && segments[1]?.match(/^\\d+$/)) {\n            // This is a block type field\n            const parent = getParentObject(result, segments.slice(0, 2))\n            if (parent && typeof parent === 'object') {\n              parent.blockType = value\n            }\n            continue\n          }\n        }\n\n        // Special handling for relationship fields with _id suffix\n        if (segment === 'id' && i > 0) {\n          const parentKey = segments[i - 1]\n          // Check if the previous segment is an array index\n          const prevIsIndex = parentKey ? /^\\d+$/.test(parentKey) : false\n\n          if (!prevIsIndex) {\n            // Check if this is a relationship field\n            const isRelationship = fields.some(\n              (field) => field.name === parentKey && field.type === 'relationship',\n            )\n\n            if (isRelationship) {\n              // Check if this is a polymorphic relationship field\n              const field = fields.find((f) => f.name === parentKey && f.type === 'relationship')\n              const isPolymorphic =\n                field && 'relationTo' in field && Array.isArray(field.relationTo)\n\n              if (isPolymorphic) {\n                // For polymorphic relationships, check for the corresponding _relationTo field\n                const relationToKey = segments.slice(0, i).concat('relationTo').join('_')\n                const relationToValue = data[relationToKey]\n\n                // This is a polymorphic relationship\n                const parent = getParentObject(result, segments.slice(0, i - 1))\n                if (parent && parentKey && typeof parent === 'object') {\n                  // Both fields must be defined to create/update the relationship\n                  // If either is undefined, skip the field entirely (preserve existing data)\n                  if (value !== undefined && relationToValue !== undefined) {\n                    // Check if both are explicitly null\n                    if (relationToValue === null && value === null) {\n                      // Only set to null if explicitly null (user typed \"null\" in CSV)\n                      parent[parentKey] = null\n                    } else if (relationToValue || value) {\n                      // At least one has a value, create the relationship\n                      parent[parentKey] = {\n                        relationTo: relationToValue,\n                        value, // This will be transformed to proper format in postProcess\n                      }\n                    }\n                    // If both are empty strings, don't set the field (handled by not meeting the above conditions)\n                  }\n                  // If either is undefined, don't set the field at all (preserve existing data)\n                }\n                continue\n              } else if (!isPolymorphic) {\n                // Non-polymorphic relationship\n                const parent = getParentObject(result, segments.slice(0, i - 1))\n                if (parent && parentKey && typeof parent === 'object') {\n                  parent[parentKey] = value\n                }\n                continue\n              }\n            }\n          }\n        }\n\n        // Special handling for _relationTo suffix (skip it, handled above)\n        if (segment === 'relationTo' && i > 0) {\n          const parentKey = segments[i - 1]\n          if (parentKey && !parentKey.match(/^\\d+$/)) {\n            const field = fields.find((f) => f.name === parentKey && f.type === 'relationship')\n            const isPolymorphic = field && 'relationTo' in field && Array.isArray(field.relationTo)\n\n            if (isPolymorphic) {\n              // For polymorphic relationships, this is handled when processing the _id field\n              // Skip it entirely\n              continue\n            }\n          }\n        }\n\n        current[segment] = value\n      } else if (isArrayIndex && nextSegment !== undefined) {\n        // Initialize array if needed\n        if (!current[segment] || !Array.isArray(current[segment])) {\n          current[segment] = []\n        }\n\n        const arrayIndex = parseInt(nextSegment)\n        const arr = current[segment] as unknown[]\n\n        // Ensure array has sufficient length\n        while (arr.length <= arrayIndex) {\n          arr.push(null)\n        }\n\n        // Handle array of objects\n        if (arr[arrayIndex] === null || arr[arrayIndex] === undefined) {\n          arr[arrayIndex] = {}\n        }\n\n        // Check if this is a blocks field with block slug pattern\n        const isBlocksField = fields.some((f) => f.name === segment && f.type === 'blocks')\n        if (isBlocksField && i + 3 < segments.length) {\n          // Pattern: blocks_0_hero_title where 'hero' is the block slug\n          const blockSlug = segments[i + 2]\n          const blockFieldName = segments[i + 3]\n\n          if (blockSlug && blockFieldName) {\n            const blockObject = arr[arrayIndex] as Record<string, unknown>\n\n            // Set the blockType based on the slug\n            blockObject.blockType = blockSlug\n\n            // Handle nested block fields\n            if (i + 3 === segments.length - 1) {\n              // Direct field on the block\n              blockObject[blockFieldName] = value\n            } else {\n              // Nested field in the block\n              if (!blockObject[blockFieldName] || typeof blockObject[blockFieldName] !== 'object') {\n                blockObject[blockFieldName] = {}\n              }\n              // Continue processing remaining segments\n              current = blockObject[blockFieldName] as Record<string, unknown>\n              i = i + 3 // Skip index, slug, and field name\n              continue // Continue processing the remaining segments (not break!)\n            }\n            break\n          }\n        }\n\n        // If this is the last segment after the index, set the value\n        if (i + 2 === segments.length - 1) {\n          const lastSegment = segments[segments.length - 1]\n          if (lastSegment && arr[arrayIndex] && typeof arr[arrayIndex] === 'object') {\n            ;(arr[arrayIndex] as Record<string, unknown>)[lastSegment] = value\n          }\n          break\n        } else if (i + 1 === segments.length - 1) {\n          // Direct array value (e.g., tags_0 = \"value\")\n          arr[arrayIndex] = value\n          break\n        } else {\n          // Continue traversing into the array element\n          current = arr[arrayIndex] as Record<string, unknown>\n          i++ // skip the index segment\n        }\n      } else {\n        // Regular object property\n        // Check if this segment is already set to null (polymorphic relationship already processed)\n        if (current[segment] === null && isLast && segment === 'relationTo') {\n          // This is a relationTo for a polymorphic field that was already set to null\n          // Skip creating a new object\n          continue\n        }\n\n        if (\n          !current[segment] ||\n          typeof current[segment] !== 'object' ||\n          Array.isArray(current[segment])\n        ) {\n          current[segment] = {}\n        }\n\n        // Handle special cases for polymorphic relationships\n        if (segment === 'relationTo' && i > 0 && segments[i - 1]?.match(/^\\d+$/)) {\n          // This is part of a polymorphic relationship array\n          current[segment] = value\n        } else if (\n          typeof current[segment] === 'object' &&\n          !Array.isArray(current[segment]) &&\n          current[segment] !== null\n        ) {\n          current = current[segment] as Record<string, unknown>\n        }\n      }\n    }\n  }\n\n  try {\n    // Post-process to handle special structures\n    postProcessDocument(result, fields)\n  } catch (err) {\n    // Log but don't throw - return partially processed result\n\n    req.payload.logger.error({\n      err,\n      msg: '[plugin-import-export] Error in postProcessDocument',\n    })\n  }\n\n  return result\n}\n\nconst getParentObject = (\n  obj: Record<string, unknown>,\n  segments: string[],\n): Record<string, unknown> | undefined => {\n  let current: Record<string, unknown> = obj\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i]\n    const nextSegment = segments[i + 1]\n\n    if (!segment) {\n      continue\n    }\n\n    if (nextSegment && /^\\d+$/.test(nextSegment)) {\n      const arrayIndex = parseInt(nextSegment)\n      const arr = current[segment] as unknown[]\n\n      if (Array.isArray(arr) && arr[arrayIndex]) {\n        current = arr[arrayIndex] as Record<string, unknown>\n        i++ // Skip the index\n      } else {\n        return undefined\n      }\n    } else {\n      const next = current[segment]\n      if (typeof next === 'object' && next !== null && !Array.isArray(next)) {\n        current = next as Record<string, unknown>\n      } else {\n        return undefined\n      }\n    }\n  }\n\n  return current\n}\n\nconst postProcessDocument = (doc: Record<string, unknown>, fields: FlattenedField[]): void => {\n  // Handle localized fields - transform from field_locale to { field: { locale: value } }\n  // This is the format Payload stores in the database\n  const localizedFields = fields.filter((field) => field.localized)\n  const processedLocalizedFields = new Set<string>()\n\n  for (const field of localizedFields) {\n    if (processedLocalizedFields.has(field.name)) {\n      continue\n    }\n\n    // Look for all locale-specific keys for this field\n    const localePattern = new RegExp(`^${field.name}_([a-z]{2}(?:_[A-Z]{2})?)$`)\n    const localeData: Record<string, unknown> = {}\n    const keysToDelete: string[] = []\n\n    for (const [key, value] of Object.entries(doc)) {\n      const match = key.match(localePattern)\n      if (match && match[1]) {\n        const locale = match[1]\n        localeData[locale] = value\n        keysToDelete.push(key)\n      }\n    }\n\n    // If we found locale-specific data, restructure it as Payload expects\n    if (Object.keys(localeData).length > 0) {\n      // Payload stores localized fields as nested objects: { field: { en: 'value', es: 'value' } }\n      doc[field.name] = localeData\n      keysToDelete.forEach((key) => delete doc[key])\n      processedLocalizedFields.add(field.name)\n    }\n  }\n\n  // Handle number fields with hasMany - convert string arrays to number arrays\n  const numberFields = fields.filter((field) => field.type === 'number' && field.hasMany)\n  for (const field of numberFields) {\n    const value = doc[field.name]\n\n    // Skip if field doesn't exist in document\n    if (!(field.name in doc)) {\n      continue\n    }\n\n    // Handle comma-separated string (e.g., \"1,2,3,4,5\")\n    if (typeof value === 'string' && value.includes(',')) {\n      doc[field.name] = value\n        .split(',')\n        .map((v) => v.trim())\n        .filter((v) => v !== '')\n        .map((v) => {\n          const num = parseFloat(v)\n          return isNaN(num) ? 0 : num\n        })\n    }\n    // Handle array of values from indexed columns (e.g., field_0, field_1, etc.)\n    else if (Array.isArray(value)) {\n      // Filter out null, undefined, and empty string values, then convert to numbers\n      doc[field.name] = value\n        .filter((v) => v !== null && v !== undefined && v !== '')\n        .map((v) => {\n          if (typeof v === 'string') {\n            const num = parseFloat(v)\n            return isNaN(num) ? 0 : num\n          }\n          return v\n        })\n    }\n    // Handle single value for hasMany (convert to array)\n    else if (value !== null && value !== undefined && value !== '') {\n      const num = typeof value === 'string' ? parseFloat(value) : value\n      doc[field.name] = isNaN(num as number) ? [] : [num]\n    }\n    // Handle empty/null values - convert to empty array for hasMany\n    else {\n      doc[field.name] = []\n    }\n  }\n\n  // Handle relationship fields with hasMany - convert comma-separated IDs to arrays\n  const relationshipFields = fields.filter(\n    (field) =>\n      (field.type === 'relationship' || field.type === 'upload') &&\n      field.hasMany === true &&\n      !Array.isArray(field.relationTo), // Skip polymorphic for now, handled separately\n  )\n  for (const field of relationshipFields) {\n    const value = doc[field.name]\n\n    // Handle comma-separated string of IDs (e.g., \"id1,id2,id3\")\n    if (typeof value === 'string' && value.includes(',')) {\n      doc[field.name] = value\n        .split(',')\n        .map((v) => v.trim())\n        .filter((v) => v !== '')\n    }\n    // Keep array as-is if already an array\n    else if (Array.isArray(value)) {\n      doc[field.name] = value.filter((v) => v !== null && v !== undefined && v !== '')\n    }\n    // Convert single value to array for hasMany\n    else if (value !== null && value !== undefined && value !== '') {\n      doc[field.name] = [value]\n    }\n  }\n\n  // Handle polymorphic relationships - transform from flat structure to proper format\n  for (const [key, value] of Object.entries(doc)) {\n    // Handle arrays of polymorphic relationships\n    if (Array.isArray(value)) {\n      // Check if this array contains polymorphic relationship objects\n      const hasPolymorphicItems = value.some(\n        (item) => typeof item === 'object' && item !== null && 'relationTo' in item,\n      )\n\n      if (hasPolymorphicItems) {\n        // Filter out null/invalid polymorphic items and transform valid ones\n        const processedArray = []\n        for (let i = 0; i < value.length; i++) {\n          const item = value[i]\n          if (typeof item === 'object' && item !== null && 'relationTo' in item) {\n            const typedItem = item as Record<string, unknown>\n\n            // Skip if both relationTo and value/id are null/empty\n            if (!typedItem.relationTo || (!typedItem.id && !typedItem.value)) {\n              continue\n            }\n\n            // Transform from {relationTo: 'collection', id: '123'} to {relationTo: 'collection', value: '123'}\n            if ('id' in typedItem) {\n              typedItem.value = typedItem.id\n              delete typedItem.id\n            }\n\n            processedArray.push(typedItem)\n          } else if (item !== null && item !== undefined) {\n            processedArray.push(item)\n          }\n        }\n\n        // Update the array with filtered results\n        if (value.length !== processedArray.length) {\n          doc[key] = processedArray.length > 0 ? processedArray : []\n        }\n      }\n      // For non-polymorphic arrays, preserve null placeholders for sparse arrays\n    }\n    // Handle single polymorphic relationships\n    else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n      // Check if this is a single polymorphic relationship\n      if ('relationTo' in value && ('id' in value || 'value' in value)) {\n        const typedValue = value as Record<string, unknown>\n\n        // If both relationTo and value are null/empty, set the whole field to null\n        if (!typedValue.relationTo || (!typedValue.id && !typedValue.value)) {\n          doc[key] = null\n        } else {\n          // If it has 'id', transform to 'value'\n          if ('id' in typedValue && !('value' in typedValue)) {\n            typedValue.value = typedValue.id\n            delete typedValue.id\n          }\n        }\n      } else {\n        // Recursively process nested objects\n        postProcessDocument(value as Record<string, unknown>, fields)\n      }\n    }\n  }\n\n  // Process rich text fields to ensure proper data types\n  const richTextFields = fields.filter((field) => field.type === 'richText')\n  for (const field of richTextFields) {\n    if (field.name in doc && doc[field.name]) {\n      doc[field.name] = processRichTextField(doc[field.name])\n    }\n  }\n\n  // Also process rich text fields in blocks\n  const blockFields = fields.filter((field) => field.type === 'blocks')\n  for (const field of blockFields) {\n    if (field.name in doc && Array.isArray(doc[field.name])) {\n      const blocks = doc[field.name] as any[]\n      for (const block of blocks) {\n        if (!block || typeof block !== 'object') {\n          continue\n        }\n\n        // Look for richText fields directly in the block\n        for (const [key, value] of Object.entries(block)) {\n          if (key === 'richText' || (typeof key === 'string' && key.includes('richText'))) {\n            block[key] = processRichTextField(value)\n          }\n        }\n      }\n    }\n  }\n}\n"],"names":["processRichTextField","unflattenObject","data","fields","fromCSVFunctions","req","result","sortedKeys","Object","keys","sort","a","b","aMatch","match","bMatch","index","undefined","aBase","substring","bBase","parseInt","localeCompare","flatKey","value","endsWith","baseKey","replace","idKey","isPolymorphic","some","field","name","type","Array","isArray","relationTo","relationToKey","columnName","segments","split","current","i","length","segment","nextSegment","isLast","isArrayIndex","test","blockFieldName","isBlockField","parent","getParentObject","slice","blockType","parentKey","prevIsIndex","isRelationship","find","f","concat","join","relationToValue","arrayIndex","arr","push","isBlocksField","blockSlug","blockObject","lastSegment","postProcessDocument","err","payload","logger","error","msg","obj","next","doc","localizedFields","filter","localized","processedLocalizedFields","Set","has","localePattern","RegExp","localeData","keysToDelete","key","entries","locale","forEach","add","numberFields","hasMany","includes","map","v","trim","num","parseFloat","isNaN","relationshipFields","hasPolymorphicItems","item","processedArray","typedItem","id","typedValue","richTextFields","blockFields","blocks","block"],"mappings":"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"}