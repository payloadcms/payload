{"version":3,"sources":["../../src/utilities/removeDisabledFields.ts"],"sourcesContent":["/**\n * Recursively removes fields from a deeply nested object based on dot-notation paths.\n *\n * This utility supports removing:\n * - Nested fields in plain objects (e.g., \"group.value\")\n * - Fields inside arrays of objects (e.g., \"group.array.field1\")\n *\n * It safely traverses both object and array structures and avoids mutating the original input.\n *\n * @param obj - The original object to clean.\n * @param disabled - An array of dot-separated paths indicating which fields to remove.\n * @returns A deep clone of the original object with specified fields removed.\n */\n\nexport const removeDisabledFields = (\n  obj: Record<string, unknown>,\n  disabled: string[] = [],\n): Record<string, unknown> => {\n  if (!disabled.length) {\n    return obj\n  }\n\n  const clone = structuredClone(obj)\n\n  // Process each disabled path independently\n  for (const path of disabled) {\n    const parts = path.split('.')\n\n    /**\n     * Recursively walks the object tree according to the dot path,\n     * and deletes the field once the full path is reached.\n     *\n     * @param target - The current object or array being traversed\n     * @param i - The index of the current path part\n     */\n    const removeRecursively = (target: any, i = 0): void => {\n      if (target == null) {\n        return\n      }\n\n      const key = parts[i]\n\n      // If at the final part of the path, perform the deletion\n      if (i === parts.length - 1) {\n        // If the current level is an array, delete the key from each item\n        if (Array.isArray(target)) {\n          for (const item of target) {\n            if (item && typeof item === 'object' && key !== undefined) {\n              delete item[key as keyof typeof item]\n            }\n          }\n        } else if (typeof target === 'object' && key !== undefined) {\n          delete target[key]\n        }\n        return\n      }\n\n      if (key === undefined) {\n        return\n      }\n\n      // Traverse to the next level in the path\n      const next = target[key]\n\n      if (Array.isArray(next)) {\n        // If the next value is an array, recurse into each item\n        for (const item of next) {\n          removeRecursively(item, i + 1)\n        }\n      } else {\n        // Otherwise, continue down the object path\n        removeRecursively(next, i + 1)\n      }\n    }\n\n    removeRecursively(clone)\n  }\n\n  return clone\n}\n"],"names":["removeDisabledFields","obj","disabled","length","clone","structuredClone","path","parts","split","removeRecursively","target","i","key","Array","isArray","item","undefined","next"],"mappings":"AAAA;;;;;;;;;;;;CAYC,GAED,OAAO,MAAMA,uBAAuB,CAClCC,KACAC,WAAqB,EAAE;IAEvB,IAAI,CAACA,SAASC,MAAM,EAAE;QACpB,OAAOF;IACT;IAEA,MAAMG,QAAQC,gBAAgBJ;IAE9B,2CAA2C;IAC3C,KAAK,MAAMK,QAAQJ,SAAU;QAC3B,MAAMK,QAAQD,KAAKE,KAAK,CAAC;QAEzB;;;;;;KAMC,GACD,MAAMC,oBAAoB,CAACC,QAAaC,IAAI,CAAC;YAC3C,IAAID,UAAU,MAAM;gBAClB;YACF;YAEA,MAAME,MAAML,KAAK,CAACI,EAAE;YAEpB,yDAAyD;YACzD,IAAIA,MAAMJ,MAAMJ,MAAM,GAAG,GAAG;gBAC1B,kEAAkE;gBAClE,IAAIU,MAAMC,OAAO,CAACJ,SAAS;oBACzB,KAAK,MAAMK,QAAQL,OAAQ;wBACzB,IAAIK,QAAQ,OAAOA,SAAS,YAAYH,QAAQI,WAAW;4BACzD,OAAOD,IAAI,CAACH,IAAyB;wBACvC;oBACF;gBACF,OAAO,IAAI,OAAOF,WAAW,YAAYE,QAAQI,WAAW;oBAC1D,OAAON,MAAM,CAACE,IAAI;gBACpB;gBACA;YACF;YAEA,IAAIA,QAAQI,WAAW;gBACrB;YACF;YAEA,yCAAyC;YACzC,MAAMC,OAAOP,MAAM,CAACE,IAAI;YAExB,IAAIC,MAAMC,OAAO,CAACG,OAAO;gBACvB,wDAAwD;gBACxD,KAAK,MAAMF,QAAQE,KAAM;oBACvBR,kBAAkBM,MAAMJ,IAAI;gBAC9B;YACF,OAAO;gBACL,2CAA2C;gBAC3CF,kBAAkBQ,MAAMN,IAAI;YAC9B;QACF;QAEAF,kBAAkBL;IACpB;IAEA,OAAOA;AACT,EAAC"}