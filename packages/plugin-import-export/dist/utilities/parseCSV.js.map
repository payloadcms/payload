{"version":3,"sources":["../../src/utilities/parseCSV.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport { parse } from 'csv-parse'\n\nexport type ParseCSVArgs = {\n  data: Buffer | string\n  req: PayloadRequest\n}\n\n/**\n * Parses CSV data into an array of record objects.\n * Handles type coercion for booleans, numbers, and null values.\n */\nexport const parseCSV = async ({ data, req }: ParseCSVArgs): Promise<Record<string, unknown>[]> => {\n  return new Promise((resolve, reject) => {\n    const records: Record<string, unknown>[] = []\n\n    const parser = parse({\n      cast: (value, _context) => {\n        // Empty strings should be undefined (field not present in update)\n        // This preserves existing data instead of overwriting with null\n        if (value === '') {\n          return undefined\n        }\n\n        // Handle booleans\n        if (value === 'true') {\n          return true\n        }\n        if (value === 'false') {\n          return false\n        }\n\n        // Handle explicit null - user must type \"null\" to set field to null\n        if (value === 'null' || value === 'NULL') {\n          return null\n        }\n\n        // Don't auto-convert to numbers if the value contains a comma\n        // This allows hasMany fields to use comma-separated values\n        if (value.includes(',')) {\n          return value // Keep as string for comma-separated values\n        }\n\n        // Handle numbers (only after checking for commas)\n        if (!isNaN(Number(value)) && value !== '') {\n          const num = Number(value)\n\n          if (String(num) === value || value.includes('.')) {\n            return num\n          }\n        }\n\n        // Return as string\n        return value\n      },\n      columns: true,\n      skip_empty_lines: true,\n      trim: true,\n    })\n\n    parser.on('readable', () => {\n      let record\n      while ((record = parser.read()) !== null) {\n        records.push(record)\n      }\n    })\n\n    parser.on('error', (err) => {\n      req.payload.logger.error({ err, msg: 'Error parsing CSV' })\n      reject(err)\n    })\n\n    parser.on('end', () => {\n      resolve(records)\n    })\n\n    parser.write(data)\n    parser.end()\n  })\n}\n"],"names":["parse","parseCSV","data","req","Promise","resolve","reject","records","parser","cast","value","_context","undefined","includes","isNaN","Number","num","String","columns","skip_empty_lines","trim","on","record","read","push","err","payload","logger","error","msg","write","end"],"mappings":"AAEA,SAASA,KAAK,QAAQ,YAAW;AAOjC;;;CAGC,GACD,OAAO,MAAMC,WAAW,OAAO,EAAEC,IAAI,EAAEC,GAAG,EAAgB;IACxD,OAAO,IAAIC,QAAQ,CAACC,SAASC;QAC3B,MAAMC,UAAqC,EAAE;QAE7C,MAAMC,SAASR,MAAM;YACnBS,MAAM,CAACC,OAAOC;gBACZ,kEAAkE;gBAClE,gEAAgE;gBAChE,IAAID,UAAU,IAAI;oBAChB,OAAOE;gBACT;gBAEA,kBAAkB;gBAClB,IAAIF,UAAU,QAAQ;oBACpB,OAAO;gBACT;gBACA,IAAIA,UAAU,SAAS;oBACrB,OAAO;gBACT;gBAEA,oEAAoE;gBACpE,IAAIA,UAAU,UAAUA,UAAU,QAAQ;oBACxC,OAAO;gBACT;gBAEA,8DAA8D;gBAC9D,2DAA2D;gBAC3D,IAAIA,MAAMG,QAAQ,CAAC,MAAM;oBACvB,OAAOH,MAAM,4CAA4C;;gBAC3D;gBAEA,kDAAkD;gBAClD,IAAI,CAACI,MAAMC,OAAOL,WAAWA,UAAU,IAAI;oBACzC,MAAMM,MAAMD,OAAOL;oBAEnB,IAAIO,OAAOD,SAASN,SAASA,MAAMG,QAAQ,CAAC,MAAM;wBAChD,OAAOG;oBACT;gBACF;gBAEA,mBAAmB;gBACnB,OAAON;YACT;YACAQ,SAAS;YACTC,kBAAkB;YAClBC,MAAM;QACR;QAEAZ,OAAOa,EAAE,CAAC,YAAY;YACpB,IAAIC;YACJ,MAAO,AAACA,CAAAA,SAASd,OAAOe,IAAI,EAAC,MAAO,KAAM;gBACxChB,QAAQiB,IAAI,CAACF;YACf;QACF;QAEAd,OAAOa,EAAE,CAAC,SAAS,CAACI;YAClBtB,IAAIuB,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;gBAAEH;gBAAKI,KAAK;YAAoB;YACzDvB,OAAOmB;QACT;QAEAjB,OAAOa,EAAE,CAAC,OAAO;YACfhB,QAAQE;QACV;QAEAC,OAAOsB,KAAK,CAAC5B;QACbM,OAAOuB,GAAG;IACZ;AACF,EAAC"}