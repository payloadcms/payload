{"version":3,"sources":["../../src/utilities/flattenObject.ts"],"sourcesContent":["import type { Document } from 'payload'\n\nimport type { ToCSVFunction } from '../types.js'\n\ntype Args = {\n  doc: Document\n  fields?: string[]\n  prefix?: string\n  toCSVFunctions: Record<string, ToCSVFunction>\n}\n\nexport const flattenObject = ({\n  doc,\n  fields,\n  prefix,\n  toCSVFunctions,\n}: Args): Record<string, unknown> => {\n  const row: Record<string, unknown> = {}\n\n  // Helper to get toCSV function by full path or base field name\n  // This allows functions registered for field names (e.g., 'richText') to work\n  // even when the field is nested in arrays/blocks (e.g., 'blocks_0_content_richText')\n  const getToCSVFunction = (fullPath: string, baseFieldName: string): ToCSVFunction | undefined => {\n    return toCSVFunctions?.[fullPath] ?? toCSVFunctions?.[baseFieldName]\n  }\n\n  const flatten = (siblingDoc: Document, prefix?: string) => {\n    Object.entries(siblingDoc).forEach(([key, value]) => {\n      const newKey = prefix ? `${prefix}_${key}` : key\n      const toCSVFn = getToCSVFunction(newKey, key)\n\n      if (Array.isArray(value)) {\n        // If a custom toCSV function exists for this array field, run it first.\n        // If it produces output, skip per-item handling; otherwise, fall back.\n        if (toCSVFn) {\n          try {\n            const result = toCSVFn({\n              columnName: newKey,\n              data: row,\n              doc,\n              row,\n              siblingDoc,\n              value, // whole array\n            })\n\n            if (typeof result !== 'undefined') {\n              // Custom function returned a single value for this array field.\n              row[newKey] = result\n              return\n            }\n\n            // If the custom function wrote any keys for this field, consider it handled.\n            for (const k in row) {\n              if (k === newKey || k.startsWith(`${newKey}_`)) {\n                return\n              }\n            }\n            // Otherwise, fall through to per-item handling.\n          } catch (error) {\n            throw new Error(\n              `Error in toCSVFunction for array \"${newKey}\": ${JSON.stringify(value)}\\n${\n                (error as Error).message\n              }`,\n            )\n          }\n        }\n\n        value.forEach((item, index) => {\n          if (typeof item === 'object' && item !== null) {\n            const blockType = typeof item.blockType === 'string' ? item.blockType : undefined\n            const itemPrefix = blockType ? `${newKey}_${index}_${blockType}` : `${newKey}_${index}`\n\n            // Case: hasMany polymorphic relationships\n            if (\n              'relationTo' in item &&\n              'value' in item &&\n              typeof item.value === 'object' &&\n              item.value !== null\n            ) {\n              row[`${itemPrefix}_relationTo`] = item.relationTo\n              row[`${itemPrefix}_id`] = item.value.id\n              return\n            }\n\n            // Fallback: deep-flatten nested objects\n            flatten(item, itemPrefix)\n          } else {\n            // Primitive array item.\n            row[`${newKey}_${index}`] = item\n          }\n        })\n      } else if (typeof value === 'object' && value !== null) {\n        // Object field: use custom toCSV if present, else recurse.\n        if (!toCSVFn) {\n          flatten(value, newKey)\n        } else {\n          try {\n            const result = toCSVFn({\n              columnName: newKey,\n              data: row,\n              doc,\n              row,\n              siblingDoc,\n              value,\n            })\n            if (typeof result !== 'undefined') {\n              row[newKey] = result\n            }\n          } catch (error) {\n            throw new Error(\n              `Error in toCSVFunction for nested object \"${newKey}\": ${JSON.stringify(value)}\\n${\n                (error as Error).message\n              }`,\n            )\n          }\n        }\n      } else {\n        if (toCSVFn) {\n          try {\n            const result = toCSVFn({\n              columnName: newKey,\n              data: row,\n              doc,\n              row,\n              siblingDoc,\n              value,\n            })\n            if (typeof result !== 'undefined') {\n              row[newKey] = result\n            }\n          } catch (error) {\n            throw new Error(\n              `Error in toCSVFunction for field \"${newKey}\": ${JSON.stringify(value)}\\n${\n                (error as Error).message\n              }`,\n            )\n          }\n        } else {\n          row[newKey] = value\n        }\n      }\n    })\n  }\n\n  flatten(doc, prefix)\n\n  if (Array.isArray(fields) && fields.length > 0) {\n    const orderedResult: Record<string, unknown> = {}\n\n    const fieldToRegex = (field: string): RegExp => {\n      const parts = field.split('.').map((part) => `${part}(?:_\\\\d+)?`)\n      const pattern = `^${parts.join('_')}`\n      return new RegExp(pattern)\n    }\n\n    fields.forEach((field) => {\n      if (row[field.replace(/\\./g, '_')]) {\n        const sanitizedField = field.replace(/\\./g, '_')\n        orderedResult[sanitizedField] = row[sanitizedField]\n      } else {\n        const regex = fieldToRegex(field)\n        Object.keys(row).forEach((key) => {\n          if (regex.test(key)) {\n            orderedResult[key] = row[key]\n          }\n        })\n      }\n    })\n\n    return orderedResult\n  }\n\n  return row\n}\n"],"names":["flattenObject","doc","fields","prefix","toCSVFunctions","row","getToCSVFunction","fullPath","baseFieldName","flatten","siblingDoc","Object","entries","forEach","key","value","newKey","toCSVFn","Array","isArray","result","columnName","data","k","startsWith","error","Error","JSON","stringify","message","item","index","blockType","undefined","itemPrefix","relationTo","id","length","orderedResult","fieldToRegex","field","parts","split","map","part","pattern","join","RegExp","replace","sanitizedField","regex","keys","test"],"mappings":"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"}