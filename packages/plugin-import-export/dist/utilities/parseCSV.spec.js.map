{"version":3,"sources":["../../src/utilities/parseCSV.spec.ts"],"sourcesContent":["import { PayloadRequest } from 'payload'\n\nimport { parseCSV } from './parseCSV.js'\nimport { describe, it, expect, vi } from 'vitest'\n\ndescribe('parseCSV', () => {\n  const mockReq = {\n    payload: {\n      logger: {\n        error: vi.fn(),\n      },\n    },\n  } as unknown as PayloadRequest\n\n  describe('cast function behavior', () => {\n    it('should preserve comma-separated values as strings', async () => {\n      const csvData = Buffer.from('numbers,ids\\n\"1,2,3,5,8\",\"id1,id2,id3\"')\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([\n        {\n          numbers: '1,2,3,5,8',\n          ids: 'id1,id2,id3',\n        },\n      ])\n    })\n\n    it('should convert single numbers to numbers', async () => {\n      const csvData = Buffer.from('single,decimal\\n\"42\",\"3.14\"')\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([\n        {\n          single: 42,\n          decimal: 3.14,\n        },\n      ])\n    })\n\n    it('should handle booleans correctly', async () => {\n      const csvData = Buffer.from('bool1,bool2,notBool\\n\"true\",\"false\",\"True\"')\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([\n        {\n          bool1: true,\n          bool2: false,\n          notBool: 'True', // Case-sensitive\n        },\n      ])\n    })\n\n    it('should convert empty strings to undefined', async () => {\n      const csvData = Buffer.from('field1,field2\\n\"\",\"value\"')\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([\n        {\n          // field1 is undefined (not present) - empty cells don't update fields\n          field2: 'value',\n        },\n      ])\n    })\n\n    it('should handle null strings', async () => {\n      const csvData = Buffer.from('field1,field2,field3\\n\"null\",\"NULL\",\"Null\"')\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([\n        {\n          field1: null,\n          field2: null,\n          field3: 'Null', // Case-sensitive for mixed case\n        },\n      ])\n    })\n\n    it('should preserve spaces in comma-separated values', async () => {\n      const csvData = Buffer.from('numbers\\n\" 10 , 20 , 30 \"')\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([\n        {\n          numbers: ' 10 , 20 , 30 ', // CSV parser trims outer quotes but preserves the content\n        },\n      ])\n    })\n\n    it('should handle mixed comma-separated values with empty entries', async () => {\n      const csvData = Buffer.from('mixed\\n\"1,,3,,5\"')\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([\n        {\n          mixed: '1,,3,,5',\n        },\n      ])\n    })\n\n    it('should handle MongoDB ObjectIds as strings', async () => {\n      const csvData = Buffer.from('id\\n\"507f1f77bcf86cd799439011\"')\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([\n        {\n          id: '507f1f77bcf86cd799439011',\n        },\n      ])\n    })\n\n    it('should handle multiple rows with various data types', async () => {\n      const csvData = Buffer.from(\n        'title,count,tags,active\\n' +\n          '\"Item 1\",\"5\",\"tag1,tag2,tag3\",\"true\"\\n' +\n          '\"Item 2\",\"\",\"\",\"false\"\\n' +\n          '\"Item 3\",\"10\",\"single\",\"\"\\n',\n      )\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([\n        {\n          title: 'Item 1',\n          count: 5,\n          tags: 'tag1,tag2,tag3',\n          active: true,\n        },\n        {\n          title: 'Item 2',\n          // count is undefined (empty cell - field not updated)\n          // tags is undefined (empty cell - field not updated)\n          active: false,\n        },\n        {\n          title: 'Item 3',\n          count: 10,\n          tags: 'single',\n          // active is undefined (empty cell - field not updated)\n        },\n      ])\n    })\n\n    it('should skip empty lines', async () => {\n      const csvData = Buffer.from('field\\n\"value1\"\\n\\n\"value2\"\\n\\n')\n      const result = await parseCSV({ data: csvData, req: mockReq })\n\n      expect(result).toEqual([{ field: 'value1' }, { field: 'value2' }])\n    })\n  })\n\n  describe('error handling', () => {\n    it('should handle parsing errors', async () => {\n      const invalidCsv = Buffer.from('field1,field2\\n\"value1')\n\n      await expect(parseCSV({ data: invalidCsv, req: mockReq })).rejects.toThrow()\n      expect(mockReq.payload.logger.error).toHaveBeenCalled()\n    })\n  })\n})\n"],"names":["parseCSV","describe","it","expect","vi","mockReq","payload","logger","error","fn","csvData","Buffer","from","result","data","req","toEqual","numbers","ids","single","decimal","bool1","bool2","notBool","field2","field1","field3","mixed","id","title","count","tags","active","field","invalidCsv","rejects","toThrow","toHaveBeenCalled"],"mappings":"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"}