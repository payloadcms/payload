{"version":3,"sources":["../../src/utilities/getSchemaColumns.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from 'payload'\n\nimport { getFlattenedFieldKeys } from './getFlattenedFieldKeys.js'\n\nexport type GetSchemaColumnsArgs = {\n  /**\n   * The collection configuration to derive columns from\n   */\n  collectionConfig: SanitizedCollectionConfig\n  /**\n   * Array of disabled field paths from plugin config\n   */\n  disabledFields?: string[]\n  /**\n   * User-selected fields to export. If provided, only these fields (and their nested fields) will be included.\n   */\n  fields?: string[]\n  /**\n   * The locale to export. When 'all', localized fields are expanded to include all locale suffixes.\n   */\n  locale?: null | string\n  /**\n   * Available locale codes from config. Required when locale='all'.\n   */\n  localeCodes?: string[]\n}\n\n/**\n * Derives CSV column names from the collection schema.\n * This provides a base set of columns from field definitions.\n *\n * Note: For arrays/blocks with multiple items, the schema only generates index 0.\n * Additional indices from actual data should be merged with these columns.\n *\n * Benefits:\n * - Provides consistent base columns\n * - Works for empty exports\n * - Ensures proper column ordering\n */\nexport const getSchemaColumns = ({\n  collectionConfig,\n  disabledFields = [],\n  fields: selectedFields,\n  locale,\n  localeCodes,\n}: GetSchemaColumnsArgs): string[] => {\n  const hasVersions = Boolean(collectionConfig.versions)\n\n  // Determine if we need locale expansion\n  const expandLocales = locale === 'all' && localeCodes && localeCodes.length > 0\n\n  // Get all possible columns from schema (excludes system fields like id, createdAt, updatedAt)\n  let schemaColumns = getFlattenedFieldKeys(\n    collectionConfig.flattenedFields,\n    '',\n    expandLocales ? { localeCodes } : {},\n  )\n\n  // Add system fields that aren't in flattenedFields\n  const systemFields = ['id', 'createdAt', 'updatedAt']\n  schemaColumns = [...systemFields, ...schemaColumns]\n\n  // Filter to user-selected fields if specified\n  if (selectedFields && selectedFields.length > 0) {\n    schemaColumns = filterToSelectedFields(schemaColumns, selectedFields)\n  }\n\n  // Remove disabled fields\n  if (disabledFields.length > 0) {\n    const disabledSet = new Set<string>()\n    for (const path of disabledFields) {\n      // Convert dot notation to underscore and add to set\n      disabledSet.add(path.replace(/\\./g, '_'))\n    }\n    schemaColumns = schemaColumns.filter((col) => {\n      // Check if column matches any disabled path\n      for (const disabled of disabledSet) {\n        if (col === disabled || col.startsWith(`${disabled}_`)) {\n          return false\n        }\n      }\n      return true\n    })\n  }\n\n  // When user has selected specific fields, preserve their ordering\n  // filterToSelectedFields() already returns columns in user's specified order\n  if (selectedFields && selectedFields.length > 0) {\n    return schemaColumns\n  }\n\n  // No fields selected - apply default ordering (id first, timestamps last)\n  const orderedColumns: string[] = []\n\n  // 1. ID always first\n  if (schemaColumns.includes('id')) {\n    orderedColumns.push('id')\n  }\n\n  // 2. Status field for versioned collections\n  if (hasVersions) {\n    orderedColumns.push('_status')\n  }\n\n  // 3. All other fields (excluding id, timestamps, status)\n  const excludeFromMiddle = new Set(['_status', 'createdAt', 'id', 'updatedAt'])\n  for (const col of schemaColumns) {\n    if (!excludeFromMiddle.has(col)) {\n      orderedColumns.push(col)\n    }\n  }\n\n  // 4. Timestamps at the end\n  if (schemaColumns.includes('createdAt')) {\n    orderedColumns.push('createdAt')\n  }\n  if (schemaColumns.includes('updatedAt')) {\n    orderedColumns.push('updatedAt')\n  }\n\n  return orderedColumns\n}\n\n/**\n * Merges schema-derived columns with data-discovered columns.\n * Schema columns provide the base ordering, data columns add any additional\n * columns (e.g., array indices beyond 0, dynamic fields).\n */\nexport const mergeColumns = (schemaColumns: string[], dataColumns: string[]): string[] => {\n  const result = [...schemaColumns]\n  const schemaSet = new Set(schemaColumns)\n\n  // Add any data columns not in schema (preserves schema ordering, appends new ones)\n  for (const col of dataColumns) {\n    if (!schemaSet.has(col)) {\n      // Find the best position to insert this column\n      // For array indices (e.g., field_1_*), insert after field_0_*\n      const match = col.match(/^(.+?)_(\\d+)(_.*)?$/)\n      if (match) {\n        const [, basePath, index, suffix] = match\n        if (basePath && index) {\n          const prevIndex = parseInt(index, 10) - 1\n          const prevCol = `${basePath}_${prevIndex}${suffix ?? ''}`\n          const prevIdx = result.indexOf(prevCol)\n          if (prevIdx !== -1) {\n            // Insert after the previous index column\n            result.splice(prevIdx + 1, 0, col)\n            schemaSet.add(col)\n            continue\n          }\n        }\n      }\n      // Otherwise append at the end (before timestamps)\n      const createdAtIdx = result.indexOf('createdAt')\n      if (createdAtIdx !== -1) {\n        result.splice(createdAtIdx, 0, col)\n      } else {\n        result.push(col)\n      }\n      schemaSet.add(col)\n    }\n  }\n\n  return result\n}\n\n/**\n * Filters schema columns to only include those matching user-selected fields.\n * Preserves the order specified by the user in selectedFields.\n * Handles nested field selection (e.g., 'group.value' includes 'group_value' and 'group_value_*')\n */\nfunction filterToSelectedFields(columns: string[], selectedFields: string[]): string[] {\n  const result: string[] = []\n  const columnsSet = new Set(columns)\n\n  // Convert selected fields to underscore notation patterns\n  const patterns = selectedFields.map((field) => {\n    const underscored = field.replace(/\\./g, '_')\n    return {\n      exact: underscored,\n      original: field,\n      prefix: `${underscored}_`,\n    }\n  })\n\n  // Iterate through user-specified fields in order to preserve their ordering\n  for (const pattern of patterns) {\n    // First add the exact match if it exists\n    if (columnsSet.has(pattern.exact)) {\n      result.push(pattern.exact)\n    }\n\n    // Then add any columns with the prefix (nested fields)\n    for (const column of columns) {\n      if (column !== pattern.exact && column.startsWith(pattern.prefix)) {\n        if (!result.includes(column)) {\n          result.push(column)\n        }\n      }\n    }\n  }\n\n  return result\n}\n"],"names":["getFlattenedFieldKeys","getSchemaColumns","collectionConfig","disabledFields","fields","selectedFields","locale","localeCodes","hasVersions","Boolean","versions","expandLocales","length","schemaColumns","flattenedFields","systemFields","filterToSelectedFields","disabledSet","Set","path","add","replace","filter","col","disabled","startsWith","orderedColumns","includes","push","excludeFromMiddle","has","mergeColumns","dataColumns","result","schemaSet","match","basePath","index","suffix","prevIndex","parseInt","prevCol","prevIdx","indexOf","splice","createdAtIdx","columns","columnsSet","patterns","map","field","underscored","exact","original","prefix","pattern","column"],"mappings":"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"}