{"version":3,"sources":["../../src/utilities/getSession.ts"],"sourcesContent":["import type { ClientSession } from 'mongoose'\nimport type { PayloadRequest } from 'payload'\n\nimport type { MongooseAdapter } from '../index.js'\n\n/**\n * returns the session belonging to the transaction of the req.session if exists\n * @returns ClientSession\n */\nexport async function getSession(\n  db: MongooseAdapter,\n  req?: Partial<PayloadRequest>,\n): Promise<ClientSession | undefined> {\n  if (!req) {\n    return\n  }\n\n  let transactionID = req.transactionID\n\n  if (transactionID instanceof Promise) {\n    transactionID = await req.transactionID\n  }\n\n  if (transactionID) {\n    const session = db.sessions[transactionID]\n\n    // Defensive check for race conditions where:\n    // 1. Session was retrieved from db.sessions\n    // 2. Another operation committed/rolled back and ended the session\n    // 3. This operation tries to use the now-ended session\n    // Note: This shouldn't normally happen as sessions are deleted from db.sessions\n    // after commit/rollback, but can occur due to async timing where we hold\n    // a reference to a session object that gets ended before we use it.\n    if (session && !session.inTransaction()) {\n      // Clean up the orphaned session reference\n      delete db.sessions[transactionID]\n      return undefined\n    }\n\n    return session\n  }\n}\n"],"names":["getSession","db","req","transactionID","Promise","session","sessions","inTransaction","undefined"],"mappings":"AAKA;;;CAGC,GACD,OAAO,eAAeA,WACpBC,EAAmB,EACnBC,GAA6B;IAE7B,IAAI,CAACA,KAAK;QACR;IACF;IAEA,IAAIC,gBAAgBD,IAAIC,aAAa;IAErC,IAAIA,yBAAyBC,SAAS;QACpCD,gBAAgB,MAAMD,IAAIC,aAAa;IACzC;IAEA,IAAIA,eAAe;QACjB,MAAME,UAAUJ,GAAGK,QAAQ,CAACH,cAAc;QAE1C,6CAA6C;QAC7C,4CAA4C;QAC5C,mEAAmE;QACnE,uDAAuD;QACvD,gFAAgF;QAChF,yEAAyE;QACzE,oEAAoE;QACpE,IAAIE,WAAW,CAACA,QAAQE,aAAa,IAAI;YACvC,0CAA0C;YAC1C,OAAON,GAAGK,QAAQ,CAACH,cAAc;YACjC,OAAOK;QACT;QAEA,OAAOH;IACT;AACF"}