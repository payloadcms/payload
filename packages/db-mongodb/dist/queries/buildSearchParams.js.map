{"version":3,"sources":["../../src/queries/buildSearchParams.ts"],"sourcesContent":["import type { FilterQuery } from 'mongoose'\nimport type { FlattenedField, Operator, PathToQuery, Payload } from 'payload'\n\nimport { Types } from 'mongoose'\nimport { APIError, getFieldByPath, getLocalizedPaths } from 'payload'\nimport { validOperatorSet } from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\nimport type { OperatorMapKey } from './operatorMap.js'\n\nimport { getCollection } from '../utilities/getEntity.js'\nimport { isObjectID } from '../utilities/isObjectID.js'\nimport { operatorMap } from './operatorMap.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\ntype SearchParam = {\n  path?: string\n  rawQuery?: unknown\n  value?: unknown\n}\n\nconst subQueryOptions = {\n  lean: true,\n}\n\n/**\n * Convert the Payload key / value / operator into a MongoDB query\n */\nexport async function buildSearchParam({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  operator,\n  parentIsLocalized,\n  payload,\n  val,\n}: {\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  operator: Operator\n  parentIsLocalized: boolean\n  payload: Payload\n  val: unknown\n}): Promise<SearchParam | undefined> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath = incomingPath.replace(/__/g, '.')\n  if (sanitizedPath === 'id') {\n    sanitizedPath = '_id'\n  }\n\n  let paths: PathToQuery[] = []\n\n  let hasCustomID = false\n\n  if (sanitizedPath === '_id') {\n    const customIDFieldType = collectionSlug\n      ? payload.collections[collectionSlug]?.customIDType\n      : undefined\n\n    let idFieldType: 'number' | 'text' = 'text'\n\n    if (customIDFieldType) {\n      idFieldType = customIDFieldType\n      hasCustomID = true\n    }\n\n    paths.push({\n      collectionSlug,\n      complete: true,\n      field: {\n        name: 'id',\n        type: idFieldType,\n      } as FlattenedField,\n      parentIsLocalized: parentIsLocalized ?? false,\n      path: '_id',\n    })\n  } else {\n    paths = getLocalizedPaths({\n      collectionSlug,\n      fields,\n      globalSlug,\n      incomingPath: sanitizedPath,\n      locale,\n      parentIsLocalized,\n      payload,\n    })\n  }\n\n  if (!paths[0]) {\n    return undefined\n  }\n\n  const [{ field, path }] = paths\n  if (path) {\n    const sanitizedQueryValue = sanitizeQueryValue({\n      field,\n      hasCustomID,\n      locale,\n      operator,\n      parentIsLocalized,\n      path,\n      payload,\n      val,\n    })\n\n    if (!sanitizedQueryValue) {\n      return undefined\n    }\n\n    const { operator: formattedOperator, rawQuery, val: formattedValue } = sanitizedQueryValue\n\n    if (rawQuery && paths.length === 1) {\n      return { value: rawQuery }\n    }\n\n    if (!formattedOperator) {\n      return undefined\n    }\n\n    // If there are multiple collections to search through,\n    // Recursively build up a list of query constraints\n    if (paths.length > 1) {\n      // Remove top collection and reverse array\n      // to work backwards from top\n      const pathsToQuery = paths.slice(1).reverse()\n\n      let relationshipQuery: SearchParam = {\n        value: {},\n      }\n\n      for (const [i, { collectionSlug, path: subPath }] of pathsToQuery.entries()) {\n        if (!collectionSlug) {\n          throw new APIError(`Collection with the slug ${collectionSlug} was not found.`)\n        }\n\n        const { collectionConfig, Model: SubModel } = getCollection({\n          adapter: payload.db as MongooseAdapter,\n          collectionSlug,\n        })\n\n        if (i === 0) {\n          const subQuery = await SubModel.buildQuery({\n            locale,\n            payload,\n            where: {\n              [subPath]: {\n                [formattedOperator]: val,\n              },\n            },\n          })\n\n          const field = paths[0].field\n\n          const select: Record<string, boolean> = {\n            _id: true,\n          }\n\n          let joinPath: null | string = null\n\n          if (field.type === 'join') {\n            const relationshipField = getFieldByPath({\n              fields: collectionConfig.flattenedFields,\n              path: field.on,\n            })\n            if (!relationshipField) {\n              throw new APIError('Relationship field was not found')\n            }\n\n            let path = relationshipField.localizedPath\n            if (relationshipField.pathHasLocalized && payload.config.localization) {\n              path = path.replace('<locale>', locale || payload.config.localization.defaultLocale)\n            }\n            select[path] = true\n\n            joinPath = path\n          }\n\n          if (joinPath) {\n            select[joinPath] = true\n          }\n\n          const result = await SubModel.find(subQuery).lean().select(select)\n\n          const $in: unknown[] = []\n\n          result.forEach((doc: any) => {\n            if (joinPath) {\n              let ref = doc\n\n              for (const segment of joinPath.split('.')) {\n                if (typeof ref === 'object' && ref) {\n                  ref = ref[segment]\n                }\n              }\n\n              if (Array.isArray(ref)) {\n                for (const item of ref) {\n                  if (isObjectID(item)) {\n                    $in.push(item)\n                  }\n                }\n              } else if (isObjectID(ref)) {\n                $in.push(ref)\n              }\n            } else {\n              const stringID = doc._id.toString()\n              $in.push(stringID)\n\n              if (Types.ObjectId.isValid(stringID)) {\n                $in.push(doc._id)\n              }\n            }\n          })\n\n          if (pathsToQuery.length === 1) {\n            return {\n              path: joinPath ? '_id' : path,\n              value: { $in },\n            }\n          }\n\n          const nextSubPath = pathsToQuery[i + 1]?.path\n\n          if (nextSubPath) {\n            relationshipQuery = { value: { [nextSubPath]: $in } }\n          }\n\n          continue\n        }\n\n        const subQuery = relationshipQuery.value as FilterQuery<any>\n        const result = await SubModel.find(subQuery, subQueryOptions)\n\n        const $in = result.map((doc) => doc._id)\n\n        // If it is the last recursion\n        // then pass through the search param\n        if (i + 1 === pathsToQuery.length) {\n          relationshipQuery = {\n            path,\n            value: { $in },\n          }\n        } else {\n          const nextSubPath = pathsToQuery[i + 1]?.path\n          if (nextSubPath) {\n            relationshipQuery = {\n              value: {\n                [nextSubPath]: { $in },\n              },\n            }\n          }\n        }\n      }\n\n      return relationshipQuery\n    }\n\n    if (formattedOperator && validOperatorSet.has(formattedOperator as Operator)) {\n      const operatorKey = operatorMap[formattedOperator as OperatorMapKey]\n\n      if (field.type === 'relationship' || field.type === 'upload') {\n        let hasNumberIDRelation\n        let multiIDCondition = '$or'\n        if (operatorKey === '$ne') {\n          multiIDCondition = '$and'\n        }\n\n        const result = {\n          value: {\n            [multiIDCondition]: [{ [path]: { [operatorKey]: formattedValue } }],\n          },\n        }\n\n        if (typeof formattedValue === 'string') {\n          if (Types.ObjectId.isValid(formattedValue)) {\n            result.value[multiIDCondition]?.push({\n              [path]: { [operatorKey]: new Types.ObjectId(formattedValue) },\n            })\n          } else {\n            ;(Array.isArray(field.relationTo) ? field.relationTo : [field.relationTo]).forEach(\n              (relationTo) => {\n                const isRelatedToCustomNumberID =\n                  payload.collections[relationTo]?.customIDType === 'number'\n\n                if (isRelatedToCustomNumberID) {\n                  hasNumberIDRelation = true\n                }\n              },\n            )\n\n            if (hasNumberIDRelation) {\n              result.value[multiIDCondition]?.push({\n                [path]: { [operatorKey]: parseFloat(formattedValue) },\n              })\n            }\n          }\n        }\n\n        const length = result.value[multiIDCondition]?.length\n\n        if (typeof length === 'number' && length > 1) {\n          return result\n        }\n      }\n\n      if (formattedOperator === 'like' && typeof formattedValue === 'string') {\n        const words = formattedValue.split(' ')\n\n        const result = {\n          value: {\n            $and: words.map((word) => ({\n              [path]: {\n                $options: 'i',\n                $regex: word.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'),\n              },\n            })),\n          },\n        }\n\n        return result\n      }\n\n      if (formattedOperator === 'not_like' && typeof formattedValue === 'string') {\n        const words = formattedValue.split(' ')\n\n        const result = {\n          value: {\n            $and: words.map((word) => ({\n              [path]: {\n                $not: {\n                  $options: 'i',\n                  $regex: word.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'),\n                },\n              },\n            })),\n          },\n        }\n\n        return result\n      }\n\n      // Some operators like 'near' need to define a full query\n      // so if there is no operator key, just return the value\n      if (!operatorKey) {\n        return {\n          path,\n          value: formattedValue,\n        }\n      }\n\n      return {\n        path,\n        value: { [operatorKey]: formattedValue },\n      }\n    }\n  }\n  return undefined\n}\n"],"names":["Types","APIError","getFieldByPath","getLocalizedPaths","validOperatorSet","getCollection","isObjectID","operatorMap","sanitizeQueryValue","subQueryOptions","lean","buildSearchParam","collectionSlug","fields","globalSlug","incomingPath","locale","operator","parentIsLocalized","payload","val","sanitizedPath","replace","paths","hasCustomID","customIDFieldType","collections","customIDType","undefined","idFieldType","push","complete","field","name","type","path","sanitizedQueryValue","formattedOperator","rawQuery","formattedValue","length","value","pathsToQuery","slice","reverse","relationshipQuery","i","subPath","entries","collectionConfig","Model","SubModel","adapter","db","subQuery","buildQuery","where","select","_id","joinPath","relationshipField","flattenedFields","on","localizedPath","pathHasLocalized","config","localization","defaultLocale","result","find","$in","forEach","doc","ref","segment","split","Array","isArray","item","stringID","toString","ObjectId","isValid","nextSubPath","map","has","operatorKey","hasNumberIDRelation","multiIDCondition","relationTo","isRelatedToCustomNumberID","parseFloat","words","$and","word","$options","$regex","$not"],"mappings":"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"}