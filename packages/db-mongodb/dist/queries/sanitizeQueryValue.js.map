{"version":3,"sources":["../../src/queries/sanitizeQueryValue.ts"],"sourcesContent":["import type {\n  FlattenedBlock,\n  FlattenedBlocksField,\n  FlattenedField,\n  Operator,\n  Payload,\n  RelationshipField,\n} from 'payload'\n\nimport { Types } from 'mongoose'\nimport { createArrayFromCommaDelineated } from 'payload'\nimport { fieldShouldBeLocalized } from 'payload/shared'\n\ntype SanitizeQueryValueArgs = {\n  field: FlattenedField\n  hasCustomID: boolean\n  locale?: string\n  operator: Operator\n  parentIsLocalized: boolean\n  path: string\n  payload: Payload\n  val: any\n}\n\nconst buildExistsQuery = (formattedValue: unknown, path: string, treatEmptyString = true) => {\n  if (formattedValue) {\n    return {\n      rawQuery: {\n        $and: [\n          { [path]: { $exists: true } },\n          { [path]: { $ne: null } },\n          ...(treatEmptyString ? [{ [path]: { $ne: '' } }] : []), // Treat empty string as null / undefined\n        ],\n      },\n    }\n  } else {\n    return {\n      rawQuery: {\n        $or: [\n          { [path]: { $exists: false } },\n          { [path]: { $eq: null } },\n          ...(treatEmptyString ? [{ [path]: { $eq: '' } }] : []), // Treat empty string as null / undefined\n        ],\n      },\n    }\n  }\n}\n\n// returns nestedField Field object from blocks.nestedField path because getLocalizedPaths splits them only for relationships\nconst getFieldFromSegments = ({\n  field,\n  payload,\n  segments,\n}: {\n  field: FlattenedBlock | FlattenedField\n  payload: Payload\n  segments: string[]\n}): FlattenedField | undefined => {\n  if ('blocks' in field || 'blockReferences' in field) {\n    const _field: FlattenedBlocksField = field as FlattenedBlocksField\n    for (const _block of _field.blockReferences ?? _field.blocks) {\n      const block: FlattenedBlock | undefined =\n        typeof _block === 'string' ? payload.blocks[_block] : _block\n      if (block) {\n        const field = getFieldFromSegments({ field: block, payload, segments })\n        if (field) {\n          return field\n        }\n      }\n    }\n  }\n\n  if ('fields' in field) {\n    for (let i = 0; i < segments.length; i++) {\n      const foundField = field.flattenedFields.find((each) => each.name === segments[i])\n\n      if (!foundField) {\n        break\n      }\n\n      if (foundField && segments.length - 1 === i) {\n        return foundField\n      }\n\n      segments.shift()\n      return getFieldFromSegments({ field: foundField, payload, segments })\n    }\n  }\n}\n\nexport const sanitizeQueryValue = ({\n  field,\n  hasCustomID,\n  locale,\n  operator,\n  parentIsLocalized,\n  path,\n  payload,\n  val,\n}: SanitizeQueryValueArgs):\n  | {\n      operator?: string\n      rawQuery?: unknown\n      val?: unknown\n    }\n  | undefined => {\n  let formattedValue = val\n  let formattedOperator = operator\n\n  if (['array', 'blocks', 'group', 'tab'].includes(field.type) && path.includes('.')) {\n    const segments = path.split('.')\n    segments.shift()\n    const foundField = getFieldFromSegments({ field, payload, segments })\n\n    if (foundField) {\n      field = foundField\n    }\n  }\n\n  // Disregard invalid _ids\n  if (path === '_id') {\n    if (typeof val === 'string' && val.split(',').length === 1) {\n      if (!hasCustomID) {\n        const isValid = Types.ObjectId.isValid(val)\n\n        if (!isValid) {\n          return { operator: formattedOperator, val: undefined }\n        } else {\n          if (['in', 'not_in'].includes(operator)) {\n            formattedValue = createArrayFromCommaDelineated(formattedValue).map(\n              (id) => new Types.ObjectId(id),\n            )\n          } else {\n            formattedValue = new Types.ObjectId(val)\n          }\n        }\n      }\n\n      if (field.type === 'number') {\n        const parsedNumber = parseFloat(val)\n\n        if (Number.isNaN(parsedNumber)) {\n          return { operator: formattedOperator, val: undefined }\n        }\n      }\n    } else if (Array.isArray(val) || (typeof val === 'string' && val.split(',').length > 1)) {\n      if (typeof val === 'string') {\n        formattedValue = createArrayFromCommaDelineated(val)\n      }\n\n      if (Array.isArray(formattedValue)) {\n        formattedValue = formattedValue.reduce<unknown[]>((formattedValues, inVal) => {\n          if (!hasCustomID) {\n            if (Types.ObjectId.isValid(inVal)) {\n              formattedValues.push(new Types.ObjectId(inVal))\n\n              return formattedValues\n            }\n          }\n\n          if (field.type === 'number') {\n            const parsedNumber = parseFloat(inVal)\n            if (!Number.isNaN(parsedNumber)) {\n              formattedValues.push(parsedNumber)\n            }\n          } else {\n            formattedValues.push(inVal)\n          }\n\n          return formattedValues\n        }, [])\n      }\n    }\n  }\n\n  // Cast incoming values as proper searchable types\n  if (field.type === 'checkbox' && typeof val === 'string') {\n    if (val.toLowerCase() === 'true') {\n      formattedValue = true\n    }\n    if (val.toLowerCase() === 'false') {\n      formattedValue = false\n    }\n  }\n\n  if (['all', 'in', 'not_in'].includes(operator) && typeof formattedValue === 'string') {\n    formattedValue = createArrayFromCommaDelineated(formattedValue)\n\n    if (field.type === 'number' && Array.isArray(formattedValue)) {\n      formattedValue = formattedValue.map((arrayVal) => parseFloat(arrayVal))\n    }\n  }\n\n  if (field.type === 'number') {\n    if (typeof formattedValue === 'string' && operator !== 'exists') {\n      formattedValue = Number(val)\n    }\n\n    if (operator === 'exists') {\n      formattedValue = val === 'true' ? true : val === 'false' ? false : Boolean(val)\n      return buildExistsQuery(formattedValue, path)\n    }\n  }\n\n  if (field.type === 'date' && typeof val === 'string' && operator !== 'exists') {\n    formattedValue = new Date(val)\n    if (Number.isNaN(Date.parse(formattedValue))) {\n      return undefined\n    }\n  }\n\n  if (['relationship', 'upload'].includes(field.type)) {\n    if (val === 'null') {\n      formattedValue = null\n    }\n\n    // Object equality requires the value to be the first key in the object that is being queried.\n    if (\n      operator === 'equals' &&\n      formattedValue &&\n      typeof formattedValue === 'object' &&\n      formattedValue.value &&\n      formattedValue.relationTo\n    ) {\n      const { value } = formattedValue\n      const isValid = Types.ObjectId.isValid(value)\n\n      if (isValid) {\n        formattedValue.value = new Types.ObjectId(value)\n      }\n\n      let localizedPath = path\n\n      if (\n        fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n        payload.config.localization &&\n        locale\n      ) {\n        localizedPath = `${path}.${locale}`\n      }\n\n      return {\n        rawQuery: {\n          $or: [\n            {\n              [localizedPath]: {\n                $eq: {\n                  // disable auto sort\n                  /* eslint-disable */\n                  value: formattedValue.value,\n                  relationTo: formattedValue.relationTo,\n                  /* eslint-enable */\n                },\n              },\n            },\n            {\n              [localizedPath]: {\n                $eq: {\n                  relationTo: formattedValue.relationTo,\n                  value: formattedValue.value,\n                },\n              },\n            },\n          ],\n        },\n      }\n    }\n\n    const relationTo = (field as RelationshipField).relationTo\n\n    if (['in', 'not_in'].includes(operator) && Array.isArray(formattedValue)) {\n      formattedValue = formattedValue.reduce((formattedValues, inVal) => {\n        if (!inVal) {\n          return formattedValues\n        }\n\n        if (typeof relationTo === 'string' && payload.collections[relationTo]?.customIDType) {\n          if (payload.collections[relationTo].customIDType === 'number') {\n            const parsedNumber = parseFloat(inVal)\n            if (!Number.isNaN(parsedNumber)) {\n              formattedValues.push(parsedNumber)\n              return formattedValues\n            }\n          }\n\n          formattedValues.push(inVal)\n          return formattedValues\n        }\n\n        if (\n          Array.isArray(relationTo) &&\n          relationTo.some((relationTo) => !!payload.collections[relationTo]?.customIDType)\n        ) {\n          if (Types.ObjectId.isValid(inVal.toString())) {\n            formattedValues.push(new Types.ObjectId(inVal))\n          } else {\n            formattedValues.push(inVal)\n          }\n          return formattedValues\n        }\n\n        if (Types.ObjectId.isValid(inVal.toString())) {\n          formattedValues.push(new Types.ObjectId(inVal))\n        }\n\n        return formattedValues\n      }, [])\n    }\n\n    // Handle hasMany relationships with equals operator and array values\n    // For array equality checking\n    if (\n      ['equals', 'not_equals'].includes(operator) &&\n      Array.isArray(formattedValue) &&\n      'hasMany' in field &&\n      field.hasMany\n    ) {\n      if (typeof relationTo === 'string') {\n        const customIDType = payload.collections[relationTo]?.customIDType\n\n        // Convert array values to proper types (ObjectId or custom ID type)\n        formattedValue = formattedValue.map((v) => {\n          if (customIDType === 'number') {\n            const parsed = parseFloat(v)\n            return Number.isNaN(parsed) ? v : parsed\n          }\n          if (!Types.ObjectId.isValid(v)) {\n            return v\n          }\n          return new Types.ObjectId(v)\n        })\n      } else {\n        // Polymorphic hasMany - convert array of {relationTo, value} objects\n        formattedValue = formattedValue.map((item) => {\n          if (typeof item === 'object' && 'value' in item) {\n            const relTo = item.relationTo\n            const customIDType = payload.collections[relTo]?.customIDType\n            if (customIDType === 'number') {\n              const parsed = parseFloat(item.value)\n              return { relationTo: relTo, value: Number.isNaN(parsed) ? item.value : parsed }\n            }\n            if (Types.ObjectId.isValid(item.value)) {\n              return { relationTo: relTo, value: new Types.ObjectId(item.value) }\n            }\n            return item\n          }\n          // Non-polymorphic format - just IDs\n          if (Types.ObjectId.isValid(item)) {\n            return new Types.ObjectId(item)\n          }\n          return item\n        })\n      }\n    } else if (\n      ['contains', 'equals', 'like', 'not_equals'].includes(operator) &&\n      (!Array.isArray(relationTo) || !path.endsWith('.relationTo'))\n    ) {\n      if (typeof relationTo === 'string') {\n        const customIDType = payload.collections[relationTo]?.customIDType\n\n        if (customIDType) {\n          if (customIDType === 'number') {\n            formattedValue = parseFloat(val)\n\n            if (Number.isNaN(formattedValue)) {\n              return { operator: formattedOperator, val: undefined }\n            }\n          }\n        } else {\n          if (!Types.ObjectId.isValid(formattedValue)) {\n            return { operator: formattedOperator, val: undefined }\n          }\n          formattedValue = new Types.ObjectId(formattedValue)\n        }\n      } else {\n        const hasCustomIDType = relationTo.some(\n          (relationTo) => !!payload.collections[relationTo]?.customIDType,\n        )\n\n        if (hasCustomIDType) {\n          if (typeof val === 'string') {\n            const formattedNumber = Number(val)\n            formattedValue = [Types.ObjectId.isValid(val) ? new Types.ObjectId(val) : val]\n            formattedOperator = operator === 'not_equals' ? 'not_in' : 'in'\n            if (!Number.isNaN(formattedNumber)) {\n              formattedValue.push(formattedNumber)\n            }\n          }\n        } else {\n          if (!Types.ObjectId.isValid(formattedValue)) {\n            return { operator: formattedOperator, val: undefined }\n          }\n          formattedValue = new Types.ObjectId(formattedValue)\n        }\n      }\n    }\n\n    if (\n      operator === 'all' &&\n      Array.isArray(relationTo) &&\n      path.endsWith('.value') &&\n      Array.isArray(formattedValue)\n    ) {\n      formattedValue.forEach((v, i) => {\n        if (Types.ObjectId.isValid(v)) {\n          formattedValue[i] = new Types.ObjectId(v)\n        }\n      })\n    }\n  }\n\n  // Set up specific formatting necessary by operators\n\n  if (operator === 'near') {\n    let lng\n    let lat\n    let maxDistance\n    let minDistance\n\n    if (Array.isArray(formattedValue)) {\n      ;[lng, lat, maxDistance, minDistance] = formattedValue\n    }\n\n    if (typeof formattedValue === 'string') {\n      ;[lng, lat, maxDistance, minDistance] = createArrayFromCommaDelineated(formattedValue)\n    }\n\n    if (lng == null || lat == null || (maxDistance == null && minDistance == null)) {\n      formattedValue = undefined\n    } else {\n      formattedValue = {\n        $geometry: { type: 'Point', coordinates: [parseFloat(lng), parseFloat(lat)] },\n      }\n\n      if (maxDistance && !Number.isNaN(Number(maxDistance))) {\n        formattedValue.$maxDistance = parseFloat(maxDistance)\n      }\n\n      if (minDistance && !Number.isNaN(Number(minDistance))) {\n        formattedValue.$minDistance = parseFloat(minDistance)\n      }\n    }\n  }\n\n  if (operator === 'within' || operator === 'intersects') {\n    formattedValue = {\n      $geometry: formattedValue,\n    }\n  }\n\n  if (path !== '_id' || (path === '_id' && hasCustomID && field.type === 'text')) {\n    if (operator === 'contains' && !Types.ObjectId.isValid(formattedValue)) {\n      formattedValue = {\n        $options: 'i',\n        $regex: formattedValue.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'),\n      }\n    }\n\n    if (operator === 'exists') {\n      formattedValue = formattedValue === 'true' || formattedValue === true\n\n      let treatEmptyString = !['array', 'blocks', 'checkbox', 'relationship', 'upload'].includes(\n        field.type,\n      )\n\n      if (field.type === 'text' && field.hasMany) {\n        treatEmptyString = false\n      } else if (field.type === 'number' && field.hasMany) {\n        treatEmptyString = false\n      } else if (field.type === 'select' && field.hasMany) {\n        treatEmptyString = false\n      }\n\n      // _id can't be empty string, will error Cast to ObjectId failed for value \"\"\n      return buildExistsQuery(formattedValue, path, treatEmptyString)\n    }\n  }\n\n  if (\n    (path === '_id' || path === 'parent') &&\n    operator === 'like' &&\n    formattedValue.length === 24 &&\n    !hasCustomID\n  ) {\n    formattedOperator = 'equals'\n  }\n\n  if (operator === 'exists') {\n    formattedValue = formattedValue === 'true' || formattedValue === true\n\n    // Clearable fields\n    if (['relationship', 'select', 'upload'].includes(field.type)) {\n      if (formattedValue) {\n        return {\n          rawQuery: {\n            $and: [{ [path]: { $exists: true } }, { [path]: { $ne: null } }],\n          },\n        }\n      } else {\n        return {\n          rawQuery: {\n            $or: [{ [path]: { $exists: false } }, { [path]: { $eq: null } }],\n          },\n        }\n      }\n    }\n  }\n\n  return { operator: formattedOperator, val: formattedValue }\n}\n"],"names":["Types","createArrayFromCommaDelineated","fieldShouldBeLocalized","buildExistsQuery","formattedValue","path","treatEmptyString","rawQuery","$and","$exists","$ne","$or","$eq","getFieldFromSegments","field","payload","segments","_field","_block","blockReferences","blocks","block","i","length","foundField","flattenedFields","find","each","name","shift","sanitizeQueryValue","hasCustomID","locale","operator","parentIsLocalized","val","formattedOperator","includes","type","split","isValid","ObjectId","undefined","map","id","parsedNumber","parseFloat","Number","isNaN","Array","isArray","reduce","formattedValues","inVal","push","toLowerCase","arrayVal","Boolean","Date","parse","value","relationTo","localizedPath","config","localization","collections","customIDType","some","toString","hasMany","v","parsed","item","relTo","endsWith","hasCustomIDType","formattedNumber","forEach","lng","lat","maxDistance","minDistance","$geometry","coordinates","$maxDistance","$minDistance","$options","$regex","replace"],"mappings":"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"}