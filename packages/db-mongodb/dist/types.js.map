{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import type { ClientSession } from 'mongodb'\nimport type { IndexDefinition, IndexOptions, Model, PaginateModel, SchemaOptions } from 'mongoose'\nimport type {\n  ArrayField,\n  BlocksField,\n  CheckboxField,\n  CodeField,\n  CollapsibleField,\n  DateField,\n  EmailField,\n  Field,\n  GroupField,\n  JoinField,\n  JSONField,\n  MigrationData,\n  NumberField,\n  Payload,\n  PayloadRequest,\n  PointField,\n  RadioField,\n  RelationshipField,\n  RichTextField,\n  RowField,\n  SanitizedConfig,\n  SelectField,\n  TabsField,\n  TextareaField,\n  TextField,\n  UploadField,\n} from 'payload'\n\nimport type { BuildQueryArgs } from './queries/getBuildQueryPlugin.js'\n\nexport interface CollectionModel extends Model<any>, PaginateModel<any> {\n  /** buildQuery is used to transform payload's where operator into what can be used by mongoose (e.g. id => _id) */\n  buildQuery: (args: BuildQueryArgs) => Promise<Record<string, unknown>> // TODO: Delete this\n}\n\nexport interface AuthCollectionModel extends CollectionModel {\n  resetPasswordExpiration: Date\n  resetPasswordToken: string\n}\n\nexport type TypeOfIndex = {\n  fields: IndexDefinition\n  options?: IndexOptions\n}\n\nexport interface GlobalModel extends Model<Document> {\n  buildQuery: (query: unknown, locale?: string) => Promise<Record<string, unknown>>\n}\n\nexport type BuildSchema<TSchema> = (args: {\n  config: SanitizedConfig\n  fields: Field[]\n  options: BuildSchemaOptions\n}) => TSchema\n\nexport type BuildSchemaOptions = {\n  allowIDField?: boolean\n  disableUnique?: boolean\n  draftsEnabled?: boolean\n  indexSortableFields?: boolean\n  options?: SchemaOptions\n}\n\nexport type FieldGenerator<TSchema, TField> = {\n  config: SanitizedConfig\n  field: TField\n  options: BuildSchemaOptions\n  schema: TSchema\n}\n\nexport type FieldGeneratorFunction<TSchema, TField extends Field> = (\n  args: FieldGenerator<TSchema, TField>,\n) => void\n\n/**\n * Object mapping types to a schema based on TSchema\n */\nexport type FieldToSchemaMap<TSchema> = {\n  array: FieldGeneratorFunction<TSchema, ArrayField>\n  blocks: FieldGeneratorFunction<TSchema, BlocksField>\n  checkbox: FieldGeneratorFunction<TSchema, CheckboxField>\n  code: FieldGeneratorFunction<TSchema, CodeField>\n  collapsible: FieldGeneratorFunction<TSchema, CollapsibleField>\n  date: FieldGeneratorFunction<TSchema, DateField>\n  email: FieldGeneratorFunction<TSchema, EmailField>\n  group: FieldGeneratorFunction<TSchema, GroupField>\n  join: FieldGeneratorFunction<TSchema, JoinField>\n  json: FieldGeneratorFunction<TSchema, JSONField>\n  number: FieldGeneratorFunction<TSchema, NumberField>\n  point: FieldGeneratorFunction<TSchema, PointField>\n  radio: FieldGeneratorFunction<TSchema, RadioField>\n  relationship: FieldGeneratorFunction<TSchema, RelationshipField>\n  richText: FieldGeneratorFunction<TSchema, RichTextField>\n  row: FieldGeneratorFunction<TSchema, RowField>\n  select: FieldGeneratorFunction<TSchema, SelectField>\n  tabs: FieldGeneratorFunction<TSchema, TabsField>\n  text: FieldGeneratorFunction<TSchema, TextField>\n  textarea: FieldGeneratorFunction<TSchema, TextareaField>\n  upload: FieldGeneratorFunction<TSchema, UploadField>\n}\n\nexport type MigrateUpArgs = {\n  /**\n   * The Payload instance that you can use to execute Local API methods\n   * To use the current transaction you must pass `req` to arguments\n   * @example\n   * ```ts\n   *  import { type MigrateUpArgs } from '@payloadcms/db-mongodb'\n   *\n   * export async function up({ session, payload, req }: MigrateUpArgs): Promise<void> {\n   *   const posts = await payload.find({ collection: 'posts', req })\n   * }\n   * ```\n   */\n  payload: Payload\n  /**\n   * The `PayloadRequest` object that contains the current transaction\n   */\n  req: PayloadRequest\n  /**\n   * The MongoDB client session that you can use to execute MongoDB methods directly within the current transaction.\n   * @example\n   * ```ts\n   * import { type MigrateUpArgs } from '@payloadcms/db-mongodb'\n   *\n   * export async function up({ session, payload, req }: MigrateUpArgs): Promise<void> {\n   *   const { rows: posts } = await payload.db.collections.posts.collection.find({ session }).toArray()\n   * }\n   * ```\n   */\n  session?: ClientSession\n}\nexport type MigrateDownArgs = {\n  /**\n   * The Payload instance that you can use to execute Local API methods\n   * To use the current transaction you must pass `req` to arguments\n   * @example\n   * ```ts\n   * import { type MigrateDownArgs } from '@payloadcms/db-mongodb'\n   *\n   * export async function down({ session, payload, req }: MigrateDownArgs): Promise<void> {\n   *   const posts = await payload.find({ collection: 'posts', req })\n   * }\n   * ```\n   */\n  payload: Payload\n  /**\n   * The `PayloadRequest` object that contains the current transaction\n   */\n  req: PayloadRequest\n  /**\n   * The MongoDB client session that you can use to execute MongoDB methods directly within the current transaction.\n   * @example\n   * ```ts\n   * import { type MigrateDownArgs } from '@payloadcms/db-mongodb'\n   *\n   * export async function down({ session, payload, req }: MigrateDownArgs): Promise<void> {\n   *   const { rows: posts } = await payload.db.collections.posts.collection.find({ session }).toArray()\n   * }\n   * ```\n   */\n  session?: ClientSession\n}\n\nexport type MongooseMigration = {\n  down: (args: MigrateDownArgs) => Promise<void>\n  up: (args: MigrateUpArgs) => Promise<void>\n} & MigrationData\n"],"names":[],"mappings":"AAuKA,WAGiB"}