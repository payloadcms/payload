{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import type {\n  BasePostgresAdapter,\n  GenericEnum,\n  MigrateDownArgs,\n  MigrateUpArgs,\n  PostgresDB,\n  PostgresSchemaHook,\n} from '@payloadcms/drizzle/postgres'\nimport type { DrizzleAdapter } from '@payloadcms/drizzle/types'\nimport type { VercelPool, VercelPostgresPoolConfig } from '@vercel/postgres'\nimport type { DrizzleConfig } from 'drizzle-orm'\nimport type { NodePgDatabase } from 'drizzle-orm/node-postgres'\nimport type { PgSchema, PgTableFn, PgTransactionConfig } from 'drizzle-orm/pg-core'\n\nexport type Args = {\n  /**\n   * Transform the schema after it's built.\n   * You can use it to customize the schema with features that aren't supported by Payload.\n   * Examples may include: composite indices, generated columns, vectors\n   */\n  afterSchemaInit?: PostgresSchemaHook[]\n  /**\n   * Enable this flag if you want to thread your own ID to create operation data, for example:\n   * ```ts\n   * // doc created with id 1\n   * const doc = await payload.create({ collection: 'posts', data: {id: 1, title: \"my title\"}})\n   * ```\n   */\n  allowIDOnCreate?: boolean\n  /**\n   * Transform the schema before it's built.\n   * You can use it to preserve an existing database schema and if there are any collissions Payload will override them.\n   * To generate Drizzle schema from the database, see [Drizzle Kit introspection](https://orm.drizzle.team/kit-docs/commands#introspect--pull)\n   */\n  beforeSchemaInit?: PostgresSchemaHook[]\n  /**\n   * Store blocks as JSON column instead of storing them in relational structure.\n   */\n  blocksAsJSON?: boolean\n  connectionString?: string\n  /**\n   * Pass `true` to disale auto database creation if it doesn't exist.\n   * @default false\n   */\n  disableCreateDatabase?: boolean\n  extensions?: string[]\n  /**\n   * By default, we connect to a local database using the `pg` module instead of `@vercel/postgres`.\n   * This is because `@vercel/postgres` doesn't work with local databases.\n   * If you still want to use `@vercel/postgres` even locally you can pass `true` here\n   * and you'd to spin up the database with a special Neon's Docker Compose setup - https://vercel.com/docs/storage/vercel-postgres/local-development#option-2:-local-postgres-instance-with-docker\n   */\n  forceUseVercelPostgres?: boolean\n  /** Generated schema from payload generate:db-schema file path */\n  generateSchemaOutputFile?: string\n  idType?: 'serial' | 'uuid'\n  localesSuffix?: string\n  logger?: DrizzleConfig['logger']\n  migrationDir?: string\n  /**\n   * Optional pool configuration for Vercel Postgres\n   * If not provided, vercel/postgres will attempt to use the Vercel environment variables\n   */\n  pool?: VercelPostgresPoolConfig\n  prodMigrations?: {\n    down: (args: MigrateDownArgs) => Promise<void>\n    name: string\n    up: (args: MigrateUpArgs) => Promise<void>\n  }[]\n  push?: boolean\n  readReplicas?: string[]\n  relationshipsSuffix?: string\n  /**\n   * The schema name to use for the database\n   *\n   * @experimental This only works when there are not other tables or enums of the same name in the database under a different schema. Awaiting fix from Drizzle.\n   */\n  schemaName?: string\n  tablesFilter?: string[]\n  transactionOptions?: false | PgTransactionConfig\n  versionsSuffix?: string\n}\n\nexport interface GeneratedDatabaseSchema {\n  schemaUntyped: Record<string, unknown>\n}\n\ntype ResolveSchemaType<T> = 'schema' extends keyof T\n  ? T['schema']\n  : GeneratedDatabaseSchema['schemaUntyped']\n\ntype Drizzle = NodePgDatabase<ResolveSchemaType<GeneratedDatabaseSchema>>\n\nexport type VercelPostgresAdapter = {\n  drizzle: Drizzle\n  forceUseVercelPostgres?: boolean\n  pool?: VercelPool\n  poolOptions?: Args['pool']\n} & BasePostgresAdapter\n\ndeclare module 'payload' {\n  export interface DatabaseAdapter\n    extends Omit<Args, 'idType' | 'logger' | 'migrationDir' | 'pool'>,\n      DrizzleAdapter {\n    afterSchemaInit: PostgresSchemaHook[]\n    beforeSchemaInit: PostgresSchemaHook[]\n    beginTransaction: (options?: PgTransactionConfig) => Promise<null | number | string>\n    drizzle: Drizzle\n    enums: Record<string, GenericEnum>\n    extensions: Record<string, boolean>\n    extensionsFilter: Set<string>\n    /**\n     * An object keyed on each table, with a key value pair where the constraint name is the key, followed by the dot-notation field name\n     * Used for returning properly formed errors from unique fields\n     */\n    fieldConstraints: Record<string, Record<string, string>>\n    idType: Args['idType']\n    initializing: Promise<void>\n    localesSuffix?: string\n    logger: DrizzleConfig['logger']\n    pgSchema?: { table: PgTableFn } | PgSchema\n    pool: VercelPool\n    poolOptions: Args['pool']\n    prodMigrations?: {\n      down: (args: MigrateDownArgs) => Promise<void>\n      name: string\n      up: (args: MigrateUpArgs) => Promise<void>\n    }[]\n    push: boolean\n    rejectInitializing: () => void\n    relationshipsSuffix?: string\n    resolveInitializing: () => void\n    schema: Record<string, unknown>\n    schemaName?: Args['schemaName']\n    tableNameMap: Map<string, string>\n    tablesFilter?: string[]\n    versionsSuffix?: string\n  }\n}\n"],"names":[],"mappings":"AA6FA,WAKuB"}