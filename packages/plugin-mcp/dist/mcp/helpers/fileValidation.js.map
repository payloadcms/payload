{"version":3,"sources":["../../../src/mcp/helpers/fileValidation.ts"],"sourcesContent":["import type { CollectionConfig } from 'payload'\n\nimport { existsSync } from 'fs'\nimport { join } from 'path'\n\nexport type ValidationType = 'collection' | 'task' | 'workflow'\n\nexport interface ValidationResult<T = unknown> {\n  config?: T\n  error?: string\n  success: boolean\n}\n\n// Custom task config interface that matches what we're creating\nexport interface TaskConfig {\n  handler: (args: {\n    input: Record<string, unknown>\n    job: Record<string, unknown>\n    tasks: Record<string, unknown>\n  }) => Record<string, unknown>\n  inputSchema?: Array<{\n    label?: string\n    name: string\n    options?: Array<{ label: string; value: string }>\n    required?: boolean\n    type: string\n  }>\n  label?: string\n  outputSchema?: Array<{\n    label?: string\n    name: string\n    options?: Array<{ label: string; value: string }>\n    required?: boolean\n    type: string\n  }>\n  retries?: number\n  slug: string\n}\n\n// Custom workflow config interface that matches what we're creating\nexport interface WorkflowConfig {\n  handler: (args: {\n    input: Record<string, unknown>\n    job: Record<string, unknown>\n    tasks: Record<string, unknown>\n  }) => void\n  inputSchema?: Array<{\n    label?: string\n    name: string\n    options?: Array<{ label: string; value: string }>\n    required?: boolean\n    type: string\n  }>\n  label?: string\n  queue?: string\n  retries?: number\n  slug: string\n}\n\n/**\n * Generic validation function for Payload configuration files\n * @param fileName - The name of the file (e.g., 'Users.ts', 'my-task.ts')\n * @param type - The type of validation to perform ('collection', 'task', or 'workflow')\n * @returns Object containing success status and any error messages\n */\nexport const validatePayloadFile = async <T = CollectionConfig | TaskConfig | WorkflowConfig>(\n  fileName: string,\n  type: ValidationType,\n): Promise<ValidationResult<T>> => {\n  try {\n    const basePath = type === 'collection' ? 'collections' : type === 'task' ? 'tasks' : 'workflows'\n    const fullPath = join(process.cwd(), 'src', basePath)\n    const filePath = join(fullPath, fileName)\n\n    // Check if file exists\n    if (!existsSync(filePath)) {\n      return {\n        error: `${type} file does not exist: ${fileName}`,\n        success: false,\n      }\n    }\n\n    // Clear require cache to ensure fresh import\n    delete require.cache[filePath]\n\n    // Use relative path for webpack compatibility\n    const moduleName = fileName.replace('.ts', '')\n    const relativePath = `../${basePath}/${moduleName}`\n\n    // Dynamic import with relative path\n    const importedModule = await import(/* webpackIgnore: true */ relativePath)\n\n    // Get the configuration based on type\n    let config: T | undefined\n\n    if (type === 'collection') {\n      config = getCollectionConfig(importedModule, moduleName) as T\n    } else if (type === 'task') {\n      config = getTaskConfig(importedModule) as T\n    } else if (type === 'workflow') {\n      config = getWorkflowConfig(importedModule) as T\n    }\n\n    if (!config) {\n      return {\n        error: `${type} file does not export a valid ${type} config`,\n        success: false,\n      }\n    }\n\n    // Validate the configuration\n    let validationResult: ValidationResult<unknown>\n    if (type === 'collection') {\n      validationResult = validateCollectionConfig(config as unknown as CollectionConfig)\n    } else if (type === 'task') {\n      validationResult = validateTaskConfig(config as unknown as TaskConfig)\n    } else if (type === 'workflow') {\n      validationResult = validateWorkflowConfig(config as unknown as WorkflowConfig)\n    } else {\n      return {\n        error: `Unknown validation type: ${type}`,\n        success: false,\n      }\n    }\n\n    if (!validationResult.success) {\n      return validationResult as ValidationResult<T>\n    }\n\n    return {\n      config,\n      success: true,\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error during validation'\n    return {\n      error: `Failed to validate ${type} file: ${errorMessage}`,\n      success: false,\n    }\n  }\n}\n\n/**\n * Extract collection configuration from module exports\n */\nfunction getCollectionConfig(\n  importedModule: Record<string, unknown>,\n  moduleName: string,\n): CollectionConfig | undefined {\n  if (importedModule.default) {\n    return importedModule.default as CollectionConfig\n  }\n\n  if (importedModule[moduleName]) {\n    return importedModule[moduleName] as CollectionConfig\n  }\n\n  return undefined\n}\n\n/**\n * Extract task configuration from module exports\n */\nfunction getTaskConfig(importedModule: Record<string, unknown>): TaskConfig | undefined {\n  // First check for default export\n  if (importedModule.default) {\n    return importedModule.default as TaskConfig\n  }\n\n  // Look for named exports ending with \"Task\"\n  const exportNames = Object.keys(importedModule)\n  const taskExport = exportNames.find((name) => name.endsWith('Task'))\n\n  if (taskExport) {\n    return importedModule[taskExport] as TaskConfig\n  }\n\n  return undefined\n}\n\n/**\n * Extract workflow configuration from module exports\n */\nfunction getWorkflowConfig(importedModule: Record<string, unknown>): undefined | WorkflowConfig {\n  // First check for default export\n  if (importedModule.default) {\n    return importedModule.default as WorkflowConfig\n  }\n\n  // Look for named exports ending with \"Workflow\"\n  const exportNames = Object.keys(importedModule)\n  const workflowExport = exportNames.find((name) => name.endsWith('Workflow'))\n\n  if (workflowExport) {\n    return importedModule[workflowExport] as WorkflowConfig\n  }\n\n  return undefined\n}\n\n/**\n * Validate collection configuration structure\n */\nfunction validateCollectionConfig(config: CollectionConfig): ValidationResult<CollectionConfig> {\n  if (!config) {\n    return {\n      error: 'Collection config is not a valid object',\n      success: false,\n    }\n  }\n\n  if (!config.slug) {\n    return {\n      error: 'Collection config must have a valid slug property',\n      success: false,\n    }\n  }\n\n  // Validate each field has required properties\n  if (config.fields) {\n    for (let i = 0; i < config.fields.length; i++) {\n      const field = config.fields[i] as Record<string, unknown>\n      if (!field) {\n        return {\n          error: `Field at index ${i} is not a valid object`,\n          success: false,\n        }\n      }\n\n      // Check if field has type property\n      if ('type' in field && field.type) {\n        return {\n          error: `Field at index ${i} has invalid type property`,\n          success: false,\n        }\n      }\n    }\n  }\n\n  return { config, success: true }\n}\n\n/**\n * Validate task configuration structure\n */\nfunction validateTaskConfig(config: TaskConfig): ValidationResult<TaskConfig> {\n  if (!config) {\n    return {\n      error: 'Task config is not a valid object',\n      success: false,\n    }\n  }\n\n  if (!config.slug) {\n    return {\n      error: 'Task config must have a valid slug property',\n      success: false,\n    }\n  }\n\n  if (!config.handler) {\n    return {\n      error: 'Task config must have a valid handler function',\n      success: false,\n    }\n  }\n\n  // Validate optional properties\n  if (config.retries !== undefined && config.retries < 0) {\n    return {\n      error: 'Task config retries must be a non-negative number',\n      success: false,\n    }\n  }\n\n  // Validate schemas if present\n  if (config.inputSchema && Array.isArray(config.inputSchema)) {\n    for (let i = 0; i < config.inputSchema.length; i++) {\n      const field = config.inputSchema[i]\n      if (!field) {\n        return {\n          error: `Input schema field at index ${i} is not a valid object`,\n          success: false,\n        }\n      }\n\n      if (!field.name) {\n        return {\n          error: `Input schema field at index ${i} must have a valid name property`,\n          success: false,\n        }\n      }\n\n      if (!field.type) {\n        return {\n          error: `Input schema field at index ${i} must have a valid type property`,\n          success: false,\n        }\n      }\n    }\n  }\n\n  if (config.outputSchema && Array.isArray(config.outputSchema)) {\n    for (let i = 0; i < config.outputSchema.length; i++) {\n      const field = config.outputSchema[i]\n      if (!field) {\n        return {\n          error: `Output schema field at index ${i} is not a valid object`,\n          success: false,\n        }\n      }\n\n      if (!field.name) {\n        return {\n          error: `Output schema field at index ${i} must have a valid name property`,\n          success: false,\n        }\n      }\n\n      if (!field.type) {\n        return {\n          error: `Output schema field at index ${i} must have a valid type property`,\n          success: false,\n        }\n      }\n    }\n  }\n\n  return { config, success: true }\n}\n\n/**\n * Validate workflow configuration structure\n */\nfunction validateWorkflowConfig(config: WorkflowConfig): ValidationResult<WorkflowConfig> {\n  if (!config) {\n    return {\n      error: 'Workflow config is not a valid object',\n      success: false,\n    }\n  }\n\n  if (!config.slug) {\n    return {\n      error: 'Workflow config must have a valid slug property',\n      success: false,\n    }\n  }\n\n  if (!config.handler) {\n    return {\n      error: 'Workflow config must have a valid handler function',\n      success: false,\n    }\n  }\n\n  // Validate optional properties\n  if (config.queue) {\n    return {\n      error: 'Workflow config queue must be a string',\n      success: false,\n    }\n  }\n\n  if (config.retries !== undefined && config.retries < 0) {\n    return {\n      error: 'Workflow config retries must be a non-negative number',\n      success: false,\n    }\n  }\n\n  // Validate schema if present\n  if (config.inputSchema && Array.isArray(config.inputSchema)) {\n    for (let i = 0; i < config.inputSchema.length; i++) {\n      const field = config.inputSchema[i]\n      if (!field) {\n        return {\n          error: `Input schema field at index ${i} is not a valid object`,\n          success: false,\n        }\n      }\n\n      if (!field.name) {\n        return {\n          error: `Input schema field at index ${i} must have a valid name property`,\n          success: false,\n        }\n      }\n\n      if (!field.type) {\n        return {\n          error: `Input schema field at index ${i} must have a valid type property`,\n          success: false,\n        }\n      }\n    }\n  }\n\n  return { config, success: true }\n}\n\n// Convenience functions for backward compatibility\nexport const validateCollectionFile = async (\n  fileName: string,\n): Promise<ValidationResult<CollectionConfig>> => {\n  return validatePayloadFile<CollectionConfig>(fileName, 'collection')\n}\n\nexport const validateTaskFile = async (fileName: string): Promise<ValidationResult<TaskConfig>> => {\n  return validatePayloadFile<TaskConfig>(fileName, 'task')\n}\n\nexport const validateWorkflowFile = async (\n  fileName: string,\n): Promise<ValidationResult<WorkflowConfig>> => {\n  return validatePayloadFile<WorkflowConfig>(fileName, 'workflow')\n}\n"],"names":["existsSync","join","validatePayloadFile","fileName","type","basePath","fullPath","process","cwd","filePath","error","success","require","cache","moduleName","replace","relativePath","importedModule","config","getCollectionConfig","getTaskConfig","getWorkflowConfig","validationResult","validateCollectionConfig","validateTaskConfig","validateWorkflowConfig","errorMessage","Error","message","default","undefined","exportNames","Object","keys","taskExport","find","name","endsWith","workflowExport","slug","fields","i","length","field","handler","retries","inputSchema","Array","isArray","outputSchema","queue","validateCollectionFile","validateTaskFile","validateWorkflowFile"],"mappings":"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"}