{"version":3,"sources":["../../../src/mcp/helpers/fields.ts"],"sourcesContent":["type FieldDefinition = {\n  description?: string\n  name: string\n  options?: { label: string; value: string }[]\n  position?: 'main' | 'sidebar'\n  required?: boolean\n  type: string\n}\n\ntype FieldModification = {\n  changes: {\n    description?: string\n    options?: { label: string; value: string }[]\n    position?: 'main' | 'sidebar'\n    required?: boolean\n    type?: string\n  }\n  fieldName: string\n}\n\n/**\n * Adds new fields to a collection file content\n */\nexport function addFieldsToCollection(content: string, newFields: FieldDefinition[]): string {\n  // Find the fields array closing bracket\n  const fieldsRegex = /fields:\\s*\\[([\\s\\S]*?)\\]\\s*(?:,\\s*)?\\}/\n  const match = content.match(fieldsRegex)\n\n  if (!match) {\n    throw new Error('Could not find fields array in collection file')\n  }\n\n  // Generate new field definitions\n  const newFieldDefinitions = newFields\n    .map((field) => {\n      const fieldConfig = []\n      fieldConfig.push(`    {`)\n      fieldConfig.push(`      name: '${field.name}',`)\n      fieldConfig.push(`      type: '${field.type}',`)\n\n      if (field.required) {\n        fieldConfig.push(`      required: true,`)\n      }\n\n      if (field.description || field.position) {\n        fieldConfig.push(`      admin: {`)\n        if (field.description) {\n          fieldConfig.push(`        description: '${field.description}',`)\n        }\n        if (field.position) {\n          fieldConfig.push(`        position: '${field.position}',`)\n        }\n        fieldConfig.push(`      },`)\n      }\n\n      if (field.options && field.type === 'select') {\n        fieldConfig.push(`      options: [`)\n        field.options.forEach((option: { label: string; value: string }) => {\n          fieldConfig.push(`        { label: '${option.label}', value: '${option.value}' },`)\n        })\n        fieldConfig.push(`      ],`)\n      }\n\n      fieldConfig.push(`    },`)\n      return fieldConfig.join('\\n')\n    })\n    .join('\\n')\n\n  // Add new fields before the closing bracket\n  const existingFields = match[1] || ''\n  const hasTrailingComma = existingFields.trim().endsWith(',')\n  const separator = hasTrailingComma ? '\\n' : ',\\n'\n\n  return content.replace(\n    fieldsRegex,\n    `fields: [${existingFields}${separator}${newFieldDefinitions}\\n  ],\n}`,\n  )\n}\n\n/**\n * Removes fields from a collection file content\n */\nexport function removeFieldsFromCollection(content: string, fieldNames: string[]): string {\n  let updatedContent = content\n\n  fieldNames.forEach((fieldName) => {\n    // Create regex to match the field definition\n    const fieldRegex = new RegExp(\n      `\\\\s*{[^}]*name:\\\\s*['\"]${fieldName}['\"][^}]*}[^}]*(?:},?|,?\\\\s*})`,\n      'gs',\n    )\n    updatedContent = updatedContent.replace(fieldRegex, '')\n  })\n\n  // Clean up any double commas or trailing commas\n  updatedContent = updatedContent.replace(/,\\s*,/g, ',')\n  updatedContent = updatedContent.replace(/,\\s*\\]/g, '\\n  ]')\n\n  return updatedContent\n}\n\n/**\n * Modifies existing fields in a collection file content\n */\nexport function modifyFieldsInCollection(\n  content: string,\n  modifications: FieldModification[],\n): string {\n  let updatedContent = content\n\n  modifications.forEach((mod) => {\n    const { changes, fieldName } = mod\n\n    // Find the field definition\n    const fieldRegex = new RegExp(`({[^}]*name:\\\\s*['\"]${fieldName}['\"][^}]*})`, 'gs')\n    const fieldMatch = updatedContent.match(fieldRegex)\n\n    if (fieldMatch) {\n      let fieldDef = fieldMatch[0]\n\n      // Apply changes\n      if (changes.type) {\n        fieldDef = fieldDef.replace(/type:\\s*'[^']*'/, `type: '${changes.type}'`)\n      }\n\n      if (changes.required !== undefined) {\n        if (fieldDef.includes('required:')) {\n          fieldDef = fieldDef.replace(/required:[^,]*/, `required: ${changes.required}`)\n        } else {\n          fieldDef = fieldDef.replace(\n            /type:\\s*'[^']*',/,\n            `type: '${changes.type}',\\n      required: ${changes.required},`,\n          )\n        }\n      }\n\n      if (changes.description) {\n        const adminRegex = /admin:\\s*\\{[^}]*\\}/\n        if (fieldDef.match(adminRegex)) {\n          fieldDef = fieldDef.replace(\n            /description:\\s*'[^']*'/,\n            `description: '${changes.description}'`,\n          )\n        } else {\n          fieldDef = fieldDef.replace(\n            /\\},?\\s*$/,\n            `,\\n      admin: {\\n        description: '${changes.description}',\\n      },\\n    }`,\n          )\n        }\n      }\n\n      updatedContent = updatedContent.replace(fieldRegex, fieldDef)\n    }\n  })\n\n  return updatedContent\n}\n"],"names":["addFieldsToCollection","content","newFields","fieldsRegex","match","Error","newFieldDefinitions","map","field","fieldConfig","push","name","type","required","description","position","options","forEach","option","label","value","join","existingFields","hasTrailingComma","trim","endsWith","separator","replace","removeFieldsFromCollection","fieldNames","updatedContent","fieldName","fieldRegex","RegExp","modifyFieldsInCollection","modifications","mod","changes","fieldMatch","fieldDef","undefined","includes","adminRegex"],"mappings":"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"}