{"version":3,"sources":["../../../../src/mcp/tools/resource/update.ts"],"sourcesContent":["import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'\nimport type { JSONSchema4 } from 'json-schema'\nimport type { PayloadRequest, TypedUser } from 'payload'\n\nimport { z } from 'zod'\n\nimport type { PluginMCPServerConfig } from '../../../types.js'\n\nimport { toCamelCase } from '../../../utils/camelCase.js'\nimport { convertCollectionSchemaToZod } from '../../../utils/convertCollectionSchemaToZod.js'\nimport { toolSchemas } from '../schemas.js'\nexport const updateResourceTool = (\n  server: McpServer,\n  req: PayloadRequest,\n  user: TypedUser,\n  verboseLogs: boolean,\n  collectionSlug: string,\n  collections: PluginMCPServerConfig['collections'],\n  schema: JSONSchema4,\n) => {\n  const tool = async (\n    data: string,\n    id?: number | string,\n    where?: string,\n    draft: boolean = false,\n    depth: number = 0,\n    overrideLock: boolean = true,\n    filePath?: string,\n    overwriteExistingFiles: boolean = false,\n    locale?: string,\n    fallbackLocale?: string,\n  ): Promise<{\n    content: Array<{\n      text: string\n      type: 'text'\n    }>\n  }> => {\n    const payload = req.payload\n\n    if (verboseLogs) {\n      payload.logger.info(\n        `[payload-mcp] Updating resource in collection: ${collectionSlug}${id ? ` with ID: ${id}` : ' with where clause'}, draft: ${draft}${locale ? `, locale: ${locale}` : ''}`,\n      )\n    }\n\n    try {\n      // Parse the data JSON\n      let parsedData: Record<string, unknown>\n      try {\n        parsedData = JSON.parse(data)\n        if (verboseLogs) {\n          payload.logger.info(\n            `[payload-mcp] Parsed data for ${collectionSlug}: ${JSON.stringify(parsedData)}`,\n          )\n        }\n      } catch (_parseError) {\n        payload.logger.error(`[payload-mcp] Invalid JSON data provided: ${data}`)\n        const response = {\n          content: [{ type: 'text' as const, text: 'Error: Invalid JSON data provided' }],\n        }\n        return (collections?.[collectionSlug]?.overrideResponse?.(response, {}, req) ||\n          response) as {\n          content: Array<{\n            text: string\n            type: 'text'\n          }>\n        }\n      }\n\n      // Validate that either id or where is provided\n      if (!id && !where) {\n        payload.logger.error('[payload-mcp] Either id or where clause must be provided')\n        const response = {\n          content: [\n            { type: 'text' as const, text: 'Error: Either id or where clause must be provided' },\n          ],\n        }\n        return (collections?.[collectionSlug]?.overrideResponse?.(response, {}, req) ||\n          response) as {\n          content: Array<{\n            text: string\n            type: 'text'\n          }>\n        }\n      }\n\n      // Parse where clause if provided\n      let whereClause = {}\n      if (where) {\n        try {\n          whereClause = JSON.parse(where)\n          if (verboseLogs) {\n            payload.logger.info(`[payload-mcp] Using where clause: ${where}`)\n          }\n        } catch (_parseError) {\n          payload.logger.error(`[payload-mcp] Invalid where clause JSON: ${where}`)\n          const response = {\n            content: [{ type: 'text' as const, text: 'Error: Invalid JSON in where clause' }],\n          }\n          return (collections?.[collectionSlug]?.overrideResponse?.(response, {}, req) ||\n            response) as {\n            content: Array<{\n              text: string\n              type: 'text'\n            }>\n          }\n        }\n      }\n\n      // Update by ID or where clause\n      if (id) {\n        // Single document update\n        const updateOptions = {\n          id,\n          collection: collectionSlug,\n          data: parsedData,\n          depth,\n          draft,\n          overrideAccess: false,\n          overrideLock,\n          req,\n          user,\n          ...(filePath && { filePath }),\n          ...(overwriteExistingFiles && { overwriteExistingFiles }),\n          ...(locale && { locale }),\n          ...(fallbackLocale && { fallbackLocale }),\n        }\n\n        if (verboseLogs) {\n          payload.logger.info(`[payload-mcp] Updating single document with ID: ${id}`)\n        }\n        const result = await payload.update({\n          ...updateOptions,\n          data: parsedData,\n        } as any)\n\n        if (verboseLogs) {\n          payload.logger.info(`[payload-mcp] Successfully updated document with ID: ${id}`)\n        }\n\n        const response = {\n          content: [\n            {\n              type: 'text' as const,\n              text: `Document updated successfully in collection \"${collectionSlug}\"!\nUpdated document:\n\\`\\`\\`json\n${JSON.stringify(result, null, 2)}\n\\`\\`\\``,\n            },\n          ],\n        }\n\n        return (collections?.[collectionSlug]?.overrideResponse?.(response, result, req) ||\n          response) as {\n          content: Array<{\n            text: string\n            type: 'text'\n          }>\n        }\n      } else {\n        // Multiple documents update\n        const updateOptions = {\n          collection: collectionSlug,\n          data: parsedData,\n          depth,\n          draft,\n          overrideAccess: false,\n          overrideLock,\n          req,\n          user,\n          where: whereClause,\n          ...(filePath && { filePath }),\n          ...(overwriteExistingFiles && { overwriteExistingFiles }),\n          ...(locale && { locale }),\n          ...(fallbackLocale && { fallbackLocale }),\n        }\n\n        if (verboseLogs) {\n          payload.logger.info(`[payload-mcp] Updating multiple documents with where clause`)\n        }\n        const result = await payload.update({\n          ...updateOptions,\n          data: parsedData,\n        } as any)\n\n        const bulkResult = result as { docs?: unknown[]; errors?: unknown[] }\n        const docs = bulkResult.docs || []\n        const errors = bulkResult.errors || []\n\n        if (verboseLogs) {\n          payload.logger.info(\n            `[payload-mcp] Successfully updated ${docs.length} documents, ${errors.length} errors`,\n          )\n        }\n\n        let responseText = `Multiple documents updated in collection \"${collectionSlug}\"!\nUpdated: ${docs.length} documents\nErrors: ${errors.length}\n---`\n\n        if (docs.length > 0) {\n          responseText += `\\n\\nUpdated documents:\n\\`\\`\\`json\n${JSON.stringify(docs, null, 2)}\n\\`\\`\\``\n        }\n\n        if (errors.length > 0) {\n          responseText += `\\n\\nErrors:\n\\`\\`\\`json\n${JSON.stringify(errors, null, 2)}\n\\`\\`\\``\n        }\n\n        const response = {\n          content: [\n            {\n              type: 'text' as const,\n              text: responseText,\n            },\n          ],\n        }\n\n        return (collections?.[collectionSlug]?.overrideResponse?.(\n          response,\n          { docs, errors },\n          req,\n        ) || response) as {\n          content: Array<{\n            text: string\n            type: 'text'\n          }>\n        }\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\n      payload.logger.error(\n        `[payload-mcp] Error updating resource in ${collectionSlug}: ${errorMessage}`,\n      )\n\n      const response = {\n        content: [\n          {\n            type: 'text' as const,\n            text: `Error updating resource in collection \"${collectionSlug}\": ${errorMessage}`,\n          },\n        ],\n      }\n\n      return (collections?.[collectionSlug]?.overrideResponse?.(response, {}, req) || response) as {\n        content: Array<{\n          text: string\n          type: 'text'\n        }>\n      }\n    }\n  }\n\n  if (collections?.[collectionSlug]?.enabled) {\n    const convertedFields = convertCollectionSchemaToZod(schema)\n\n    // Create a new schema that combines the converted fields with update-specific parameters\n    // Use .partial() to make all fields optional for partial updates\n    const updateResourceSchema = z.object({\n      ...convertedFields.partial().shape,\n      id: z.union([z.string(), z.number()]).optional().describe('The ID of the document to update'),\n      depth: z\n        .number()\n        .optional()\n        .default(0)\n        .describe('How many levels deep to populate relationships'),\n      draft: z\n        .boolean()\n        .optional()\n        .default(false)\n        .describe('Whether to update the document as a draft'),\n      fallbackLocale: z\n        .string()\n        .optional()\n        .describe('Optional: fallback locale code to use when requested locale is not available'),\n      filePath: z.string().optional().describe('File path for file uploads'),\n      locale: z\n        .string()\n        .optional()\n        .describe(\n          'Optional: locale code to update the document in (e.g., \"en\", \"es\"). Defaults to the default locale',\n        ),\n      overrideLock: z\n        .boolean()\n        .optional()\n        .default(true)\n        .describe('Whether to override document locks'),\n      overwriteExistingFiles: z\n        .boolean()\n        .optional()\n        .default(false)\n        .describe('Whether to overwrite existing files'),\n      where: z\n        .string()\n        .optional()\n        .describe('JSON string for where clause to update multiple documents'),\n    })\n\n    server.tool(\n      `update${collectionSlug.charAt(0).toUpperCase() + toCamelCase(collectionSlug).slice(1)}`,\n      `${collections?.[collectionSlug]?.description || toolSchemas.updateResource.description.trim()}`,\n      updateResourceSchema.shape,\n      async (params: Record<string, unknown>) => {\n        const {\n          id,\n          depth,\n          draft,\n          fallbackLocale,\n          filePath,\n          locale,\n          overrideLock,\n          overwriteExistingFiles,\n          where,\n          ...fieldData\n        } = params\n        // Convert field data back to JSON string format expected by the tool\n        const data = JSON.stringify(fieldData)\n        return await tool(\n          data,\n          id as number | string | undefined,\n          where as string | undefined,\n          draft as boolean,\n          depth as number,\n          overrideLock as boolean,\n          filePath as string | undefined,\n          overwriteExistingFiles as boolean,\n          locale as string | undefined,\n          fallbackLocale as string | undefined,\n        )\n      },\n    )\n  }\n}\n"],"names":["z","toCamelCase","convertCollectionSchemaToZod","toolSchemas","updateResourceTool","server","req","user","verboseLogs","collectionSlug","collections","schema","tool","data","id","where","draft","depth","overrideLock","filePath","overwriteExistingFiles","locale","fallbackLocale","payload","logger","info","parsedData","JSON","parse","stringify","_parseError","error","response","content","type","text","overrideResponse","whereClause","updateOptions","collection","overrideAccess","result","update","bulkResult","docs","errors","length","responseText","errorMessage","Error","message","enabled","convertedFields","updateResourceSchema","object","partial","shape","union","string","number","optional","describe","default","boolean","charAt","toUpperCase","slice","description","updateResource","trim","params","fieldData"],"mappings":"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"}