{"version":3,"sources":["../../../../src/mcp/tools/collection/update.ts"],"sourcesContent":["import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'\nimport type { PayloadRequest } from 'payload'\n\nimport { readFileSync, writeFileSync } from 'fs'\nimport { join } from 'path'\n\nimport {\n  addFieldsToCollection,\n  modifyFieldsInCollection,\n  removeFieldsFromCollection,\n} from '../../helpers/fields.js'\nimport { validateCollectionFile } from '../../helpers/fileValidation.js'\nimport { toolSchemas } from '../schemas.js'\n\nexport const updateCollection = async (\n  req: PayloadRequest,\n  verboseLogs: boolean,\n  collectionsDirPath: string,\n  configFilePath: string,\n  collectionName: string,\n  updateType: string,\n  newFields?: any[],\n  fieldNamesToRemove?: string[],\n  fieldModifications?: any[],\n  configUpdates?: any,\n  newContent?: string,\n) => {\n  const payload = req.payload\n  if (verboseLogs) {\n    payload.logger.info(\n      `[payload-mcp] Updating collection: ${collectionName}, updateType: ${updateType}`,\n    )\n  }\n\n  const capitalizedName = collectionName.charAt(0).toUpperCase() + collectionName.slice(1)\n  const fileName = `${capitalizedName}.ts`\n  const filePath = join(collectionsDirPath, fileName)\n\n  // Security check: ensure we're working with the collections directory\n  if (!filePath.startsWith(collectionsDirPath)) {\n    payload.logger.error(`[payload-mcp] Invalid collection path attempted: ${filePath}`)\n    return {\n      content: [\n        {\n          type: 'text' as const,\n          text: '❌ **Error**: Invalid collection path',\n        },\n      ],\n    }\n  }\n\n  try {\n    // Check if collection file exists\n    let currentContent: string\n    try {\n      currentContent = readFileSync(filePath, 'utf8')\n    } catch (_ignore) {\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: `❌ **Error**: Collection file not found: ${fileName}`,\n          },\n        ],\n      }\n    }\n\n    let updatedContent: string\n    let updateSummary: string[] = []\n\n    switch (updateType) {\n      case 'add_field':\n        if (!newFields || newFields.length === 0) {\n          return {\n            content: [\n              {\n                type: 'text' as const,\n                text: '❌ **Error**: No fields provided for add_field update type',\n              },\n            ],\n          }\n        }\n        updatedContent = addFieldsToCollection(currentContent, newFields)\n        updateSummary = newFields.map((field: any) => `Added field: ${field.name} (${field.type})`)\n        break\n\n      case 'modify_field':\n        if (!fieldModifications || fieldModifications.length === 0) {\n          return {\n            content: [\n              {\n                type: 'text' as const,\n                text: '❌ **Error**: No field modifications provided for modify_field update type',\n              },\n            ],\n          }\n        }\n        updatedContent = modifyFieldsInCollection(currentContent, fieldModifications)\n        updateSummary = fieldModifications.map((mod: any) => `Modified field: ${mod.fieldName}`)\n        break\n\n      case 'remove_field':\n        if (!fieldNamesToRemove || fieldNamesToRemove.length === 0) {\n          return {\n            content: [\n              {\n                type: 'text' as const,\n                text: '❌ **Error**: No field names provided for remove_field update type',\n              },\n            ],\n          }\n        }\n        updatedContent = removeFieldsFromCollection(currentContent, fieldNamesToRemove)\n        updateSummary = fieldNamesToRemove.map((fieldName: string) => `Removed field: ${fieldName}`)\n        break\n\n      case 'replace_content':\n        if (!newContent) {\n          return {\n            content: [\n              {\n                type: 'text' as const,\n                text: '❌ **Error**: No new content provided for replace_content update type',\n              },\n            ],\n          }\n        }\n        updatedContent = newContent\n        updateSummary = ['Replaced entire collection content']\n        break\n\n      case 'update_config':\n        if (!configUpdates) {\n          return {\n            content: [\n              {\n                type: 'text' as const,\n                text: '❌ **Error**: No config updates provided for update_config update type',\n              },\n            ],\n          }\n        }\n        // For now, we'll use a simple approach since the config helper might not have this functionality\n        updatedContent = currentContent\n        updateSummary = Object.keys(configUpdates).map((key) => `Updated config: ${key}`)\n        break\n\n      default:\n        return {\n          content: [\n            {\n              type: 'text' as const,\n              text: `❌ **Error**: Unknown update type: ${updateType}`,\n            },\n          ],\n        }\n    }\n\n    // Write the updated content back to the file\n    writeFileSync(filePath, updatedContent, 'utf8')\n    if (verboseLogs) {\n      payload.logger.info(`[payload-mcp] Successfully updated collection file: ${filePath}`)\n    }\n\n    // Validate the updated file\n    const validationResult = await validateCollectionFile(fileName)\n    if (validationResult.error) {\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: `❌ **Error**: Updated collection has validation issues:\\n\\n${validationResult.error}`,\n          },\n        ],\n      }\n    }\n\n    return {\n      content: [\n        {\n          type: 'text' as const,\n          text: `✅ **Collection updated successfully!**\n\n**File**: \\`${fileName}\\`\n**Update Type**: ${updateType}\n\n**Changes Made**:\n${updateSummary.map((summary) => `- ${summary}`).join('\\n')}\n\n**Updated Collection Code:**\n\\`\\`\\`typescript\n${updatedContent}\n\\`\\`\\``,\n        },\n      ],\n    }\n  } catch (error) {\n    const errorMessage = (error as Error).message\n    payload.logger.error(`[payload-mcp] Error updating collection: ${errorMessage}`)\n    return {\n      content: [\n        {\n          type: 'text' as const,\n          text: `❌ **Error updating collection**: ${errorMessage}`,\n        },\n      ],\n    }\n  }\n}\n\nexport const updateCollectionTool = (\n  server: McpServer,\n  req: PayloadRequest,\n  verboseLogs: boolean,\n  collectionsDirPath: string,\n  configFilePath: string,\n) => {\n  const tool = async ({\n    collectionName,\n    configUpdates,\n    fieldModifications,\n    fieldNamesToRemove,\n    newContent,\n    newFields,\n    updateType,\n  }: {\n    collectionName: string\n    configUpdates?: any\n    fieldModifications?: any[]\n    fieldNamesToRemove?: string[]\n    newContent?: string\n    newFields?: any[]\n    updateType: string\n  }) => {\n    const payload = req.payload\n\n    if (verboseLogs) {\n      payload.logger.info(\n        `[payload-mcp] Updating collection: ${collectionName}, updateType: ${updateType}`,\n      )\n    }\n\n    try {\n      const result = await updateCollection(\n        req,\n        verboseLogs,\n        collectionsDirPath,\n        configFilePath,\n        collectionName,\n        updateType,\n        newFields,\n        fieldNamesToRemove,\n        fieldModifications,\n        configUpdates,\n        newContent,\n      )\n\n      if (verboseLogs) {\n        payload.logger.info(`[payload-mcp] Collection update completed for: ${collectionName}`)\n      }\n\n      return result\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\n      payload.logger.error(\n        `[payload-mcp] Error updating collection ${collectionName}: ${errorMessage}`,\n      )\n\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: `Error updating collection \"${collectionName}\": ${errorMessage}`,\n          },\n        ],\n      }\n    }\n  }\n\n  server.tool(\n    'updateCollection',\n    toolSchemas.updateCollection.description,\n    toolSchemas.updateCollection.parameters.shape,\n    async (args) => {\n      return await tool(args)\n    },\n  )\n}\n"],"names":["readFileSync","writeFileSync","join","addFieldsToCollection","modifyFieldsInCollection","removeFieldsFromCollection","validateCollectionFile","toolSchemas","updateCollection","req","verboseLogs","collectionsDirPath","configFilePath","collectionName","updateType","newFields","fieldNamesToRemove","fieldModifications","configUpdates","newContent","payload","logger","info","capitalizedName","charAt","toUpperCase","slice","fileName","filePath","startsWith","error","content","type","text","currentContent","_ignore","updatedContent","updateSummary","length","map","field","name","mod","fieldName","Object","keys","key","validationResult","summary","errorMessage","message","updateCollectionTool","server","tool","result","Error","description","parameters","shape","args"],"mappings":"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"}