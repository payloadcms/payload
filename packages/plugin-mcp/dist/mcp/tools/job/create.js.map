{"version":3,"sources":["../../../../src/mcp/tools/job/create.ts"],"sourcesContent":["import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'\nimport type { PayloadRequest } from 'payload'\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs'\nimport { join } from 'path'\n\nimport { validatePayloadFile } from '../../helpers/fileValidation.js'\nimport { toolSchemas } from '../schemas.js'\n\nconst createOrUpdateJobFile = (\n  req: PayloadRequest,\n  verboseLogs: boolean,\n  jobsDir: string,\n  jobName: string,\n  jobType: 'task' | 'workflow',\n  jobSlug: string,\n  camelCaseJobSlug: string,\n) => {\n  const payload = req.payload\n  const jobFilePath = join(jobsDir, `${jobName}.ts`)\n  const importName = `${camelCaseJobSlug}${jobType === 'task' ? 'Task' : 'Workflow'}`\n  const importPath = `./${jobType === 'task' ? 'tasks' : 'workflows'}/${camelCaseJobSlug}`\n\n  if (verboseLogs) {\n    payload.logger.info(`[payload-mcp] Processing job file: ${jobFilePath}`)\n  }\n\n  if (existsSync(jobFilePath)) {\n    if (verboseLogs) {\n      payload.logger.info(`[payload-mcp] Updating existing job file: ${jobFilePath}`)\n    }\n\n    // Update existing job file\n    let content = readFileSync(jobFilePath, 'utf8')\n\n    // Add import if not already present\n    const importStatement = `import { ${importName} } from '${importPath}'`\n    if (!content.includes(importStatement)) {\n      if (verboseLogs) {\n        payload.logger.info(`[payload-mcp] Adding import: ${importStatement}`)\n      }\n\n      // Find the last import statement and add after it\n      const importRegex = /import\\s+(?:\\S.*)?from\\s+['\"].*['\"];?\\s*\\n/g\n      let lastImportMatch\n      let match\n      while ((match = importRegex.exec(content)) !== null) {\n        lastImportMatch = match\n      }\n\n      if (lastImportMatch) {\n        const insertIndex = lastImportMatch.index + lastImportMatch[0].length\n        content =\n          content.slice(0, insertIndex) + importStatement + '\\n' + content.slice(insertIndex)\n      } else {\n        // No imports found, add at the beginning\n        content = importStatement + '\\n\\n' + content\n      }\n    }\n\n    // Add to the appropriate array\n    const arrayName = jobType === 'task' ? 'tasks' : 'workflows'\n    const arrayRegex = new RegExp(`(${arrayName}:\\\\s*\\\\[)([^\\\\]]*)(\\\\])`, 's')\n    const arrayMatch = content.match(arrayRegex)\n\n    if (arrayMatch && arrayMatch[2]) {\n      const existingItems = arrayMatch[2].trim()\n      const newItem = existingItems ? `${existingItems},\\n    ${importName}` : `\\n    ${importName}`\n      content = content.replace(arrayRegex, `$1${newItem}\\n  $3`)\n\n      if (verboseLogs) {\n        payload.logger.info(`[payload-mcp] Added ${importName} to ${arrayName} array`)\n      }\n    } else {\n      // Array doesn't exist, add it\n      const jobsConfigRegex = /(export\\s+const\\s.*JobsConfig\\s*=\\s*\\{)([^}]*)(\\})/s\n      const jobsConfigMatch = content.match(jobsConfigRegex)\n\n      if (jobsConfigMatch && jobsConfigMatch[2]) {\n        const existingConfig = jobsConfigMatch[2].trim()\n        const newConfig = existingConfig\n          ? `${existingConfig},\\n  ${arrayName}: [\\n    ${importName}\\n  ]`\n          : `\\n  ${arrayName}: [\\n    ${importName}\\n  ]`\n        content = content.replace(jobsConfigRegex, `$1${newConfig}\\n$3`)\n\n        if (verboseLogs) {\n          payload.logger.info(`[payload-mcp] Created new ${arrayName} array with ${importName}`)\n        }\n      }\n    }\n\n    writeFileSync(jobFilePath, content)\n    if (verboseLogs) {\n      payload.logger.info(`[payload-mcp] Successfully updated job file: ${jobFilePath}`)\n    }\n  } else {\n    if (verboseLogs) {\n      payload.logger.info(`[payload-mcp] Creating new job file: ${jobFilePath}`)\n    }\n\n    // Create new job file\n    const camelCaseJobName = toCamelCase(jobName)\n    const jobFileContent = `import type { JobsConfig } from 'payload'\nimport { ${importName} } from '${importPath}'\n\nexport const ${camelCaseJobName}JobsConfig: JobsConfig = {\n  ${jobType === 'task' ? 'tasks' : 'workflows'}: [\n    ${importName}\n  ]\n}\n`\n    writeFileSync(jobFilePath, jobFileContent)\n    if (verboseLogs) {\n      payload.logger.info(`[payload-mcp] Successfully created new job file: ${jobFilePath}`)\n    }\n  }\n}\n\n// Reusable function for creating jobs\nexport const createJob = async (\n  req: PayloadRequest,\n  verboseLogs: boolean,\n  jobsDir: string,\n  jobName: string,\n  jobType: 'task' | 'workflow',\n  jobSlug: string,\n  description: string,\n  inputSchema: any,\n  outputSchema: any,\n  jobData: Record<string, any>,\n) => {\n  const payload = req.payload\n\n  if (verboseLogs) {\n    payload.logger.info(`[payload-mcp] Creating ${jobType}: ${jobName}`)\n  }\n\n  try {\n    // Ensure jobs directory exists\n    if (!existsSync(jobsDir)) {\n      if (verboseLogs) {\n        payload.logger.info(`[payload-mcp] Creating jobs directory: ${jobsDir}`)\n      }\n      mkdirSync(jobsDir, { recursive: true })\n    }\n\n    // Ensure subdirectories exist\n    const tasksDir = join(jobsDir, 'tasks')\n    const workflowsDir = join(jobsDir, 'workflows')\n\n    if (!existsSync(tasksDir)) {\n      mkdirSync(tasksDir, { recursive: true })\n    }\n    if (!existsSync(workflowsDir)) {\n      mkdirSync(workflowsDir, { recursive: true })\n    }\n\n    const camelCaseJobSlug = toCamelCase(jobSlug)\n    const targetDir = jobType === 'task' ? tasksDir : workflowsDir\n    const fileName = `${camelCaseJobSlug}.ts`\n    const filePath = join(targetDir, fileName)\n\n    if (verboseLogs) {\n      payload.logger.info(`[payload-mcp] Target file path: ${filePath}`)\n    }\n\n    // Security check: ensure we're working with the jobs directory\n    if (!filePath.startsWith(jobsDir)) {\n      payload.logger.error(`[payload-mcp] Invalid job path attempted: ${filePath}`)\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: '❌ **Error**: Invalid job path',\n          },\n        ],\n      }\n    }\n\n    // Check if file already exists\n    if (existsSync(filePath)) {\n      if (verboseLogs) {\n        payload.logger.info(`[payload-mcp] Job file already exists: ${fileName}`)\n      }\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: `❌ **Error**: Job file already exists: ${fileName}`,\n          },\n        ],\n      }\n    }\n\n    // Generate job content based on type\n    let jobContent: string\n    if (jobType === 'task') {\n      jobContent = generateTaskContent(\n        jobName,\n        jobSlug,\n        description,\n        inputSchema,\n        outputSchema,\n        jobData,\n      )\n    } else {\n      jobContent = generateWorkflowContent(\n        jobName,\n        jobSlug,\n        description,\n        inputSchema,\n        outputSchema,\n        jobData,\n      )\n    }\n\n    // Write the job file\n    writeFileSync(filePath, jobContent, 'utf8')\n    if (verboseLogs) {\n      payload.logger.info(`[payload-mcp] Successfully created job file: ${filePath}`)\n    }\n\n    // Update the main job file\n    createOrUpdateJobFile(req, verboseLogs, jobsDir, jobName, jobType, jobSlug, camelCaseJobSlug)\n\n    // Validate the generated file\n    const validationResult = await validatePayloadFile(fileName, jobType)\n    if (validationResult.error) {\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: `❌ **Error**: Generated job has validation issues:\\n\\n${validationResult.error}`,\n          },\n        ],\n      }\n    }\n\n    return {\n      content: [\n        {\n          type: 'text' as const,\n          text: `✅ **Job created successfully!**\n\n**File**: \\`${fileName}\\`\n**Type**: \\`${jobType}\\`\n**Slug**: \\`${jobSlug}\\`\n**Description**: ${description}\n\n**Generated Job Code:**\n\\`\\`\\`typescript\n${jobContent}\n\\`\\`\\``,\n        },\n      ],\n    }\n  } catch (error) {\n    const errorMessage = (error as Error).message\n    payload.logger.error(`[payload-mcp] Error creating job: ${errorMessage}`)\n\n    return {\n      content: [\n        {\n          type: 'text' as const,\n          text: `❌ **Error creating job**: ${errorMessage}`,\n        },\n      ],\n    }\n  }\n}\n\n// Helper function to generate task content\nfunction generateTaskContent(\n  jobName: string,\n  jobSlug: string,\n  description: string,\n  inputSchema: any,\n  outputSchema: any,\n  jobData: Record<string, any>,\n): string {\n  const camelCaseJobSlug = toCamelCase(jobSlug)\n\n  return `import type { Task } from 'payload'\n\nexport const ${camelCaseJobSlug}Task: Task = {\n  slug: '${jobSlug}',\n  description: '${description}',\n  inputSchema: ${JSON.stringify(inputSchema, null, 2)},\n  outputSchema: ${JSON.stringify(outputSchema, null, 2)},\n  handler: async (input, context) => {\n    // TODO: Implement your task logic here\n    // Access input data: input.fieldName\n    // Access context: context.payload, context.req, etc.\n\n    // Example implementation:\n    const result = {\n      message: 'Task executed successfully',\n      input,\n      timestamp: new Date().toISOString(),\n    }\n\n    return result\n  },\n}\n`\n}\n\n// Helper function to generate workflow content\nfunction generateWorkflowContent(\n  jobName: string,\n  jobSlug: string,\n  description: string,\n  inputSchema: any,\n  outputSchema: any,\n  jobData: Record<string, any>,\n): string {\n  const camelCaseJobSlug = toCamelCase(jobSlug)\n\n  return `import type { Workflow } from 'payload'\n\nexport const ${camelCaseJobSlug}Workflow: Workflow = {\n  slug: '${jobSlug}',\n  description: '${description}',\n  inputSchema: ${JSON.stringify(inputSchema, null, 2)},\n  outputSchema: ${JSON.stringify(outputSchema, null, 2)},\n  steps: [\n    // TODO: Define your workflow steps here\n    // Each step should be a function that returns a result\n    // Example:\n    // {\n    //   name: 'step1',\n    //   handler: async (input, context) => {\n    //     // Step logic here\n    //     return { result: 'step1 completed' }\n    //   }\n    // }\n  ],\n}\n`\n}\n\n// Helper function to convert to camel case\nfunction toCamelCase(str: string): string {\n  return str\n    .replace(/[-_\\s]+(.)?/g, (_, chr) => (chr ? chr.toUpperCase() : ''))\n    .replace(/^(.)/, (_, chr) => chr.toLowerCase())\n}\n\nexport const createJobTool = (\n  server: McpServer,\n  req: PayloadRequest,\n  verboseLogs: boolean,\n  jobsDir: string,\n) => {\n  const tool = async (\n    jobName: string,\n    jobType: 'task' | 'workflow',\n    jobSlug: string,\n    description: string,\n    inputSchema: any = {},\n    outputSchema: any = {},\n    jobData: Record<string, any> = {},\n  ) => {\n    if (verboseLogs) {\n      req.payload.logger.info(\n        `[payload-mcp] Create Job Tool called with: ${jobName}, ${jobType}, ${jobSlug}`,\n      )\n    }\n\n    try {\n      const result = await createJob(\n        req,\n        verboseLogs,\n        jobsDir,\n        jobName,\n        jobType,\n        jobSlug,\n        description,\n        inputSchema,\n        outputSchema,\n        jobData,\n      )\n\n      if (verboseLogs) {\n        req.payload.logger.info(`[payload-mcp] Create Job Tool completed successfully`)\n      }\n\n      return result\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error'\n      req.payload.logger.error(`[payload-mcp] Error in Create Job Tool: ${errorMessage}`)\n\n      return {\n        content: [\n          {\n            type: 'text' as const,\n            text: `❌ **Error in Create Job Tool**: ${errorMessage}`,\n          },\n        ],\n      }\n    }\n  }\n\n  server.tool(\n    'createJob',\n    'Creates a new Payload job (task or workflow) with specified configuration',\n    toolSchemas.createJob.parameters.shape,\n    async (args) => {\n      return tool(\n        args.jobName,\n        args.jobType,\n        args.jobSlug,\n        args.description,\n        args.inputSchema,\n        args.outputSchema,\n        args.jobData,\n      )\n    },\n  )\n}\n"],"names":["existsSync","mkdirSync","readFileSync","writeFileSync","join","validatePayloadFile","toolSchemas","createOrUpdateJobFile","req","verboseLogs","jobsDir","jobName","jobType","jobSlug","camelCaseJobSlug","payload","jobFilePath","importName","importPath","logger","info","content","importStatement","includes","importRegex","lastImportMatch","match","exec","insertIndex","index","length","slice","arrayName","arrayRegex","RegExp","arrayMatch","existingItems","trim","newItem","replace","jobsConfigRegex","jobsConfigMatch","existingConfig","newConfig","camelCaseJobName","toCamelCase","jobFileContent","createJob","description","inputSchema","outputSchema","jobData","recursive","tasksDir","workflowsDir","targetDir","fileName","filePath","startsWith","error","type","text","jobContent","generateTaskContent","generateWorkflowContent","validationResult","errorMessage","message","JSON","stringify","str","_","chr","toUpperCase","toLowerCase","createJobTool","server","tool","result","Error","parameters","shape","args"],"mappings":"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"}