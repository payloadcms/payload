{"version":3,"sources":["../../src/utils/convertCollectionSchemaToZod.ts"],"sourcesContent":["import type { JSONSchema4 } from 'json-schema'\n\nimport { jsonSchemaToZod } from 'json-schema-to-zod'\nimport * as ts from 'typescript'\nimport { z } from 'zod'\n\n/**\n * Recursively processes JSON schema properties to simplify relationship fields.\n * For create/update validation we only need to accept IDs (string/number),\n * not populated objects. This removes the $ref option from oneOf unions\n * that represent relationship fields, leaving only the ID shape.\n *\n * NOTE: This function must operate on a cloned schema to avoid mutating\n * the original JSON schema used for tool listing.\n */\nfunction simplifyRelationshipFields(schema: JSONSchema4): JSONSchema4 {\n  if (!schema || typeof schema !== 'object') {\n    return schema\n  }\n\n  const processed = { ...schema }\n\n  if (Array.isArray(processed.oneOf)) {\n    const hasRef = processed.oneOf.some(\n      (option) => option && typeof option === 'object' && '$ref' in option,\n    )\n\n    processed.oneOf = processed.oneOf.map((option) => {\n      if (option && typeof option === 'object' && '$ref' in option) {\n        // Replace unresolved $ref with a permissive object schema to keep the union shape\n        return { type: 'object', additionalProperties: true }\n      }\n      return simplifyRelationshipFields(option)\n    })\n  }\n\n  if (processed.properties && typeof processed.properties === 'object') {\n    processed.properties = Object.fromEntries(\n      Object.entries(processed.properties).map(([key, value]) => [\n        key,\n        simplifyRelationshipFields(value),\n      ]),\n    )\n  }\n\n  if (processed.items && typeof processed.items === 'object' && !Array.isArray(processed.items)) {\n    processed.items = simplifyRelationshipFields(processed.items)\n  }\n\n  return processed\n}\n\nexport const convertCollectionSchemaToZod = (schema: JSONSchema4) => {\n  // Clone to avoid mutating the original schema (used elsewhere for tool listing)\n  const schemaClone = JSON.parse(JSON.stringify(schema)) as JSONSchema4\n\n  // Remove properties that should not be included in the Zod schema\n  delete schemaClone?.properties?.id\n  delete schemaClone?.properties?.createdAt\n  delete schemaClone?.properties?.updatedAt\n  if (Array.isArray(schemaClone.required)) {\n    schemaClone.required = schemaClone.required.filter((field) => field !== 'id')\n    if (schemaClone.required.length === 0) {\n      delete schemaClone.required\n    }\n  }\n\n  const simplifiedSchema = simplifyRelationshipFields(schemaClone)\n\n  const zodSchemaAsString = jsonSchemaToZod(simplifiedSchema)\n\n  // Transpile TypeScript to JavaScript\n  const transpileResult = ts.transpileModule(zodSchemaAsString, {\n    compilerOptions: {\n      module: ts.ModuleKind.CommonJS,\n      removeComments: true,\n      strict: false,\n      target: ts.ScriptTarget.ES2018,\n    },\n  })\n\n  /**\n   * This Function evaluation is safe because:\n   * 1. The input schema comes from Payload's collection configuration, which is controlled by the application developer\n   * 2. The jsonSchemaToZod library converts JSON Schema to Zod schema definitions, producing only type validation code\n   * 3. The transpiled output contains only Zod schema definitions (z.string(), z.number(), etc.) - no executable logic\n   * 4. The resulting Zod schema is used only for parameter validation in MCP tools, not for data processing\n   * 5. No user input or external data is involved in the schema generation process\n   */\n  // eslint-disable-next-line @typescript-eslint/no-implied-eval\n  return new Function('z', `return ${transpileResult.outputText}`)(z)\n}\n"],"names":["jsonSchemaToZod","ts","z","simplifyRelationshipFields","schema","processed","Array","isArray","oneOf","hasRef","some","option","map","type","additionalProperties","properties","Object","fromEntries","entries","key","value","items","convertCollectionSchemaToZod","schemaClone","JSON","parse","stringify","id","createdAt","updatedAt","required","filter","field","length","simplifiedSchema","zodSchemaAsString","transpileResult","transpileModule","compilerOptions","module","ModuleKind","CommonJS","removeComments","strict","target","ScriptTarget","ES2018","Function","outputText"],"mappings":"AAEA,SAASA,eAAe,QAAQ,qBAAoB;AACpD,YAAYC,QAAQ,aAAY;AAChC,SAASC,CAAC,QAAQ,MAAK;AAEvB;;;;;;;;CAQC,GACD,SAASC,2BAA2BC,MAAmB;IACrD,IAAI,CAACA,UAAU,OAAOA,WAAW,UAAU;QACzC,OAAOA;IACT;IAEA,MAAMC,YAAY;QAAE,GAAGD,MAAM;IAAC;IAE9B,IAAIE,MAAMC,OAAO,CAACF,UAAUG,KAAK,GAAG;QAClC,MAAMC,SAASJ,UAAUG,KAAK,CAACE,IAAI,CACjC,CAACC,SAAWA,UAAU,OAAOA,WAAW,YAAY,UAAUA;QAGhEN,UAAUG,KAAK,GAAGH,UAAUG,KAAK,CAACI,GAAG,CAAC,CAACD;YACrC,IAAIA,UAAU,OAAOA,WAAW,YAAY,UAAUA,QAAQ;gBAC5D,kFAAkF;gBAClF,OAAO;oBAAEE,MAAM;oBAAUC,sBAAsB;gBAAK;YACtD;YACA,OAAOX,2BAA2BQ;QACpC;IACF;IAEA,IAAIN,UAAUU,UAAU,IAAI,OAAOV,UAAUU,UAAU,KAAK,UAAU;QACpEV,UAAUU,UAAU,GAAGC,OAAOC,WAAW,CACvCD,OAAOE,OAAO,CAACb,UAAUU,UAAU,EAAEH,GAAG,CAAC,CAAC,CAACO,KAAKC,MAAM,GAAK;gBACzDD;gBACAhB,2BAA2BiB;aAC5B;IAEL;IAEA,IAAIf,UAAUgB,KAAK,IAAI,OAAOhB,UAAUgB,KAAK,KAAK,YAAY,CAACf,MAAMC,OAAO,CAACF,UAAUgB,KAAK,GAAG;QAC7FhB,UAAUgB,KAAK,GAAGlB,2BAA2BE,UAAUgB,KAAK;IAC9D;IAEA,OAAOhB;AACT;AAEA,OAAO,MAAMiB,+BAA+B,CAAClB;IAC3C,gFAAgF;IAChF,MAAMmB,cAAcC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACtB;IAE9C,kEAAkE;IAClE,OAAOmB,aAAaR,YAAYY;IAChC,OAAOJ,aAAaR,YAAYa;IAChC,OAAOL,aAAaR,YAAYc;IAChC,IAAIvB,MAAMC,OAAO,CAACgB,YAAYO,QAAQ,GAAG;QACvCP,YAAYO,QAAQ,GAAGP,YAAYO,QAAQ,CAACC,MAAM,CAAC,CAACC,QAAUA,UAAU;QACxE,IAAIT,YAAYO,QAAQ,CAACG,MAAM,KAAK,GAAG;YACrC,OAAOV,YAAYO,QAAQ;QAC7B;IACF;IAEA,MAAMI,mBAAmB/B,2BAA2BoB;IAEpD,MAAMY,oBAAoBnC,gBAAgBkC;IAE1C,qCAAqC;IACrC,MAAME,kBAAkBnC,GAAGoC,eAAe,CAACF,mBAAmB;QAC5DG,iBAAiB;YACfC,QAAQtC,GAAGuC,UAAU,CAACC,QAAQ;YAC9BC,gBAAgB;YAChBC,QAAQ;YACRC,QAAQ3C,GAAG4C,YAAY,CAACC,MAAM;QAChC;IACF;IAEA;;;;;;;GAOC,GACD,8DAA8D;IAC9D,OAAO,IAAIC,SAAS,KAAK,CAAC,OAAO,EAAEX,gBAAgBY,UAAU,EAAE,EAAE9C;AACnE,EAAC"}