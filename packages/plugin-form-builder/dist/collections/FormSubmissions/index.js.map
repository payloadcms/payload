{"version":3,"sources":["../../../src/collections/FormSubmissions/index.ts"],"sourcesContent":["import type { CollectionConfig, Field } from 'payload'\n\nimport type { FormBuilderPluginConfig } from '../../types.js'\n\nimport { defaultPaymentFields } from './fields/defaultPaymentFields.js'\nimport { createCharge } from './hooks/createCharge.js'\nimport { sendEmail } from './hooks/sendEmail.js'\n\n// all settings can be overridden by the config\nexport const generateSubmissionCollection = (\n  formConfig: FormBuilderPluginConfig,\n): CollectionConfig => {\n  const formSlug = formConfig?.formOverrides?.slug || 'forms'\n\n  const enablePaymentFields = Boolean(formConfig?.fields?.payment)\n\n  const defaultFields: Field[] = [\n    {\n      name: 'form',\n      type: 'relationship',\n      relationTo: formSlug,\n      required: true,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      validate: async (value, { req: { payload }, req }) => {\n        /* Don't run in the client side */\n        if (!payload) {\n          return true\n        }\n\n        if (payload) {\n          let _existingForm\n\n          try {\n            _existingForm = await payload.findByID({\n              id: value,\n              collection: formSlug,\n              req,\n            })\n\n            return true\n          } catch (_error) {\n            return 'Cannot create this submission because this form does not exist.'\n          }\n        }\n      },\n    },\n    {\n      name: 'submissionData',\n      type: 'array',\n      fields: [\n        {\n          name: 'field',\n          type: 'text',\n          required: true,\n        },\n        {\n          name: 'value',\n          type: 'textarea',\n          required: true,\n          validate: (value: unknown) => {\n            // TODO:\n            // create a validation function that dynamically\n            // relies on the field type and its options as configured.\n\n            // How to access sibling data from this field?\n            // Need the `name` of the field in order to validate it.\n\n            // Might not be possible to use this validation function.\n            // Instead, might need to do all validation in a `beforeValidate` collection hook.\n\n            if (typeof value !== 'undefined') {\n              return true\n            }\n\n            return 'This field is required.'\n          },\n        },\n      ],\n    },\n    ...(enablePaymentFields ? [defaultPaymentFields] : []),\n  ]\n\n  const newConfig: CollectionConfig = {\n    ...(formConfig?.formSubmissionOverrides || {}),\n    slug: formConfig?.formSubmissionOverrides?.slug || 'form-submissions',\n    access: {\n      create: () => true,\n      read: ({ req: { user } }) => !!user, // logged-in users,\n      update: () => false,\n      ...(formConfig?.formSubmissionOverrides?.access || {}),\n    },\n    admin: {\n      ...(formConfig?.formSubmissionOverrides?.admin || {}),\n      enableRichTextRelationship: false,\n    },\n    fields:\n      formConfig?.formSubmissionOverrides?.fields &&\n      typeof formConfig?.formSubmissionOverrides?.fields === 'function'\n        ? formConfig.formSubmissionOverrides.fields({ defaultFields })\n        : defaultFields,\n    hooks: {\n      ...(formConfig?.formSubmissionOverrides?.hooks || {}),\n      afterChange: [\n        (data) => sendEmail(data, formConfig),\n        ...(formConfig?.formSubmissionOverrides?.hooks?.afterChange || []),\n      ],\n      beforeChange: [\n        (data) => createCharge(data, formConfig),\n        ...(formConfig?.formSubmissionOverrides?.hooks?.beforeChange || []),\n      ],\n    },\n  }\n  return newConfig\n}\n"],"names":["defaultPaymentFields","createCharge","sendEmail","generateSubmissionCollection","formConfig","formSlug","formOverrides","slug","enablePaymentFields","Boolean","fields","payment","defaultFields","name","type","relationTo","required","validate","value","req","payload","_existingForm","findByID","id","collection","_error","newConfig","formSubmissionOverrides","access","create","read","user","update","admin","enableRichTextRelationship","hooks","afterChange","data","beforeChange"],"mappings":"AAIA,SAASA,oBAAoB,QAAQ,mCAAkC;AACvE,SAASC,YAAY,QAAQ,0BAAyB;AACtD,SAASC,SAAS,QAAQ,uBAAsB;AAEhD,+CAA+C;AAC/C,OAAO,MAAMC,+BAA+B,CAC1CC;IAEA,MAAMC,WAAWD,YAAYE,eAAeC,QAAQ;IAEpD,MAAMC,sBAAsBC,QAAQL,YAAYM,QAAQC;IAExD,MAAMC,gBAAyB;QAC7B;YACEC,MAAM;YACNC,MAAM;YACNC,YAAYV;YACZW,UAAU;YACV,oFAAoF;YACpFC,UAAU,OAAOC,OAAO,EAAEC,KAAK,EAAEC,OAAO,EAAE,EAAED,GAAG,EAAE;gBAC/C,gCAAgC,GAChC,IAAI,CAACC,SAAS;oBACZ,OAAO;gBACT;gBAEA,IAAIA,SAAS;oBACX,IAAIC;oBAEJ,IAAI;wBACFA,gBAAgB,MAAMD,QAAQE,QAAQ,CAAC;4BACrCC,IAAIL;4BACJM,YAAYnB;4BACZc;wBACF;wBAEA,OAAO;oBACT,EAAE,OAAOM,QAAQ;wBACf,OAAO;oBACT;gBACF;YACF;QACF;QACA;YACEZ,MAAM;YACNC,MAAM;YACNJ,QAAQ;gBACN;oBACEG,MAAM;oBACNC,MAAM;oBACNE,UAAU;gBACZ;gBACA;oBACEH,MAAM;oBACNC,MAAM;oBACNE,UAAU;oBACVC,UAAU,CAACC;wBACT,QAAQ;wBACR,gDAAgD;wBAChD,0DAA0D;wBAE1D,8CAA8C;wBAC9C,wDAAwD;wBAExD,yDAAyD;wBACzD,kFAAkF;wBAElF,IAAI,OAAOA,UAAU,aAAa;4BAChC,OAAO;wBACT;wBAEA,OAAO;oBACT;gBACF;aACD;QACH;WACIV,sBAAsB;YAACR;SAAqB,GAAG,EAAE;KACtD;IAED,MAAM0B,YAA8B;QAClC,GAAItB,YAAYuB,2BAA2B,CAAC,CAAC;QAC7CpB,MAAMH,YAAYuB,yBAAyBpB,QAAQ;QACnDqB,QAAQ;YACNC,QAAQ,IAAM;YACdC,MAAM,CAAC,EAAEX,KAAK,EAAEY,IAAI,EAAE,EAAE,GAAK,CAAC,CAACA;YAC/BC,QAAQ,IAAM;YACd,GAAI5B,YAAYuB,yBAAyBC,UAAU,CAAC,CAAC;QACvD;QACAK,OAAO;YACL,GAAI7B,YAAYuB,yBAAyBM,SAAS,CAAC,CAAC;YACpDC,4BAA4B;QAC9B;QACAxB,QACEN,YAAYuB,yBAAyBjB,UACrC,OAAON,YAAYuB,yBAAyBjB,WAAW,aACnDN,WAAWuB,uBAAuB,CAACjB,MAAM,CAAC;YAAEE;QAAc,KAC1DA;QACNuB,OAAO;YACL,GAAI/B,YAAYuB,yBAAyBQ,SAAS,CAAC,CAAC;YACpDC,aAAa;gBACX,CAACC,OAASnC,UAAUmC,MAAMjC;mBACtBA,YAAYuB,yBAAyBQ,OAAOC,eAAe,EAAE;aAClE;YACDE,cAAc;gBACZ,CAACD,OAASpC,aAAaoC,MAAMjC;mBACzBA,YAAYuB,yBAAyBQ,OAAOG,gBAAgB,EAAE;aACnE;QACH;IACF;IACA,OAAOZ;AACT,EAAC"}