# Hierarchy System

> Automatic tree structure management for Payload collections

## Quick Start

The hierarchy system provides tree/nested structure support for any Payload collection. When enabled, it automatically maintains tree integrity, generates breadcrumb paths, and enables efficient descendant queries.

**Use it for:** Folders, nested pages, categories, organizational structures, or any hierarchical data.

**Basic Example:**

```typescript
// Collection with hierarchy enabled
{
  id: 'doc-c',
  name: 'Current Document',
  parent: 'doc-b',  // User-provided relationship field

  // Auto-generated by hierarchy system:
  _h_parentTree: ['doc-a', 'doc-b'],  // Ancestors (excluding self)
  _h_depth: 2,  // Third level (0-indexed from root)
  _h_slugPath: 'grandparent/parent/current-document',
  _h_titlePath: 'Grandparent/Parent/Current Document'
}
```

## How It Works

### Four Internal Fields

When hierarchy is enabled on a collection, four fields are automatically added:

#### 1. `_h_parentTree` (Array of IDs)

- **Purpose:** Stores the complete ancestor chain
- **Format:** `[grandparent, parent]` - ancestors only, **excluding self**
- **Use Case:** Enables efficient "find all descendants" queries
- **Example Query:** `{ _h_parentTree: { in: ['parent-id'] } }` finds all descendants

#### 2. `_h_depth` (Number)

- **Purpose:** Stores the depth/level of the document in the tree
- **Format:** `0` = root level, `1` = first level, `2` = second level, etc.
- **Indexed:** Yes, for fast depth-based queries
- **Use Case:** Filter by depth, limit tree expansion in UI, indentation

#### 3. `_h_slugPath` (String or Localized Object)

- **Purpose:** Slugified breadcrumb path for URLs and search
- **Format:** `"grandparent/parent/current"` or `{ en: "...", fr: "..." }`
- **Indexed:** Yes, for fast path-based queries
- **Use Case:** URL generation, prefix searches, breadcrumb display

#### 4. `_h_titlePath` (String or Localized Object)

- **Purpose:** Human-readable breadcrumb path
- **Format:** `"Grandparent/Parent/Current"` or `{ en: "...", fr: "..." }`
- **Indexed:** Yes, for display and search
- **Use Case:** UI breadcrumbs, search results, admin list view

### Automatic Tree Maintenance

When a document's parent or title changes:

1. **Document Update:** The document's tree data is recalculated
2. **Descendant Cascade:** ALL descendants are updated recursively
3. **Batch Processing:** Descendants processed in batches of 100 (handles unlimited depth)
4. **Path Regeneration:** All path fields regenerated for consistency

**Example:**

```typescript
// Move "Page C" from under "Page A" to under "Page B"
// Before: A → C → D → E
// After:  B → C → D → E

// Updates automatically:
// - C's _h_parentTree: [A] → [B]
// - D's _h_parentTree: [A, C] → [B, C]
// - E's _h_parentTree: [A, C, D] → [B, C, D]
// - All path fields updated for C, D, and E
```

## Performance Optimizations

### 1. Title-Only Change Optimization

**Problem:** Renaming a document should not require fetching its parent from the database.

**Solution:** When only the title changes (parent unchanged), derive the parent's path by stripping the last segment from the previous document's path.

```typescript
// Title changed from "Old Name" to "New Name"
// Previous path: "grandparent/parent/old-name"
// Derived parent path: "grandparent/parent" (strip last segment)
// New path: "grandparent/parent/new-name"
// ✅ No database query needed
```

**Performance Impact:**

- **Before:** 2 DB queries (fetch parent + update document)
- **After:** 1 DB query (update document only)
- **Improvement:** 50% reduction

See [HIERARCHY_OPTIMIZATION.md](./HIERARCHY_OPTIMIZATION.md) for details.

### 2. Batch Processing

**Problem:** Deep trees with thousands of descendants could cause memory issues.

**Solution:** Process descendants in batches of 100, paginating through all results.

```typescript
// Handles unlimited tree depth:
// Root → 1000 children → 1000 grandchildren → ...
// Processes 100 at a time using hasNextPage pagination
```

### 3. Direct Database Updates

**Problem:** Running hooks on every descendant update creates N versions and is slow.

**Solution:** Use `req.payload.db.updateOne()` directly for descendant updates, bypassing hooks and access control.

**Trade-off:** Descendants don't trigger afterChange hooks during cascade updates.

## Localization Support

If the title field is localized, path fields are automatically localized:

```typescript
// Localized document
{
  name: { en: 'Products', fr: 'Produits' },
  _prefixSlugPath: { en: 'store/products', fr: 'magasin/produits' },
  _prefixTitlePath: { en: 'Store/Products', fr: 'Magasin/Produits' }
}
```

**Behavior:**

- All locales processed simultaneously
- Non-changed locales preserve previous values
- Explicit iteration over `config.localization.localeCodes`

## Configuration

To use hierarchy, add the `hierarchy` property to your collection config.

### Basic Setup

**Enable with defaults (parent field auto-created):**

```typescript
{
  slug: 'pages',
  fields: [
    {
      name: 'title',
      type: 'text',
      required: true,
    }
  ],
  hierarchy: {
    parentFieldName: 'parent',  // Field will be auto-created
  }
}
```

The parent relationship field is automatically created with these defaults:

- `type: 'relationship'`
- `relationTo: [collection slug]` (self-referential)
- `hasMany: false`
- `index: true`
- `admin.position: 'sidebar'`

### With Custom Parent Field

If you need custom validation or UI configuration, define the parent field yourself:

```typescript
{
  slug: 'pages',
  fields: [
    {
      name: 'parentPage',
      type: 'relationship',
      relationTo: 'pages',
      hasMany: false,
      validate: (value) => {
        // Custom validation logic
      },
      admin: {
        description: 'Select a parent page',
      }
    },
    {
      name: 'title',
      type: 'text',
    }
  ],
  hierarchy: {
    parentFieldName: 'parentPage',
  }
}
```

**Note:** If you define the parent field manually, it **must** be configured as:

- `type: 'relationship'`
- `relationTo: [same collection slug]` (self-referential)
- `hasMany: false`

Otherwise, a validation error will be thrown.

### With Custom Options

```typescript
{
  slug: 'pages',
  fields: [
    {
      name: 'title',
      type: 'text',
    }
  ],
  hierarchy: {
    parentFieldName: 'parent',
    slugify: (text) => customSlugify(text),  // Optional custom slugify function
    slugPathFieldName: '_breadcrumbPath',    // Optional custom field name
    titlePathFieldName: '_breadcrumbTitle',  // Optional custom field name
  }
}
```

### Without Path Generation

If you only need the parent tree structure for queries (e.g., "find all descendants") without generating breadcrumb paths:

```typescript
{
  slug: 'categories',
  fields: [
    {
      name: 'name',
      type: 'text',
      required: true,
    }
  ],
  hierarchy: {
    parentFieldName: 'parent',
    generatePaths: false,  // Skip path generation, only track parent tree
  }
}
```

**What you get:**

- ✅ `parent` field (auto-created relationship)
- ✅ `_h_parentTree` field (for descendant queries)
- ✅ `_h_depth` field (for level tracking)
- ❌ `_h_slugPath` and `_h_titlePath` fields (skipped)

**Benefits:**

- Faster operations (no path computation)
- No dependency on `useAsTitle` field
- Simpler data model when URLs/breadcrumbs aren't needed

### Available Options

- **`parentFieldName`** (required): Name of the parent relationship field (auto-created if not defined)
- **`generatePaths`** (optional): Whether to generate path fields (`_h_slugPath` and `_h_titlePath`). Set to `false` if you only need parent tree tracking. (default: `true`)
- **`slugify`** (optional): Custom function to slugify text for path generation (only used when `generatePaths` is `true`)
- **`slugPathFieldName`** (optional): Name for slugified path field (default: `'_h_slugPath'`, only used when `generatePaths` is `true`)
- **`titlePathFieldName`** (optional): Name for title path field (default: `'_h_titlePath'`, only used when `generatePaths` is `true`)

## Use Cases

### 1. Nested Pages

Create a hierarchical page structure:

```typescript
{
  slug: 'pages',
  fields: [
    {
      name: 'title',
      type: 'text',
      required: true,
    }
  ],
  hierarchy: {
    parentFieldName: 'parent',  // Auto-created
  }
}
```

### 2. Categories

Build nested category taxonomies:

```typescript
{
  slug: 'categories',
  fields: [
    {
      name: 'name',
      type: 'text',
      required: true,
    }
  ],
  hierarchy: {
    parentFieldName: 'parentCategory',  // Auto-created
  },
  admin: {
    useAsTitle: 'name',
  }
}
```

### 3. Organizational Structure

Model departments, locations, or organizational hierarchies:

```typescript
{
  slug: 'departments',
  fields: [
    {
      name: 'deptName',
      type: 'text',
      required: true,
    }
  ],
  hierarchy: {
    parentFieldName: 'parentDept',  // Auto-created
  }
}
```

### 4. Folders (Internal Payload Feature)

The folders feature uses hierarchy internally:

```typescript
// Automatically creates "payload-folders" collection with hierarchy
config.folders = { enabled: true }

// Other collections get a relationship field pointing to folders
// The folders collection has hierarchy enabled internally
```

## Data Model

### Example Document Structure

```typescript
// Root document
{
  id: 'doc-a',
  name: 'Grandparent',
  parent: null,
  _h_parentTree: [],
  _h_depth: 0,
  _h_slugPath: 'grandparent',
  _h_titlePath: 'Grandparent'
}

// Second level
{
  id: 'doc-b',
  name: 'Parent',
  parent: 'doc-a',
  _h_parentTree: ['doc-a'],
  _h_depth: 1,
  _h_slugPath: 'grandparent/parent',
  _h_titlePath: 'Grandparent/Parent'
}

// Third level
{
  id: 'doc-c',
  name: 'Current',
  parent: 'doc-b',
  _h_parentTree: ['doc-a', 'doc-b'],
  _h_depth: 2,
  _h_slugPath: 'grandparent/parent/current',
  _h_titlePath: 'Grandparent/Parent/Current'
}
```

### Query Patterns

```typescript
// Find all descendants of a document
payload.find({
  collection: 'pages',
  where: {
    _h_parentTree: { in: ['doc-b'] }, // Finds doc-c and all its children
  },
})

// Find all documents at a specific depth
payload.find({
  collection: 'pages',
  where: {
    _h_depth: { equals: 2 }, // All documents at depth 2
  },
})

// Find all root documents
payload.find({
  collection: 'pages',
  where: {
    _h_depth: { equals: 0 },
  },
})

// Find all documents up to depth 3
payload.find({
  collection: 'pages',
  where: {
    _h_depth: { less_than_equal: 3 },
  },
})

// Find by path prefix
payload.find({
  collection: 'pages',
  where: {
    _h_slugPath: { starts_with: 'grandparent/' }, // All under grandparent
  },
})

// Search within path
payload.find({
  collection: 'pages',
  where: {
    _h_titlePath: { contains: 'Parent' },
  },
})
```

## Implementation Details

### Key Files

**Configuration:**

- [addHierarchyToCollection.ts](./addHierarchyToCollection.ts) - Adds fields and hooks to collection

**Hooks:**

- [hooks/collectionAfterChange.ts](./hooks/collectionAfterChange.ts) - Main orchestration hook

**Core Logic:**

- [utils/computeTreeData.ts](./utils/fetchParentAndComputeTree.ts) - Fetches/derives parent and computes tree
- [utils/updateDescendants.ts](./utils/updateDescendants.ts) - Batch updates all descendants
- [utils/generateTreePaths.ts](./utils/generateTreePaths.ts) - Generates slug and title paths

**Optimizations:**

- [utils/deriveParentPathsFromPrevious.ts](./utils/deriveParentPathsFromPrevious.ts) - Derives parent paths from previous doc
- [utils/getTreeChanges.ts](./utils/getTreeChanges.ts) - Detects what changed

**Path Adjustment:**

- [utils/adjustDescendantTreePaths.ts](./utils/adjustDescendantTreePaths.ts) - Updates descendant paths

**Path Adjustment Algorithm:**

When a document moves to a new parent, all its descendants must have their paths updated. The algorithm:

1. **Strip old parent prefix**: Remove the previous parent's path from the descendant's current path
2. **Prepend new parent prefix**: Add the new parent's path to the remaining path

**Example:**

```typescript
// Document "C" moves from Parent A to Parent B
// Previous parent path: "a/b"
// Descendant path: "a/b/c/descendant"
// New parent path: "x/y"

// Step 1: Strip "a/b/" → "c/descendant"
// Step 2: Prepend "x/y/" → "x/y/c/descendant" ✓
```

This ensures descendants maintain their relative position in the tree while reflecting the new parent's path.

### Hook Flow

```
1. User updates document (parent or title changed)
   ↓
2. collectionAfterChange hook triggered
   ↓
3. getTreeChanges() detects what changed
   ↓
4. computeTreeData() calculates new tree and paths
   ├─ If parent changed: fetch new parent from DB
   ├─ If only title changed: derive parent path
   └─ generateTreePaths() creates new path fields
   ↓
5. req.payload.db.updateOne() saves document
   ↓
6. updateDescendants() cascades changes
   ├─ Query descendants (batch of 100)
   ├─ For each: adjustDescendantTreePaths()
   ├─ For each: calculate new _h_parentTree
   └─ Update all in parallel with Promise.all()
   ↓
7. Repeat until hasNextPage === false
```

## Current Implementation Status

✅ **Completed:**

- Unlimited descendants support (pagination)
- Optimization for title-only changes
- Explicit localization handling
- Collection-level config option
- Auto-creation of parent field with validation
- Support for custom parent field definitions

⏳ **Future Work:**

- Migration script for existing data
- Circular reference prevention
- Background path repair job

**Key points:**

1. Process root documents first (order matters)
2. Build paths incrementally from parent paths
3. Update directly via `db.updateOne()` (bypass hooks)
4. Handle localization if needed
5. Parent field auto-created if not defined by user

## Future Considerations

### Circular Reference Prevention

Currently relies on validation elsewhere. Could add:

- Hook-level check before update
- Validate new parent is not a descendant
- Prevent self-referential parent

### Path Validation on Read

Add an afterRead hook to verify paths are in sync:

- Compare computed path vs stored path
- Log warnings for inconsistencies
- Optional auto-repair mode
