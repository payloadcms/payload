{"version":3,"sources":["../../../../src/fields/hooks/afterRead/index.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext, TypedFallbackLocale } from '../../../index.js'\nimport type { JsonObject, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'\n\nimport { getSelectMode } from '../../../utilities/getSelectMode.js'\nimport { traverseFields } from './traverseFields.js'\n\nexport type AfterReadArgs<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth?: number\n  depth: number\n  doc: T\n  draft: boolean\n  fallbackLocale: TypedFallbackLocale\n  findMany?: boolean\n  /**\n   * Controls whether locales should be flattened into the requested locale.\n   * E.g.: { [locale]: fields } -> fields\n   *\n   * @default true\n   */\n  flattenLocales?: boolean\n  global: null | SanitizedGlobalConfig\n  locale: string\n  overrideAccess: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  select?: SelectType\n  showHiddenFields: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Remove hidden fields from response\n * - Flatten locales into requested locale. If the input doc contains all locales, the output doc after this function will only contain the requested locale.\n * - Sanitize outgoing data (point field, etc.)\n * - Execute field hooks\n * - Execute read access control\n * - Populate relationships\n */\n\nexport async function afterRead<T extends JsonObject>(args: AfterReadArgs<T>): Promise<T> {\n  const {\n    collection,\n    context,\n    currentDepth: incomingCurrentDepth,\n    depth: incomingDepth,\n    doc: incomingDoc,\n    draft,\n    fallbackLocale,\n    findMany,\n    flattenLocales = true,\n    global,\n    locale,\n    overrideAccess,\n    populate,\n    req,\n    select,\n    showHiddenFields,\n  } = args\n\n  const fieldPromises: Promise<void>[] = []\n  const populationPromises: Promise<void>[] = []\n\n  let depth =\n    incomingDepth || incomingDepth === 0\n      ? parseInt(String(incomingDepth), 10)\n      : req.payload.config.defaultDepth\n  if (depth > req.payload.config.maxDepth) {\n    depth = req.payload.config.maxDepth\n  }\n\n  const currentDepth = incomingCurrentDepth || 1\n\n  traverseFields({\n    collection,\n    context,\n    currentDepth,\n    depth,\n    doc: incomingDoc,\n    draft,\n    fallbackLocale,\n    fieldDepth: 0,\n    fieldPromises,\n    fields: (collection?.fields || global?.fields)!,\n    findMany: findMany!,\n    flattenLocales,\n    global,\n    locale,\n    overrideAccess,\n    parentIndexPath: '',\n    parentIsLocalized: false,\n    parentPath: '',\n    parentSchemaPath: '',\n    populate,\n    populationPromises,\n    req,\n    select,\n    selectMode: select ? getSelectMode(select) : undefined,\n    showHiddenFields,\n    siblingDoc: incomingDoc,\n  })\n\n  /**\n   * Await all field and population promises in parallel.\n   * A field promise is able to add more field promises to the fieldPromises array, which will not be\n   * awaited in the first run.\n   * This is why we need to loop again to process the new field promises, until there are no more field promises left.\n   */\n  let iterations = 0\n  while (fieldPromises.length > 0 || populationPromises.length > 0) {\n    const currentFieldPromises = fieldPromises.splice(0, fieldPromises.length)\n    const currentPopulationPromises = populationPromises.splice(0, populationPromises.length)\n\n    await Promise.all(currentFieldPromises)\n    await Promise.all(currentPopulationPromises)\n\n    iterations++\n    if (iterations >= 100) {\n      throw new Error(\n        'Infinite afterRead promise loop detected. A hook is likely adding field promises in an infinitely recursive way.',\n      )\n    }\n  }\n  return incomingDoc\n}\n"],"names":["getSelectMode","traverseFields","afterRead","args","collection","context","currentDepth","incomingCurrentDepth","depth","incomingDepth","doc","incomingDoc","draft","fallbackLocale","findMany","flattenLocales","global","locale","overrideAccess","populate","req","select","showHiddenFields","fieldPromises","populationPromises","parseInt","String","payload","config","defaultDepth","maxDepth","fieldDepth","fields","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","selectMode","undefined","siblingDoc","iterations","length","currentFieldPromises","splice","currentPopulationPromises","Promise","all","Error"],"mappings":"AAKA,SAASA,aAAa,QAAQ,sCAAqC;AACnE,SAASC,cAAc,QAAQ,sBAAqB;AA2BpD;;;;;;;;CAQC,GAED,OAAO,eAAeC,UAAgCC,IAAsB;IAC1E,MAAM,EACJC,UAAU,EACVC,OAAO,EACPC,cAAcC,oBAAoB,EAClCC,OAAOC,aAAa,EACpBC,KAAKC,WAAW,EAChBC,KAAK,EACLC,cAAc,EACdC,QAAQ,EACRC,iBAAiB,IAAI,EACrBC,MAAM,EACNC,MAAM,EACNC,cAAc,EACdC,QAAQ,EACRC,GAAG,EACHC,MAAM,EACNC,gBAAgB,EACjB,GAAGnB;IAEJ,MAAMoB,gBAAiC,EAAE;IACzC,MAAMC,qBAAsC,EAAE;IAE9C,IAAIhB,QACFC,iBAAiBA,kBAAkB,IAC/BgB,SAASC,OAAOjB,gBAAgB,MAChCW,IAAIO,OAAO,CAACC,MAAM,CAACC,YAAY;IACrC,IAAIrB,QAAQY,IAAIO,OAAO,CAACC,MAAM,CAACE,QAAQ,EAAE;QACvCtB,QAAQY,IAAIO,OAAO,CAACC,MAAM,CAACE,QAAQ;IACrC;IAEA,MAAMxB,eAAeC,wBAAwB;IAE7CN,eAAe;QACbG;QACAC;QACAC;QACAE;QACAE,KAAKC;QACLC;QACAC;QACAkB,YAAY;QACZR;QACAS,QAAS5B,YAAY4B,UAAUhB,QAAQgB;QACvClB,UAAUA;QACVC;QACAC;QACAC;QACAC;QACAe,iBAAiB;QACjBC,mBAAmB;QACnBC,YAAY;QACZC,kBAAkB;QAClBjB;QACAK;QACAJ;QACAC;QACAgB,YAAYhB,SAASrB,cAAcqB,UAAUiB;QAC7ChB;QACAiB,YAAY5B;IACd;IAEA;;;;;GAKC,GACD,IAAI6B,aAAa;IACjB,MAAOjB,cAAckB,MAAM,GAAG,KAAKjB,mBAAmBiB,MAAM,GAAG,EAAG;QAChE,MAAMC,uBAAuBnB,cAAcoB,MAAM,CAAC,GAAGpB,cAAckB,MAAM;QACzE,MAAMG,4BAA4BpB,mBAAmBmB,MAAM,CAAC,GAAGnB,mBAAmBiB,MAAM;QAExF,MAAMI,QAAQC,GAAG,CAACJ;QAClB,MAAMG,QAAQC,GAAG,CAACF;QAElBJ;QACA,IAAIA,cAAc,KAAK;YACrB,MAAM,IAAIO,MACR;QAEJ;IACF;IACA,OAAOpC;AACT"}