{"version":3,"sources":["../../../../src/fields/hooks/afterRead/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext, TypedFallbackLocale } from '../../../index.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectMode,\n  SelectType,\n} from '../../../types/index.js'\nimport type { Block, Field, TabAsField } from '../../config/types.js'\nimport type { AfterReadArgs } from './index.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { getBlockSelect } from '../../../utilities/getBlockSelect.js'\nimport { stripUnselectedFields } from '../../../utilities/stripUnselectedFields.js'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { relationshipPopulationPromise } from './relationshipPopulationPromise.js'\nimport { traverseFields } from './traverseFields.js'\nimport { virtualFieldPopulationPromise } from './virtualFieldPopulationPromise.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: TypedFallbackLocale\n  field: Field | TabAsField\n  /**\n   * The depth of the current field being processed.\n   * Fields without names (i.e. rows, collapsibles, unnamed groups)\n   * simply pass this value through\n   *\n   * @default 0\n   */\n  fieldDepth: number\n  fieldIndex: number\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  findMany: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  /**\n   * @todo make required in v4.0\n   */\n  parentIsLocalized?: boolean\n  parentPath: string\n  parentSchemaPath: string\n  populate?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  select?: SelectType\n  selectMode?: SelectMode\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n} & Required<Pick<AfterReadArgs<JsonObject>, 'flattenLocales'>>\n\n// This function is responsible for the following actions, in order:\n// - Remove hidden fields from response\n// - Flatten locales into requested locale\n// - Sanitize outgoing data (point field, etc.)\n// - Execute field hooks\n// - Execute read access control\n// - Populate relationships\n\nexport const promise = async ({\n  blockData,\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  field,\n  fieldDepth,\n  fieldIndex,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  populate,\n  populationPromises,\n  req,\n  select,\n  selectMode,\n  showHiddenFields,\n  siblingDoc,\n  siblingFields,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const fieldAffectsDataResult = fieldAffectsData(field)\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n  let removedFieldValue = false\n\n  const isTopLevelIDField = fieldAffectsDataResult && field.name === 'id' && fieldDepth === 0\n\n  if (\n    fieldAffectsDataResult &&\n    field.hidden &&\n    typeof siblingDoc[field.name!] !== 'undefined' &&\n    !showHiddenFields &&\n    !isTopLevelIDField\n  ) {\n    removedFieldValue = true\n    delete siblingDoc[field.name!]\n  }\n\n  if (path !== 'id') {\n    const shouldContinue = stripUnselectedFields({\n      field,\n      select: select!,\n      selectMode: selectMode!,\n      siblingDoc,\n    })\n\n    if (!shouldContinue) {\n      return\n    }\n  }\n\n  const shouldLocalizeField = fieldShouldBeLocalized({\n    field,\n    parentIsLocalized: parentIsLocalized!,\n  })\n\n  const shouldHoistLocalizedValue: boolean = Boolean(\n    flattenLocales &&\n      fieldAffectsDataResult &&\n      typeof siblingDoc[field.name!] === 'object' &&\n      siblingDoc[field.name!] !== null &&\n      shouldLocalizeField &&\n      locale !== 'all' &&\n      req.payload.config.localization,\n  )\n\n  if (fieldAffectsDataResult && shouldHoistLocalizedValue) {\n    // replace actual value with localized value before sanitizing\n    // { [locale]: fields } -> fields\n    const value = siblingDoc[field.name!][locale!]\n\n    let hoistedValue = value\n\n    if (fallbackLocale && fallbackLocale !== locale) {\n      let fallbackValue\n      const isNullOrUndefined = typeof value === 'undefined' || value === null\n\n      if (Array.isArray(fallbackLocale)) {\n        for (const locale of fallbackLocale) {\n          const val = siblingDoc[field.name!]?.[locale]\n          if (val !== undefined && val !== null && val !== '') {\n            fallbackValue = val\n            break\n          }\n        }\n      } else {\n        fallbackValue = siblingDoc[field.name!][fallbackLocale]\n      }\n\n      if (fallbackValue) {\n        switch (field.type) {\n          case 'text':\n          case 'textarea': {\n            if (value === '' || isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n\n          default: {\n            if (isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n        }\n      }\n    }\n\n    siblingDoc[field.name!] = hoistedValue\n  }\n\n  // Sanitize outgoing field value\n  switch (field.type) {\n    case 'group': {\n      // Fill groups with empty objects so fields with hooks within groups can populate\n      // themselves virtually as necessary\n      if (fieldAffectsDataResult && typeof siblingDoc[field.name] === 'undefined') {\n        siblingDoc[field.name] = {}\n      }\n\n      break\n    }\n    case 'point': {\n      const pointDoc = siblingDoc[field.name] as Record<string, unknown>\n      if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {\n        siblingDoc[field.name] = pointDoc.coordinates\n      } else {\n        siblingDoc[field.name] = undefined\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      // Rich Text fields should use afterRead hooks to do population. The previous editor.populationPromises have been renamed to editor.graphQLPopulationPromises\n      break\n    }\n\n    case 'tabs': {\n      field.tabs.forEach((tab) => {\n        if (\n          tabHasName(tab) &&\n          (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)\n        ) {\n          siblingDoc[tab.name] = {}\n        }\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n\n  // If locale is `all`, siblingDoc[field.name] will be an object mapping locales to values - locales won't be flattened.\n  // In this case, run the hook for each locale and value pair\n  const shouldRunHookOnAllLocales =\n    locale === 'all' &&\n    'name' in field &&\n    typeof field.name === 'string' &&\n    // If localized values were hoisted, siblingDoc[field.name] will not be an object mapping locales to values\n    // => Object.entries(siblingDoc[field.name]) will be the value of a single locale, not all locales\n    // => do not run the hook for each locale\n    !shouldHoistLocalizedValue &&\n    shouldLocalizeField &&\n    typeof siblingDoc[field.name] === 'object'\n\n  if (fieldAffectsDataResult) {\n    // Execute hooks\n    if (triggerHooks && 'hooks' in field && field.hooks?.afterRead) {\n      for (const hook of field.hooks.afterRead) {\n        if (shouldRunHookOnAllLocales) {\n          const localesAndValues = Object.entries(siblingDoc[field.name])\n          await Promise.all(\n            localesAndValues.map(async ([localeKey, value]) => {\n              const hookedValue = await hook({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                data: doc,\n                depth,\n                draft,\n                field,\n                findMany,\n                global,\n                indexPath: indexPathSegments,\n                operation: 'read',\n                originalDoc: doc,\n                overrideAccess,\n                path: pathSegments,\n                req,\n                schemaPath: schemaPathSegments,\n                showHiddenFields,\n                siblingData: siblingDoc,\n                siblingFields: siblingFields!,\n                value,\n              })\n\n              if (hookedValue !== undefined) {\n                siblingDoc[field.name][localeKey] = hookedValue\n              }\n            }),\n          )\n        } else {\n          const hookedValue = await hook({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            data: doc,\n            depth,\n            draft,\n            field,\n            findMany,\n            global,\n            indexPath: indexPathSegments,\n            operation: 'read',\n            originalDoc: doc,\n            overrideAccess,\n            path: pathSegments,\n            req,\n            schemaPath: schemaPathSegments,\n            showHiddenFields,\n            siblingData: siblingDoc,\n            siblingFields: siblingFields!,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }\n      }\n    }\n\n    if (\n      'virtual' in field &&\n      typeof field.virtual === 'string' &&\n      (!field.hidden || showHiddenFields)\n    ) {\n      populationPromises.push(\n        virtualFieldPopulationPromise({\n          name: field.name,\n          draft,\n          fallbackLocale: fallbackLocale!,\n          fields: (collection || global)!.flattenedFields,\n          locale: locale!,\n          overrideAccess,\n          ref: doc,\n          req,\n          segments: field.virtual.split('.'),\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n\n    // Execute access control\n    let allowDefaultValue = true\n    if (triggerAccessControl && field.access && field.access.read) {\n      const canReadField = overrideAccess\n        ? true\n        : await field.access.read({\n            id: doc.id as number | string,\n            blockData,\n            data: doc,\n            doc,\n            req,\n            siblingData: siblingDoc,\n          })\n\n      if (!canReadField) {\n        allowDefaultValue = false\n        delete siblingDoc[field.name!]\n      }\n    }\n\n    // Set defaultValue on the field for globals being returned without being first created\n    // or collection documents created prior to having a default.\n    if (\n      !removedFieldValue &&\n      allowDefaultValue &&\n      typeof siblingDoc[field.name!] === 'undefined' &&\n      typeof field.defaultValue !== 'undefined'\n    ) {\n      siblingDoc[field.name!] = await getDefaultValue({\n        defaultValue: field.defaultValue,\n        locale: locale!,\n        req,\n        user: req.user,\n        value: siblingDoc[field.name!],\n      })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload' || field.type === 'join') {\n      populationPromises.push(\n        relationshipPopulationPromise({\n          currentDepth,\n          depth,\n          draft,\n          fallbackLocale,\n          field,\n          locale,\n          overrideAccess,\n          parentIsLocalized: parentIsLocalized!,\n          populate,\n          req,\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name] as JsonObject\n\n      let arraySelect = select?.[field.name]\n\n      if (selectMode === 'include' && typeof arraySelect === 'object') {\n        arraySelect = {\n          ...arraySelect,\n          id: true,\n        }\n      }\n\n      if (Array.isArray(rows) && rows.length > 0) {\n        rows.forEach((row, rowIndex) => {\n          traverseFields({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldDepth: fieldDepth + 1,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: path + '.' + rowIndex,\n            parentSchemaPath: schemaPath,\n            populate,\n            populationPromises,\n            req,\n            select: typeof arraySelect === 'object' ? arraySelect : undefined,\n            selectMode,\n            showHiddenFields,\n            siblingDoc: row || {},\n            triggerAccessControl,\n            triggerHooks,\n          })\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              traverseFields({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                depth,\n                doc,\n                draft,\n                fallbackLocale,\n                fieldDepth: fieldDepth + 1,\n                fieldPromises,\n                fields: field.fields,\n                findMany,\n                flattenLocales,\n                global,\n                locale,\n                overrideAccess,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath,\n                populate,\n                populationPromises,\n                req,\n                showHiddenFields,\n                siblingDoc: (row as JsonObject) || {},\n                triggerAccessControl,\n                triggerHooks,\n              })\n            })\n          }\n        })\n      } else if (shouldHoistLocalizedValue && (!rows || rows.length === 0)) {\n        siblingDoc[field.name] = null\n      } else if (field.hidden !== true || showHiddenFields === true) {\n        siblingDoc[field.name] = []\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows) && rows.length > 0) {\n        rows.forEach((row, rowIndex) => {\n          const blockTypeToMatch = (row as JsonObject).blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          const { blockSelect, blockSelectMode } = getBlockSelect({\n            block: block!,\n            // TODO: fix this\n            // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n            select: select?.[field.name]!,\n            selectMode: selectMode!,\n          })\n\n          if (block) {\n            traverseFields({\n              blockData: row,\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldDepth: fieldDepth + 1,\n              fieldPromises,\n              fields: block.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath + '.' + block.slug,\n              populate,\n              populationPromises,\n              req,\n              select: typeof blockSelect === 'object' ? blockSelect : undefined,\n              selectMode: blockSelectMode,\n              showHiddenFields,\n              siblingDoc: (row as JsonObject) || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          }\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              const blockTypeToMatch = row.blockType\n\n              const block: Block | undefined =\n                req.payload.blocks[blockTypeToMatch] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n                ) as Block | undefined)\n\n              if (block) {\n                traverseFields({\n                  blockData: row,\n                  collection,\n                  context,\n                  currentDepth,\n                  depth,\n                  doc,\n                  draft,\n                  fallbackLocale,\n                  fieldDepth: fieldDepth + 1,\n                  fieldPromises,\n                  fields: block.fields,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  parentPath: path + '.' + rowIndex,\n                  parentSchemaPath: schemaPath + '.' + block.slug,\n                  populate,\n                  populationPromises,\n                  req,\n                  showHiddenFields,\n                  siblingDoc: (row as JsonObject) || {},\n                  triggerAccessControl,\n                  triggerHooks,\n                })\n              }\n            })\n          }\n        })\n      } else if (shouldHoistLocalizedValue && (!rows || rows.length === 0)) {\n        siblingDoc[field.name] = null\n      } else if (field.hidden !== true || showHiddenFields === true) {\n        siblingDoc[field.name] = []\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldDepth,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (fieldAffectsDataResult) {\n        const groupSelect =\n          typeof select?.[field.name] === 'object'\n            ? (select?.[field.name] as SelectType)\n            : undefined\n\n        if (shouldLocalizeField && !shouldHoistLocalizedValue) {\n          Object.values(siblingDoc[field.name] || {}).forEach((localizedData) => {\n            traverseFields({\n              blockData,\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldDepth: fieldDepth + 1,\n              fieldPromises,\n              fields: field.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path,\n              parentSchemaPath: schemaPath,\n              populate,\n              populationPromises,\n              req,\n              select: groupSelect,\n              selectMode,\n              showHiddenFields,\n              siblingDoc: localizedData || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          })\n        } else {\n          traverseFields({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldDepth: fieldDepth + 1,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: path,\n            parentSchemaPath: schemaPath,\n            populate,\n            populationPromises,\n            req,\n            select: groupSelect,\n            selectMode,\n            showHiddenFields,\n            siblingDoc: typeof siblingDoc[field.name] !== 'object' ? {} : siblingDoc[field.name],\n            triggerAccessControl,\n            triggerHooks,\n          })\n        }\n      } else {\n        traverseFields({\n          blockData,\n          collection,\n          context,\n          currentDepth,\n          depth,\n          doc,\n          draft,\n          fallbackLocale,\n          fieldDepth,\n          fieldPromises,\n          fields: field.fields,\n          findMany,\n          flattenLocales,\n          global,\n          locale,\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          populate,\n          populationPromises,\n          req,\n          select,\n          selectMode,\n          showHiddenFields,\n          siblingDoc,\n          triggerAccessControl,\n          triggerHooks,\n        })\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterRead?.length) {\n        for (const hook of editor.hooks.afterRead) {\n          if (shouldRunHookOnAllLocales) {\n            const localesAndValues = Object.entries(siblingDoc[field.name])\n\n            await Promise.all(\n              localesAndValues.map(async ([locale, value]) => {\n                const hookedValue = await hook({\n                  collection,\n                  context,\n                  currentDepth,\n                  data: doc,\n                  depth,\n                  draft,\n                  fallbackLocale: fallbackLocale!,\n                  field,\n                  fieldPromises,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  indexPath: indexPathSegments,\n                  locale,\n                  operation: 'read',\n                  originalDoc: doc,\n                  overrideAccess,\n                  parentIsLocalized: parentIsLocalized!,\n                  path: pathSegments,\n                  populate,\n                  populationPromises,\n                  req,\n                  schemaPath: schemaPathSegments,\n                  showHiddenFields,\n                  siblingData: siblingDoc,\n                  triggerAccessControl,\n                  triggerHooks,\n                  value,\n                })\n\n                if (hookedValue !== undefined) {\n                  siblingDoc[field.name][locale] = hookedValue\n                }\n              }),\n            )\n          } else {\n            const hookedValue = await hook({\n              collection,\n              context,\n              currentDepth,\n              data: doc,\n              depth,\n              draft,\n              fallbackLocale: fallbackLocale!,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              indexPath: indexPathSegments,\n              locale: locale!,\n              operation: 'read',\n              originalDoc: doc,\n              overrideAccess,\n              parentIsLocalized: parentIsLocalized!,\n              path: pathSegments,\n              populate,\n              populationPromises,\n              req,\n              schemaPath: schemaPathSegments,\n              showHiddenFields,\n              siblingData: siblingDoc,\n              triggerAccessControl,\n              triggerHooks,\n              value: siblingDoc[field.name],\n            })\n\n            if (hookedValue !== undefined) {\n              siblingDoc[field.name] = hookedValue\n            }\n          }\n        }\n      }\n      break\n    }\n\n    case 'tab': {\n      const tabDoc = siblingDoc\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        const tabSelect: SelectType | undefined =\n          typeof select?.[field.name] === 'object'\n            ? (select?.[field.name] as SelectType)\n            : undefined\n        if (shouldLocalizeField && !shouldHoistLocalizedValue) {\n          Object.values(siblingDoc[field.name] || {}).forEach((localizedData) => {\n            traverseFields({\n              blockData,\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldDepth: fieldDepth + 1,\n              fieldPromises,\n              fields: field.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path,\n              parentSchemaPath: schemaPath,\n              populate,\n              populationPromises,\n              req,\n              select: tabSelect,\n              selectMode,\n              showHiddenFields,\n              siblingDoc: localizedData || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          })\n        } else {\n          traverseFields({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldDepth: fieldDepth + 1,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: path,\n            parentSchemaPath: schemaPath,\n            populate,\n            populationPromises,\n            req,\n            select: tabSelect,\n            selectMode,\n            showHiddenFields,\n            siblingDoc: typeof siblingDoc[field.name] !== 'object' ? {} : siblingDoc[field.name],\n            triggerAccessControl,\n            triggerHooks,\n          })\n        }\n      } else {\n        traverseFields({\n          blockData,\n          collection,\n          context,\n          currentDepth,\n          depth,\n          doc,\n          draft,\n          fallbackLocale,\n          fieldDepth,\n          fieldPromises,\n          fields: field.fields,\n          findMany,\n          flattenLocales,\n          global,\n          locale,\n          overrideAccess,\n          parentIndexPath: isNamedTab ? '' : indexPath,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          parentPath: isNamedTab ? path : parentPath,\n          parentSchemaPath: schemaPath,\n          populate,\n          populationPromises,\n          req,\n          select,\n          selectMode,\n          showHiddenFields,\n          siblingDoc: tabDoc,\n          triggerAccessControl,\n          triggerHooks,\n        })\n      }\n\n      break\n    }\n\n    case 'tabs': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldDepth,\n        fieldPromises,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","getBlockSelect","stripUnselectedFields","fieldAffectsData","fieldShouldBeLocalized","tabHasName","getDefaultValue","getFieldPaths","relationshipPopulationPromise","traverseFields","virtualFieldPopulationPromise","promise","blockData","collection","context","currentDepth","depth","doc","draft","fallbackLocale","field","fieldDepth","fieldIndex","fieldPromises","findMany","flattenLocales","global","locale","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","populate","populationPromises","req","select","selectMode","showHiddenFields","siblingDoc","siblingFields","triggerAccessControl","triggerHooks","indexPath","path","schemaPath","index","fieldAffectsDataResult","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","removedFieldValue","isTopLevelIDField","name","hidden","shouldContinue","shouldLocalizeField","shouldHoistLocalizedValue","payload","config","localization","value","hoistedValue","fallbackValue","isNullOrUndefined","Array","isArray","val","undefined","type","pointDoc","coordinates","length","editor","Error","tabs","forEach","tab","shouldRunHookOnAllLocales","hooks","afterRead","hook","localesAndValues","Object","entries","Promise","all","localeKey","hookedValue","data","operation","originalDoc","siblingData","virtual","push","fields","flattenedFields","ref","segments","allowDefaultValue","access","read","canReadField","id","defaultValue","user","rows","arraySelect","row","rowIndex","localized","values","localeRows","blockTypeToMatch","blockType","block","blocks","blockReferences","find","curBlock","slug","blockSelect","blockSelectMode","groupSelect","localizedData","tabDoc","isNamedTab","tabSelect"],"mappings":"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"}