{"version":3,"sources":["../../../../src/fields/hooks/afterChange/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n}\n\n// This function is responsible for the following actions, in order:\n// - Execute field hooks\n\nexport const promise = async ({\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  fieldIndex,\n  global,\n  operation,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingFields,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n  const getNestedValue = (data: JsonObject, path: string[]) =>\n    path.reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : undefined), data)\n  const previousValData =\n    previousSiblingDoc && Object.keys(previousSiblingDoc).length > 0\n      ? previousSiblingDoc\n      : previousDoc\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if ('hooks' in field && field.hooks?.afterChange) {\n      for (const hook of field.hooks.afterChange) {\n        const hookedValue = await hook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          path: pathSegments,\n          previousDoc,\n          previousSiblingDoc,\n          previousValue:\n            getNestedValue(previousValData, pathSegments) ?? previousValData?.[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingFields: siblingFields!,\n          value: getNestedValue(siblingDoc, pathSegments) ?? siblingDoc?.[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingDoc[field.name] = hookedValue\n        }\n      }\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises: Promise<void>[] = []\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              previousDoc,\n              previousSiblingDoc: previousDoc?.[field.name]?.[rowIndex] || ({} as JsonObject),\n              req,\n              siblingData: siblingData?.[field.name]?.[rowIndex] || {},\n              siblingDoc: row ? { ...row } : {},\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises: Promise<void>[] = []\n\n        rows.forEach((row, rowIndex) => {\n          const blockTypeToMatch = (row as JsonObject).blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                blockData: siblingData?.[field.name]?.[rowIndex],\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                previousDoc,\n                previousSiblingDoc: previousValData?.[field.name]?.[rowIndex] || ({} as JsonObject),\n                req,\n                siblingData: siblingData?.[field.name]?.[rowIndex] || {},\n                siblingDoc: row ? { ...row } : {},\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (fieldAffectsData(field)) {\n        await traverseFields({\n          blockData,\n          collection,\n          context,\n          data,\n          doc,\n          fields: field.fields,\n          global,\n          operation,\n          parentIndexPath: '',\n          parentIsLocalized: parentIsLocalized || field.localized,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          previousDoc,\n          previousSiblingDoc: (previousDoc?.[field.name] as JsonObject) || {},\n          req,\n          siblingData: (siblingData?.[field.name] as JsonObject) || {},\n          siblingDoc: (siblingDoc?.[field.name] as JsonObject) || {},\n        })\n      } else {\n        await traverseFields({\n          blockData,\n          collection,\n          context,\n          data,\n          doc,\n          fields: field.fields,\n          global,\n          operation,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          previousDoc,\n          previousSiblingDoc: { ...previousSiblingDoc },\n          req,\n          siblingData: siblingData || {},\n          siblingDoc: { ...siblingDoc },\n        })\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field.editor\n\n      if (editor?.hooks?.afterChange?.length) {\n        for (const hook of editor.hooks.afterChange) {\n          const hookedValue = await hook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            indexPath: indexPathSegments,\n            operation,\n            originalDoc: doc,\n            parentIsLocalized,\n            path: pathSegments,\n            previousDoc,\n            previousSiblingDoc,\n            previousValue: previousDoc?.[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            value: siblingDoc?.[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabPreviousSiblingDoc = siblingDoc\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        tabSiblingData = (siblingData?.[field.name] ?? {}) as JsonObject\n        tabSiblingDoc = (siblingDoc?.[field.name] ?? {}) as JsonObject\n        tabPreviousSiblingDoc = (previousDoc?.[field.name] ?? {}) as JsonObject\n      }\n\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: tabPreviousSiblingDoc,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getFieldPaths","traverseFields","promise","blockData","collection","context","data","doc","field","fieldIndex","global","operation","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","previousDoc","previousSiblingDoc","req","siblingData","siblingDoc","siblingFields","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","getNestedValue","reduce","acc","key","undefined","previousValData","Object","keys","length","hooks","afterChange","hook","hookedValue","originalDoc","previousValue","name","value","type","rows","Array","isArray","promises","forEach","row","rowIndex","push","fields","localized","Promise","all","blockTypeToMatch","blockType","block","payload","blocks","blockReferences","find","curBlock","slug","editor","Error","tabSiblingData","tabSiblingDoc","tabPreviousSiblingDoc","isNamedTab","tabs","tab"],"mappings":"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"}