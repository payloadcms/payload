{"version":3,"sources":["../../../../src/fields/hooks/beforeDuplicate/promise.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, FieldHookArgs, TabAsField } from '../../config/types.js'\n\nimport { fieldAffectsData, fieldShouldBeLocalized } from '../../config/types.js'\nimport { getFieldPaths } from '../../getFieldPaths.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc: T\n  field: Field | TabAsField\n  fieldIndex: number\n  id?: number | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n}\n\nexport const promise = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  doc,\n  field,\n  fieldIndex,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingDoc,\n  siblingFields,\n}: Args<T>): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const { localization } = req.payload.config\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    let fieldData = siblingDoc?.[field.name!]\n    const fieldIsLocalized = localization && fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    // Run field beforeDuplicate hooks.\n    // These hooks are responsible for resetting the `id` field values of array and block rows. See `baseIDField`.\n    if (Array.isArray('hooks' in field && field.hooks?.beforeDuplicate)) {\n      if (fieldIsLocalized) {\n        const localeData: JsonObject = {}\n\n        for (const locale of localization.localeCodes) {\n          const beforeDuplicateArgs: FieldHookArgs = {\n            blockData,\n            collection,\n            context,\n            data: doc as Partial<T>,\n            field,\n            global: undefined!,\n            indexPath: indexPathSegments,\n            path: pathSegments,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingDoc[field.name!]?.[locale],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData: siblingDoc,\n            siblingDocWithLocales: siblingDoc,\n            siblingFields: siblingFields!,\n            value: siblingDoc[field.name!]?.[locale],\n          }\n\n          let hookResult\n          if ('hooks' in field && field.hooks?.beforeDuplicate) {\n            for (const hook of field.hooks.beforeDuplicate) {\n              hookResult = await hook(beforeDuplicateArgs)\n            }\n          }\n\n          if (typeof hookResult !== 'undefined') {\n            localeData[locale] = hookResult\n          }\n        }\n\n        siblingDoc[field.name!] = localeData\n      } else {\n        const beforeDuplicateArgs: FieldHookArgs = {\n          blockData,\n          collection,\n          context,\n          data: doc as Partial<T>,\n          field,\n          global: undefined!,\n          indexPath: indexPathSegments,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name!]!,\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData: siblingDoc,\n          siblingDocWithLocales: siblingDoc,\n          siblingFields: siblingFields!,\n          value: siblingDoc[field.name!]!,\n        }\n\n        let hookResult\n        if ('hooks' in field && field.hooks?.beforeDuplicate) {\n          for (const hook of field.hooks.beforeDuplicate) {\n            hookResult = await hook(beforeDuplicateArgs)\n          }\n        }\n\n        if (typeof hookResult !== 'undefined') {\n          siblingDoc[field.name!] = hookResult\n        }\n      }\n    }\n\n    // First, for any localized fields, we will loop over locales\n    // and if locale data is present, traverse the sub fields.\n    // There are only a few different fields where this is possible.\n    if (fieldIsLocalized) {\n      if (typeof fieldData !== 'object' || fieldData === null) {\n        siblingDoc[field.name!] = {}\n        fieldData = siblingDoc[field.name!]\n      }\n\n      const promises: Promise<void>[] = []\n\n      localization.localeCodes.forEach((locale) => {\n        if (fieldData[locale]) {\n          switch (field.type) {\n            case 'array': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises: Promise<void>[] = []\n\n                rows.forEach((row, rowIndex) => {\n                  promises.push(\n                    traverseFields({\n                      id,\n                      blockData,\n                      collection,\n                      context,\n                      doc,\n                      fields: field.fields,\n                      overrideAccess,\n                      parentIndexPath: '',\n                      parentIsLocalized: parentIsLocalized || field.localized!,\n                      parentPath: path + '.' + rowIndex,\n                      parentSchemaPath: schemaPath,\n                      req,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n\n              break\n            }\n\n            case 'blocks': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises: Promise<void>[] = []\n\n                rows.forEach((row, rowIndex) => {\n                  const blockTypeToMatch = row.blockType\n\n                  const block: Block | undefined =\n                    req.payload.blocks[blockTypeToMatch] ??\n                    ((field.blockReferences ?? field.blocks).find(\n                      (curBlock) =>\n                        typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n                    ) as Block | undefined)\n\n                  promises.push(\n                    traverseFields({\n                      id,\n                      blockData: row,\n                      collection,\n                      context,\n                      doc,\n                      fields: block!.fields,\n                      overrideAccess,\n                      parentIndexPath: '',\n                      parentIsLocalized: parentIsLocalized || field.localized!,\n                      parentPath: path + '.' + rowIndex,\n                      parentSchemaPath: schemaPath + '.' + block!.slug,\n                      req,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n              break\n            }\n\n            case 'group':\n            case 'tab': {\n              promises.push(\n                traverseFields({\n                  id,\n                  blockData,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentIsLocalized: parentIsLocalized || field.localized!,\n                  parentPath: path,\n                  parentSchemaPath: schemaPath,\n                  req,\n                  siblingDoc: fieldData[locale],\n                }),\n              )\n\n              break\n            }\n          }\n        }\n      })\n\n      await Promise.all(promises)\n    } else {\n      // If the field is not localized, but it affects data,\n      // we need to further traverse its children\n      // so the child fields can run beforeDuplicate hooks\n      switch (field.type) {\n        case 'array': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises: Promise<void>[] = []\n\n            rows.forEach((row, rowIndex) => {\n              promises.push(\n                traverseFields({\n                  id,\n                  blockData,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentIsLocalized: parentIsLocalized || field.localized!,\n                  parentPath: path + '.' + rowIndex,\n                  parentSchemaPath: schemaPath,\n                  req,\n                  siblingDoc: row,\n                }),\n              )\n            })\n\n            await Promise.all(promises)\n          }\n\n          break\n        }\n\n        case 'blocks': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises: Promise<void>[] = []\n\n            rows.forEach((row, rowIndex) => {\n              const blockTypeToMatch = row.blockType\n\n              const block: Block | undefined =\n                req.payload.blocks[blockTypeToMatch] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n                ) as Block | undefined)\n\n              if (block) {\n                ;(row as JsonObject).blockType = blockTypeToMatch\n\n                promises.push(\n                  traverseFields({\n                    id,\n                    blockData: row,\n                    collection,\n                    context,\n                    doc,\n                    fields: block.fields,\n                    overrideAccess,\n                    parentIndexPath: '',\n                    parentIsLocalized: parentIsLocalized || field.localized!,\n                    parentPath: path + '.' + rowIndex,\n                    parentSchemaPath: schemaPath + '.' + block.slug,\n                    req,\n                    siblingDoc: row,\n                  }),\n                )\n              }\n            })\n\n            await Promise.all(promises)\n          }\n\n          break\n        }\n\n        case 'group': {\n          if (typeof siblingDoc[field.name] !== 'object') {\n            siblingDoc[field.name] = {}\n          }\n\n          const groupDoc = siblingDoc[field.name] as JsonObject\n\n          await traverseFields({\n            id,\n            blockData,\n            collection,\n            context,\n            doc,\n            fields: field.fields,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized!,\n            parentPath: path,\n            parentSchemaPath: schemaPath,\n            req,\n            siblingDoc: groupDoc,\n          })\n\n          break\n        }\n\n        case 'tab': {\n          if (typeof siblingDoc[field.name!] !== 'object') {\n            siblingDoc[field.name!] = {}\n          }\n\n          const tabDoc = siblingDoc[field.name!] as JsonObject\n\n          await traverseFields({\n            id,\n            blockData,\n            collection,\n            context,\n            doc,\n            fields: field.fields,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized!,\n            parentPath: path,\n            parentSchemaPath: schemaPath,\n            req,\n            siblingDoc: tabDoc,\n          })\n\n          break\n        }\n      }\n    }\n  } else {\n    // Finally, we traverse fields which do not affect data here - collapsibles, rows, unnamed groups\n    switch (field.type) {\n      case 'collapsible':\n      case 'group':\n      case 'row': {\n        await traverseFields({\n          id,\n          blockData,\n          collection,\n          context,\n          doc,\n          fields: field.fields,\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          req,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      // Unnamed Tab\n      // @ts-expect-error `fieldAffectsData` inferred return type doesn't account for TabAsField\n      case 'tab': {\n        await traverseFields({\n          id,\n          blockData,\n          collection,\n          context,\n          doc,\n          // @ts-expect-error `fieldAffectsData` inferred return type doesn't account for TabAsField\n          fields: field.fields,\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          req,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      case 'tabs': {\n        await traverseFields({\n          id,\n          blockData,\n          collection,\n          context,\n          doc,\n          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          req,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n  }\n}\n"],"names":["fieldAffectsData","fieldShouldBeLocalized","getFieldPaths","traverseFields","promise","id","blockData","collection","context","doc","field","fieldIndex","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingDoc","siblingFields","indexPath","path","schemaPath","index","localization","payload","config","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","fieldData","name","fieldIsLocalized","Array","isArray","hooks","beforeDuplicate","localeData","locale","localeCodes","beforeDuplicateArgs","data","global","undefined","previousSiblingDoc","previousValue","siblingData","siblingDocWithLocales","value","hookResult","hook","promises","forEach","type","rows","row","rowIndex","push","fields","localized","blockTypeToMatch","blockType","block","blocks","blockReferences","find","curBlock","slug","Promise","all","groupDoc","tabDoc","tabs","tab"],"mappings":"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"}