{"version":3,"sources":["../../src/fields/getFieldPaths.ts"],"sourcesContent":["import type { ClientTab } from '../admin/types.js'\nimport type { ClientField, Field, Tab, TabAsFieldClient } from './config/types.js'\n\ntype Args = {\n  field: ClientField | ClientTab | Field | Tab | TabAsFieldClient\n  index: number\n  parentIndexPath: string\n  /**\n   * Needed to generate data paths. Omit if you only need schema paths, e.g. within field schema maps.\n   */\n  parentPath?: string\n  parentSchemaPath: string\n}\n\ntype FieldPaths = {\n  /**\n   * A string of '-' separated indexes representing where\n   * to find this field in a given field schema array.\n   * It will always be complete and accurate.\n   */\n  indexPath: string\n  /**\n   * Path for this field relative to its position in the data.\n   */\n  path: string\n  /**\n   * Path for this field relative to its position in the schema.\n   */\n  schemaPath: string\n}\n\nexport function getFieldPaths({\n  field,\n  index,\n  parentIndexPath,\n  parentPath = '',\n  parentSchemaPath,\n}: Args): FieldPaths {\n  const parentPathSegments = parentPath.split('.')\n\n  const parentPathIsUnnamed =\n    parentPathSegments?.[parentPathSegments.length - 1]?.startsWith('_index-')\n\n  const parentWithoutIndex = parentPathIsUnnamed\n    ? parentPathSegments.slice(0, -1).join('.')\n    : parentPath\n\n  const parentPathToUse = parentPathIsUnnamed ? parentWithoutIndex : parentPath\n\n  if ('name' in field) {\n    return {\n      indexPath: '',\n      path: `${parentPathToUse ? parentPathToUse + '.' : ''}${field.name}`,\n      schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${field.name}`,\n    }\n  }\n\n  const indexSuffix = `_index-${`${parentIndexPath ? parentIndexPath + '-' : ''}${index}`}`\n\n  const parentSchemaPathSegments = parentSchemaPath.split('.')\n\n  const parentSchemaPathIsUnnamed =\n    parentSchemaPathSegments?.[parentSchemaPathSegments.length - 1]?.startsWith('_index-')\n\n  return {\n    indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,\n    path: `${parentPathToUse ? parentPathToUse + '.' : ''}${indexSuffix}`,\n    schemaPath: parentSchemaPathIsUnnamed\n      ? `${parentSchemaPath}-${index}`\n      : `${parentSchemaPath ? parentSchemaPath + '.' : ''}${indexSuffix}`,\n  }\n}\n"],"names":["getFieldPaths","field","index","parentIndexPath","parentPath","parentSchemaPath","parentPathSegments","split","parentPathIsUnnamed","length","startsWith","parentWithoutIndex","slice","join","parentPathToUse","indexPath","path","name","schemaPath","indexSuffix","parentSchemaPathSegments","parentSchemaPathIsUnnamed"],"mappings":"AA+BA,OAAO,SAASA,cAAc,EAC5BC,KAAK,EACLC,KAAK,EACLC,eAAe,EACfC,aAAa,EAAE,EACfC,gBAAgB,EACX;IACL,MAAMC,qBAAqBF,WAAWG,KAAK,CAAC;IAE5C,MAAMC,sBACJF,oBAAoB,CAACA,mBAAmBG,MAAM,GAAG,EAAE,EAAEC,WAAW;IAElE,MAAMC,qBAAqBH,sBACvBF,mBAAmBM,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC,OACrCT;IAEJ,MAAMU,kBAAkBN,sBAAsBG,qBAAqBP;IAEnE,IAAI,UAAUH,OAAO;QACnB,OAAO;YACLc,WAAW;YACXC,MAAM,GAAGF,kBAAkBA,kBAAkB,MAAM,KAAKb,MAAMgB,IAAI,EAAE;YACpEC,YAAY,GAAGb,mBAAmBA,mBAAmB,MAAM,KAAKJ,MAAMgB,IAAI,EAAE;QAC9E;IACF;IAEA,MAAME,cAAc,CAAC,OAAO,EAAE,GAAGhB,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO,EAAE;IAEzF,MAAMkB,2BAA2Bf,iBAAiBE,KAAK,CAAC;IAExD,MAAMc,4BACJD,0BAA0B,CAACA,yBAAyBX,MAAM,GAAG,EAAE,EAAEC,WAAW;IAE9E,OAAO;QACLK,WAAW,GAAGZ,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO;QACpEc,MAAM,GAAGF,kBAAkBA,kBAAkB,MAAM,KAAKK,aAAa;QACrED,YAAYG,4BACR,GAAGhB,iBAAiB,CAAC,EAAEH,OAAO,GAC9B,GAAGG,mBAAmBA,mBAAmB,MAAM,KAAKc,aAAa;IACvE;AACF"}