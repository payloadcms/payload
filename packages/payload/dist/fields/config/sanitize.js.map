{"version":3,"sources":["../../../src/fields/config/sanitize.ts"],"sourcesContent":["import { deepMergeSimple } from '@payloadcms/translations/utilities'\nimport { v4 as uuid } from 'uuid'\n\nimport type {\n  CollectionConfig,\n  SanitizedJoin,\n  SanitizedJoins,\n} from '../../collections/config/types.js'\nimport type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { GlobalConfig } from '../../globals/config/types.js'\nimport type { Field } from './types.js'\n\nimport {\n  DuplicateFieldName,\n  InvalidConfiguration,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  MissingEditorProp,\n  MissingFieldType,\n} from '../../errors/index.js'\nimport { ReservedFieldName } from '../../errors/ReservedFieldName.js'\nimport { flattenAllFields } from '../../utilities/flattenAllFields.js'\nimport { formatLabels, toWords } from '../../utilities/formatLabels.js'\nimport { getFieldByPath } from '../../utilities/getFieldByPath.js'\nimport { validateTimezones } from '../../utilities/validateTimezones.js'\nimport { baseBlockFields } from '../baseFields/baseBlockFields.js'\nimport { baseIDField } from '../baseFields/baseIDField.js'\nimport { baseTimezoneField } from '../baseFields/timezone/baseField.js'\nimport { defaultTimezones } from '../baseFields/timezone/defaultTimezones.js'\nimport { setDefaultBeforeDuplicate } from '../setDefaultBeforeDuplicate.js'\nimport { validations } from '../validations.js'\nimport {\n  reservedAPIKeyFieldNames,\n  reservedBaseAuthFieldNames,\n  reservedBaseUploadFieldNames,\n  reservedVerifyFieldNames,\n} from './reservedFieldNames.js'\nimport { sanitizeJoinField } from './sanitizeJoinField.js'\nimport {\n  fieldAffectsData as _fieldAffectsData,\n  fieldIsLocalized,\n  fieldIsVirtual,\n  tabHasName,\n} from './types.js'\n\ntype Args = {\n  collectionConfig?: CollectionConfig\n  config: Config\n  existingFieldNames?: Set<string>\n  fields: Field[]\n  globalConfig?: GlobalConfig\n  /**\n   * Used to prevent unnecessary sanitization of fields that are not top-level.\n   */\n  isTopLevelField?: boolean\n  joinPath?: string\n  /**\n   * When not passed in, assume that join are not supported (globals, arrays, blocks)\n   */\n  joins?: SanitizedJoins\n  parentIsLocalized: boolean\n  polymorphicJoins?: SanitizedJoin[]\n  /**\n   * If true, a richText field will require an editor property to be set, as the sanitizeFields function will not add it from the payload config if not present.\n   *\n   * @default false\n   */\n  requireFieldLevelRichTextEditor?: boolean\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>\n  /**\n   * If not null, will validate that upload and relationship fields do not relate to a collection that is not in this array.\n   * This validation will be skipped if validRelationships is null.\n   */\n  validRelationships: null | string[]\n}\n\nexport const sanitizeFields = async ({\n  collectionConfig,\n  config,\n  existingFieldNames = new Set(),\n  fields,\n  globalConfig,\n  isTopLevelField = true,\n  joinPath = '',\n  joins,\n  parentIsLocalized,\n  polymorphicJoins,\n  requireFieldLevelRichTextEditor = false,\n  richTextSanitizationPromises,\n  validRelationships,\n}: Args): Promise<Field[]> => {\n  if (!fields) {\n    return []\n  }\n\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]!\n\n    if ('_sanitized' in field && field._sanitized === true) {\n      continue\n    }\n\n    if ('_sanitized' in field) {\n      field._sanitized = true\n    }\n\n    if (!field.type) {\n      throw new MissingFieldType(field)\n    }\n\n    const fieldAffectsData = _fieldAffectsData(field)\n\n    if (isTopLevelField && fieldAffectsData && field.name) {\n      if (collectionConfig && collectionConfig.upload) {\n        if (reservedBaseUploadFieldNames.includes(field.name)) {\n          throw new ReservedFieldName(field, field.name)\n        }\n      }\n\n      if (\n        collectionConfig &&\n        collectionConfig.auth &&\n        typeof collectionConfig.auth === 'object' &&\n        !collectionConfig.auth.disableLocalStrategy\n      ) {\n        if (reservedBaseAuthFieldNames.includes(field.name)) {\n          throw new ReservedFieldName(field, field.name)\n        }\n\n        if (collectionConfig.auth.verify) {\n          // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n          if (reservedAPIKeyFieldNames.includes(field.name)) {\n            throw new ReservedFieldName(field, field.name)\n          }\n\n          // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n          if (reservedVerifyFieldNames.includes(field.name)) {\n            throw new ReservedFieldName(field, field.name)\n          }\n        }\n      }\n    }\n\n    // assert that field names do not contain forbidden characters\n    if (fieldAffectsData && field.name.includes('.')) {\n      throw new InvalidFieldName(field, field.name)\n    }\n\n    // Auto-label\n    if (\n      'name' in field &&\n      field.name &&\n      typeof field.label !== 'object' &&\n      typeof field.label !== 'string' &&\n      typeof field.label !== 'function' &&\n      field.label !== false\n    ) {\n      field.label = toWords(field.name)\n    }\n\n    if (\n      field.type === 'checkbox' &&\n      typeof field.defaultValue === 'undefined' &&\n      field.required === true\n    ) {\n      field.defaultValue = false\n    }\n\n    if (field.type === 'join') {\n      sanitizeJoinField({ config, field, joinPath, joins, parentIsLocalized, polymorphicJoins })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      // Validate that relationTo is not empty\n      if (Array.isArray(field.relationTo) && field.relationTo.length === 0) {\n        throw new Error(\n          `Field \"${field.name}\" of type \"${field.type}\" has an empty relationTo array. At least one collection must be specified.`,\n        )\n      }\n\n      if (validRelationships) {\n        const relationships = Array.isArray(field.relationTo)\n          ? field.relationTo\n          : [field.relationTo]\n\n        relationships.forEach((relationship: string) => {\n          if (!validRelationships.includes(relationship)) {\n            throw new InvalidFieldRelationship(field, relationship)\n          }\n        })\n      }\n\n      if (field.min && !field.minRows) {\n        console.warn(\n          `(payload): The \"min\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"minRows\" instead.`,\n        )\n        field.minRows = field.min\n      }\n\n      if (field.max && !field.maxRows) {\n        console.warn(\n          `(payload): The \"max\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"maxRows\" instead.`,\n        )\n        field.maxRows = field.max\n      }\n    }\n\n    if (field.type === 'upload') {\n      if (!field.admin || !('isSortable' in field.admin)) {\n        field.admin = {\n          isSortable: true,\n          ...field.admin,\n        }\n      }\n    }\n\n    if (field.type === 'array' && field.fields) {\n      const hasCustomID = field.fields.some((f) => 'name' in f && f.name === 'id')\n      if (!hasCustomID) {\n        field.fields.push(baseIDField)\n      }\n    }\n\n    if ((field.type === 'blocks' || field.type === 'array') && field.label) {\n      field.labels = field.labels || formatLabels(field.name)\n    }\n\n    if (fieldAffectsData) {\n      if (existingFieldNames.has(field.name)) {\n        throw new DuplicateFieldName(field.name)\n      } else if (!['blockName', 'id'].includes(field.name)) {\n        existingFieldNames.add(field.name)\n      }\n\n      if (typeof field.localized !== 'undefined') {\n        let shouldDisableLocalized = !config.localization\n\n        if (\n          process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized !== 'true' &&\n          parentIsLocalized &&\n          // @todo PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY=true will be the default in 4.0\n          process.env.PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY !== 'true'\n        ) {\n          shouldDisableLocalized = true\n        }\n\n        if (shouldDisableLocalized) {\n          delete field.localized\n        }\n      }\n\n      if (typeof field.validate === 'undefined') {\n        const defaultValidate = validations[field.type as keyof typeof validations]\n        if (defaultValidate) {\n          field.validate = (val: any, options: any) =>\n            defaultValidate(val, { ...field, ...options })\n        } else {\n          field.validate = (): true => true\n        }\n      }\n\n      if (!field.hooks) {\n        field.hooks = {}\n      }\n\n      if (!field.access) {\n        field.access = {}\n      }\n\n      setDefaultBeforeDuplicate(field, parentIsLocalized)\n    }\n\n    if (!field.admin) {\n      field.admin = {}\n    }\n\n    // Make sure that the richText field has an editor\n    if (field.type === 'richText') {\n      const sanitizeRichText = async (_config: SanitizedConfig) => {\n        if (!field.editor) {\n          if (_config.editor && !requireFieldLevelRichTextEditor) {\n            // config.editor should be sanitized at this point\n            field.editor = _config.editor\n          } else {\n            throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n          }\n        }\n\n        if (typeof field.editor === 'function') {\n          field.editor = await field.editor({\n            config: _config,\n            isRoot: requireFieldLevelRichTextEditor,\n            parentIsLocalized: (parentIsLocalized || field.localized)!,\n          })\n        }\n\n        if (field.editor.i18n && Object.keys(field.editor.i18n).length >= 0) {\n          config.i18n!.translations = deepMergeSimple(config.i18n!.translations!, field.editor.i18n)\n        }\n      }\n      if (richTextSanitizationPromises) {\n        richTextSanitizationPromises.push(sanitizeRichText)\n      } else {\n        await sanitizeRichText(config as unknown as SanitizedConfig)\n      }\n    }\n\n    if (field.type === 'blocks' && field.blocks) {\n      if (field.blockReferences && field.blocks?.length) {\n        throw new Error('You cannot have both blockReferences and blocks in the same blocks field')\n      }\n\n      const blockSlugs: string[] = []\n\n      for (const block of field.blockReferences ?? field.blocks) {\n        const blockSlug = typeof block === 'string' ? block : block.slug\n\n        if (blockSlugs.includes(blockSlug)) {\n          throw new DuplicateFieldName(blockSlug)\n        }\n\n        blockSlugs.push(blockSlug)\n\n        if (typeof block === 'string') {\n          continue\n        }\n\n        if (block._sanitized === true) {\n          continue\n        }\n\n        block._sanitized = true\n        block.fields = block.fields.concat(baseBlockFields)\n        block.labels = !block.labels ? formatLabels(block.slug) : block.labels\n        block.fields = await sanitizeFields({\n          collectionConfig,\n          config,\n          existingFieldNames: new Set(),\n          fields: block.fields,\n          isTopLevelField: false,\n          parentIsLocalized: (parentIsLocalized || field.localized)!,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n      }\n    }\n\n    if ('fields' in field && field.fields) {\n      field.fields = await sanitizeFields({\n        collectionConfig,\n        config,\n        existingFieldNames: fieldAffectsData ? new Set() : existingFieldNames,\n        fields: field.fields,\n        isTopLevelField: isTopLevelField && !fieldAffectsData,\n        joinPath: fieldAffectsData ? `${joinPath ? joinPath + '.' : ''}${field.name}` : joinPath,\n        joins,\n        parentIsLocalized: parentIsLocalized || fieldIsLocalized(field),\n        polymorphicJoins,\n        requireFieldLevelRichTextEditor,\n        richTextSanitizationPromises,\n        validRelationships,\n      })\n    }\n\n    if (field.type === 'tabs') {\n      for (let j = 0; j < field.tabs.length; j++) {\n        const tab = field.tabs[j]!\n\n        const isNamedTab = tabHasName(tab)\n\n        if (isNamedTab && typeof tab.label === 'undefined') {\n          tab.label = toWords(tab.name)\n        }\n\n        if (\n          'admin' in tab &&\n          tab.admin?.condition &&\n          typeof tab.admin.condition === 'function' &&\n          !tab.id\n        ) {\n          // Always attach a UUID to tabs with a condition so there's no conflicts even if there are duplicate nested names\n          tab.id = isNamedTab ? `${tab.name}_${uuid()}` : uuid()\n        }\n\n        tab.fields = await sanitizeFields({\n          collectionConfig,\n          config,\n          existingFieldNames: isNamedTab ? new Set() : existingFieldNames,\n          fields: tab.fields,\n          isTopLevelField: isTopLevelField && !isNamedTab,\n          joinPath: isNamedTab ? `${joinPath ? joinPath + '.' : ''}${tab.name}` : joinPath,\n          joins,\n          parentIsLocalized: parentIsLocalized || (isNamedTab && tab.localized)!,\n          polymorphicJoins,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n\n        field.tabs[j] = tab\n      }\n    }\n\n    if (field.type === 'ui' && typeof field.admin.disableBulkEdit === 'undefined') {\n      field.admin.disableBulkEdit = true\n    }\n\n    fields[i] = field\n\n    // Insert our field after assignment\n    if (field.type === 'date' && field.timezone) {\n      const name = field.name + '_tz'\n\n      let defaultTimezone =\n        field.timezone && typeof field.timezone === 'object'\n          ? field.timezone.defaultTimezone\n          : config.admin?.timezones?.defaultTimezone\n\n      const required =\n        field.required ||\n        (field.timezone && typeof field.timezone === 'object' && field.timezone.required)\n\n      const supportedTimezones =\n        field.timezone && typeof field.timezone === 'object' && field.timezone.supportedTimezones\n          ? field.timezone.supportedTimezones\n          : config.admin?.timezones?.supportedTimezones\n\n      const options =\n        typeof supportedTimezones === 'function'\n          ? supportedTimezones({ defaultTimezones })\n          : supportedTimezones\n\n      validateTimezones({\n        source: `field \"${field.name}\" timezone.supportedTimezones`,\n        timezones: options,\n      })\n\n      if (options && options.length === 1 && options[0]?.value) {\n        defaultTimezone = options[0].value\n      }\n\n      // Generate label for timezone field\n      // Use parent field's label + ' Tz' if it's a simple string, otherwise fallback to name\n      const timezoneLabel = typeof field.label === 'string' ? `${field.label} Tz` : toWords(name)\n\n      // Need to set the options here manually so that any database enums are generated correctly\n      // The UI component will import the options from the config\n      const baseField = baseTimezoneField({\n        name,\n        defaultValue: defaultTimezone,\n        label: timezoneLabel,\n        options,\n        required,\n      })\n\n      // Apply override if provided\n      const timezoneField =\n        typeof field.timezone === 'object' && typeof field.timezone.override === 'function'\n          ? field.timezone.override({ baseField })\n          : baseField\n\n      fields.splice(++i, 0, timezoneField)\n    }\n\n    if ('virtual' in field && typeof field.virtual === 'string') {\n      const virtualField = field\n      const fields = (collectionConfig || globalConfig)?.fields\n      if (fields) {\n        let flattenFields = flattenAllFields({ fields })\n        const paths = field.virtual.split('.')\n        let isHasMany = false\n\n        for (const [i, segment] of paths.entries()) {\n          const field = flattenFields.find((e) => e.name === segment)\n          if (!field) {\n            break\n          }\n\n          if (field.type === 'group' || field.type === 'tab' || field.type === 'array') {\n            flattenFields = field.flattenedFields\n          } else if (\n            (field.type === 'relationship' || field.type === 'upload') &&\n            i !== paths.length - 1 &&\n            typeof field.relationTo === 'string'\n          ) {\n            if (\n              field.hasMany &&\n              (virtualField.type === 'text' ||\n                virtualField.type === 'number' ||\n                virtualField.type === 'select')\n            ) {\n              if (isHasMany) {\n                throw new InvalidConfiguration(\n                  `Virtual field ${virtualField.name} in ${globalConfig ? `global ${globalConfig.slug}` : `collection ${collectionConfig?.slug}`} references 2 or more hasMany relationships on the path ${virtualField.virtual} which is not allowed.`,\n                )\n              }\n\n              isHasMany = true\n              virtualField.hasMany = true\n            }\n            const relatedCollection = config.collections?.find((e) => e.slug === field.relationTo)\n            if (relatedCollection) {\n              flattenFields = flattenAllFields({ fields: relatedCollection.fields })\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return fields\n}\n"],"names":["deepMergeSimple","v4","uuid","DuplicateFieldName","InvalidConfiguration","InvalidFieldName","InvalidFieldRelationship","MissingEditorProp","MissingFieldType","ReservedFieldName","flattenAllFields","formatLabels","toWords","validateTimezones","baseBlockFields","baseIDField","baseTimezoneField","defaultTimezones","setDefaultBeforeDuplicate","validations","reservedAPIKeyFieldNames","reservedBaseAuthFieldNames","reservedBaseUploadFieldNames","reservedVerifyFieldNames","sanitizeJoinField","fieldAffectsData","_fieldAffectsData","fieldIsLocalized","tabHasName","sanitizeFields","collectionConfig","config","existingFieldNames","Set","fields","globalConfig","isTopLevelField","joinPath","joins","parentIsLocalized","polymorphicJoins","requireFieldLevelRichTextEditor","richTextSanitizationPromises","validRelationships","i","length","field","_sanitized","type","name","upload","includes","auth","disableLocalStrategy","verify","label","defaultValue","required","Array","isArray","relationTo","Error","relationships","forEach","relationship","min","minRows","console","warn","max","maxRows","admin","isSortable","hasCustomID","some","f","push","labels","has","add","localized","shouldDisableLocalized","localization","process","env","NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized","PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY","validate","defaultValidate","val","options","hooks","access","sanitizeRichText","_config","editor","isRoot","i18n","Object","keys","translations","blocks","blockReferences","blockSlugs","block","blockSlug","slug","concat","j","tabs","tab","isNamedTab","condition","id","disableBulkEdit","timezone","defaultTimezone","timezones","supportedTimezones","source","value","timezoneLabel","baseField","timezoneField","override","splice","virtual","virtualField","flattenFields","paths","split","isHasMany","segment","entries","find","e","flattenedFields","hasMany","relatedCollection","collections"],"mappings":"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"}