{"version":3,"sources":["../../../src/fields/config/types.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { EditorProps } from '@monaco-editor/react'\nimport type { JSONSchema4 } from 'json-schema'\nimport type { CSSProperties } from 'react'\nimport type React from 'react'\nimport type { DeepUndefinable, MarkRequired } from 'ts-essentials'\n\nimport type {\n  JoinFieldClientProps,\n  JoinFieldErrorClientComponent,\n  JoinFieldErrorServerComponent,\n  JoinFieldLabelClientComponent,\n  JoinFieldLabelServerComponent,\n} from '../../admin/fields/Join.js'\nimport type { FieldClientComponent, FieldServerComponent } from '../../admin/forms/Field.js'\nimport type { RichTextAdapter, RichTextAdapterProvider } from '../../admin/RichText.js'\nimport type {\n  ArrayFieldClientProps,\n  ArrayFieldErrorClientComponent,\n  ArrayFieldErrorServerComponent,\n  ArrayFieldLabelClientComponent,\n  ArrayFieldLabelServerComponent,\n  BlocksFieldClientProps,\n  BlocksFieldErrorClientComponent,\n  BlocksFieldErrorServerComponent,\n  BlocksFieldLabelClientComponent,\n  BlocksFieldLabelServerComponent,\n  CheckboxFieldClientProps,\n  CheckboxFieldErrorClientComponent,\n  CheckboxFieldErrorServerComponent,\n  CheckboxFieldLabelClientComponent,\n  CheckboxFieldLabelServerComponent,\n  ClientTab,\n  CodeFieldClientProps,\n  CodeFieldErrorClientComponent,\n  CodeFieldErrorServerComponent,\n  CodeFieldLabelClientComponent,\n  CodeFieldLabelServerComponent,\n  CollapsibleFieldClientProps,\n  CollapsibleFieldLabelClientComponent,\n  CollapsibleFieldLabelServerComponent,\n  ConditionalDateProps,\n  Data,\n  DateFieldClientProps,\n  DateFieldErrorClientComponent,\n  DateFieldErrorServerComponent,\n  DateFieldLabelClientComponent,\n  DateFieldLabelServerComponent,\n  DefaultCellComponentProps,\n  DefaultServerCellComponentProps,\n  Description,\n  EmailFieldClientProps,\n  EmailFieldErrorClientComponent,\n  EmailFieldErrorServerComponent,\n  EmailFieldLabelClientComponent,\n  EmailFieldLabelServerComponent,\n  FieldDescriptionClientProps,\n  FieldDescriptionServerProps,\n  FieldDiffClientProps,\n  FieldDiffServerProps,\n  GroupFieldClientProps,\n  GroupFieldLabelClientComponent,\n  GroupFieldLabelServerComponent,\n  HiddenFieldProps,\n  JSONFieldClientProps,\n  JSONFieldErrorClientComponent,\n  JSONFieldErrorServerComponent,\n  JSONFieldLabelClientComponent,\n  JSONFieldLabelServerComponent,\n  NumberFieldClientProps,\n  NumberFieldErrorClientComponent,\n  NumberFieldErrorServerComponent,\n  NumberFieldLabelClientComponent,\n  NumberFieldLabelServerComponent,\n  PointFieldClientProps,\n  PointFieldErrorClientComponent,\n  PointFieldErrorServerComponent,\n  PointFieldLabelClientComponent,\n  PointFieldLabelServerComponent,\n  RadioFieldClientProps,\n  RadioFieldErrorClientComponent,\n  RadioFieldErrorServerComponent,\n  RadioFieldLabelClientComponent,\n  RadioFieldLabelServerComponent,\n  RelationshipFieldClientProps,\n  RelationshipFieldErrorClientComponent,\n  RelationshipFieldErrorServerComponent,\n  RelationshipFieldLabelClientComponent,\n  RelationshipFieldLabelServerComponent,\n  RichTextFieldClientProps,\n  RowFieldClientProps,\n  RowLabelComponent,\n  SelectFieldClientProps,\n  SelectFieldErrorClientComponent,\n  SelectFieldErrorServerComponent,\n  SelectFieldLabelClientComponent,\n  SelectFieldLabelServerComponent,\n  StaticDescription,\n  TabsFieldClientProps,\n  TextareaFieldClientProps,\n  TextareaFieldErrorClientComponent,\n  TextareaFieldErrorServerComponent,\n  TextareaFieldLabelClientComponent,\n  TextareaFieldLabelServerComponent,\n  TextFieldClientProps,\n  TextFieldErrorClientComponent,\n  TextFieldErrorServerComponent,\n  TextFieldLabelClientComponent,\n  TextFieldLabelServerComponent,\n  UploadFieldClientProps,\n} from '../../admin/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type {\n  CustomComponent,\n  LabelFunction,\n  PayloadComponent,\n  StaticLabel,\n  Timezone,\n  TimezonesConfig,\n} from '../../config/types.js'\nimport type { DBIdentifierName } from '../../database/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type {\n  ArrayFieldValidation,\n  BlocksFieldValidation,\n  BlockSlug,\n  CheckboxFieldValidation,\n  CodeFieldValidation,\n  CollectionSlug,\n  DateFieldValidation,\n  EmailFieldValidation,\n  FieldCustom,\n  JSONFieldValidation,\n  PointFieldValidation,\n  RadioFieldValidation,\n  RequestContext,\n  Sort,\n  TextareaFieldValidation,\n} from '../../index.js'\nimport type { DocumentPreferences } from '../../preferences/types.js'\nimport type {\n  DefaultValue,\n  JsonObject,\n  Operation,\n  PayloadRequest,\n  PickPreserveOptional,\n  Where,\n} from '../../types/index.js'\nimport type {\n  NumberFieldManyValidation,\n  NumberFieldSingleValidation,\n  RelationshipFieldManyValidation,\n  RelationshipFieldSingleValidation,\n  RichTextFieldValidation,\n  SelectFieldManyValidation,\n  SelectFieldSingleValidation,\n  TextFieldManyValidation,\n  TextFieldSingleValidation,\n  UploadFieldManyValidation,\n  UploadFieldSingleValidation,\n} from '../validations.js'\n\nexport type FieldHookArgs<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = {\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData: JsonObject | undefined\n  /** The collection which the field belongs to. If the field belongs to a global, this will be null. */\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * Only available in `afterRead` hooks\n   */\n  currentDepth?: number\n  /**\n   * Only available in `afterRead` hooks\n   */\n  /** The data passed to update the document within create and update operations, and the full document itself in the afterRead hook. */\n  data?: Partial<TData>\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  depth?: number\n  draft?: boolean\n  /** The field which the hook is running against. */\n  field: FieldAffectingData\n  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */\n  findMany?: boolean\n  /** The global which the field belongs to. If the field belongs to a collection, this will be null. */\n  global: null | SanitizedGlobalConfig\n  indexPath: number[]\n  /** A string relating to which operation the field type is currently executing within. Useful within beforeValidate, beforeChange, and afterChange hooks to differentiate between create and update operations. */\n  operation?: 'create' | 'delete' | 'read' | 'update'\n  /** The full original document in `update` operations. In the `afterChange` hook, this is the resulting document of the operation. */\n  originalDoc?: TData\n  overrideAccess?: boolean\n  /**\n   * The path of the field, e.g. [\"group\", \"myArray\", 1, \"textField\"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.\n   */\n  path: (number | string)[]\n  /** The document before changes were applied, only in `afterChange` hooks. */\n  previousDoc?: TData\n  /** The sibling data of the document before changes being applied, only in `beforeChange`, `beforeValidate`, `beforeDuplicate` and `afterChange` field hooks. */\n  previousSiblingDoc?: TSiblingData\n  /** The previous value of the field, before changes, only in `beforeChange`, `afterChange`, `beforeDuplicate` and `beforeValidate` field hooks. */\n  previousValue?: TValue\n  /** The Express request object. It is mocked for Local API operations. */\n  req: PayloadRequest\n  /**\n   * The schemaPath of the field, e.g. [\"group\", \"myArray\", \"textField\"]. The schemaPath is the path but without indexes and would be used in the context of field schemas, not field data.\n   */\n  schemaPath: string[]\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  showHiddenFields?: boolean\n  /** The sibling data passed to a field that the hook is running against. */\n  siblingData: Partial<TSiblingData>\n  /**\n   * The original siblingData with locales (not modified by any hooks). Only available in `beforeChange` and `beforeDuplicate` field hooks.\n   */\n  siblingDocWithLocales?: Record<string, unknown>\n  /**\n   * The sibling fields of the field which the hook is running against.\n   */\n  siblingFields: (Field | TabAsField)[]\n  /** The value of the field. */\n  value?: TValue\n}\n\nexport type FieldHook<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = (\n  args: FieldHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type FieldAccessArgs<TData extends TypeWithID = any, TSiblingData = any> = {\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData?: JsonObject | undefined\n  /**\n   * The incoming, top-level document data used to `create` or `update` the document with.\n   */\n  data?: Partial<TData>\n  /**\n   * The original data of the document before the `update` is applied. `doc` is undefined during the `create` operation.\n   */\n  doc?: TData\n  /**\n   * The `id` of the current document being read or updated. `id` is undefined during the `create` operation.\n   */\n  id?: number | string\n  /** The `payload` object to interface with the payload API */\n  req: PayloadRequest\n  /**\n   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.\n   */\n  siblingData?: Partial<TSiblingData>\n}\n\nexport type FieldAccess<TData extends TypeWithID = any, TSiblingData = any> = (\n  args: FieldAccessArgs<TData, TSiblingData>,\n) => boolean | Promise<boolean>\n\n//TODO: In 4.0, we should replace the three parameters of the condition function with a single, named parameter object\nexport type Condition<TData extends TypeWithID = any, TSiblingData = any> = (\n  /**\n   * The top-level document data\n   */\n  data: Partial<TData>,\n  /**\n   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.\n   */\n  siblingData: Partial<TSiblingData>,\n  {\n    blockData,\n    operation,\n    path,\n    user,\n  }: {\n    /**\n     * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n     */\n    blockData: Partial<TData>\n    /**\n     * A string relating to which operation the field type is currently executing within.\n     */\n    operation: Operation\n    /**\n     * The path of the field, e.g. [\"group\", \"myArray\", 1, \"textField\"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.\n     */\n    path: (number | string)[]\n    user: PayloadRequest['user']\n  },\n) => boolean\n\nexport type FilterOptionsProps<TData = any> = {\n  /**\n   * The data of the nearest parent block. Will be `undefined` if the field is not within a block or when called on a `Filter` component within the list view.\n   */\n  blockData: TData\n  /**\n   * An object containing the full collection or global document currently being edited. Will be an empty object when called on a `Filter` component within the list view.\n   */\n  data: TData\n  /**\n   * The `id` of the current document being edited. Will be undefined during the `create` operation or when called on a `Filter` component within the list view.\n   */\n  id: number | string\n  /**\n   * The collection `slug` to filter against, limited to this field's `relationTo` property.\n   */\n  relationTo: CollectionSlug\n  req: PayloadRequest\n  /**\n   * An object containing document data that is scoped to only fields within the same parent of this field. Will be an empty object when called on a `Filter` component within the list view.\n   */\n  siblingData: unknown\n  /**\n   * An object containing the currently authenticated user.\n   */\n  user: Partial<PayloadRequest['user']>\n}\n\nexport type FilterOptionsFunc<TData = any> = (\n  options: FilterOptionsProps<TData>,\n) => boolean | Promise<boolean | Where> | Where\n\nexport type FilterOptions<TData = any> = FilterOptionsFunc<TData> | null | Where\n\ntype BlockSlugOrString = (({} & string) | BlockSlug)[]\n\nexport type BlocksFilterOptionsProps<TData = any> = {\n  /**\n   * The `id` of the current document being edited. Will be undefined during the `create` operation.\n   */\n  id: number | string\n} & Pick<FilterOptionsProps<TData>, 'data' | 'req' | 'siblingData' | 'user'>\n\nexport type BlocksFilterOptions<TData = any> =\n  | ((\n      options: BlocksFilterOptionsProps<TData>,\n    ) => BlockSlugOrString | Promise<BlockSlugOrString | true> | true)\n  | BlockSlugOrString\n\nexport type FieldAdmin = {\n  className?: string\n  components?: {\n    Cell?: PayloadComponent<DefaultServerCellComponentProps, DefaultCellComponentProps>\n    Description?: PayloadComponent<FieldDescriptionServerProps, FieldDescriptionClientProps>\n    Diff?: PayloadComponent<FieldDiffServerProps, FieldDiffClientProps>\n    Field?: PayloadComponent<FieldClientComponent | FieldServerComponent>\n    /**\n     * The Filter component has to be a client component\n     */\n    Filter?: PayloadComponent\n  }\n  /**\n   * You can programmatically show / hide fields based on what other fields are doing.\n   * This is also run on the server, to determine if the field should be validated.\n   */\n  condition?: Condition\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  /**\n   * The field description will be displayed next to the field in the admin UI. Additionally,\n   * we use the field description to generate JSDoc comments for the generated TypeScript types.\n   */\n  description?: Description\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view groupBy options.\n   * @type boolean\n   */\n  disableGroupBy?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type AdminClient = {\n  className?: string\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  description?: StaticDescription\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view groupBy options.\n   * @type boolean\n   */\n  disableGroupBy?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: { '--field-width'?: CSSProperties['width'] } & CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type Labels = {\n  plural: LabelFunction | StaticLabel\n  singular: LabelFunction | StaticLabel\n}\n\nexport type LabelsClient = {\n  plural: StaticLabel\n  singular: StaticLabel\n}\n\nexport type BaseValidateOptions<TData, TSiblingData, TValue> = {\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData: Partial<TData>\n  collectionSlug?: string\n  data: Partial<TData>\n  event?: 'onChange' | 'submit'\n  id?: number | string\n  operation?: Operation\n  /**\n   * The `overrideAccess` flag that was attached to the request. This is used to bypass access control checks for fields.\n   */\n  overrideAccess?: boolean\n  /**\n   * The path of the field, e.g. [\"group\", \"myArray\", 1, \"textField\"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.\n   */\n  path: (number | string)[]\n  preferences: DocumentPreferences\n  previousValue?: TValue\n  req: PayloadRequest\n  required?: boolean\n  siblingData: Partial<TSiblingData>\n}\n\nexport type ValidateOptions<\n  TData,\n  TSiblingData,\n  TFieldConfig extends object,\n  TValue,\n> = BaseValidateOptions<TData, TSiblingData, TValue> & TFieldConfig\n\nexport type Validate<\n  TValue = any,\n  TData = any,\n  TSiblingData = any,\n  TFieldConfig extends object = object,\n> = (\n  value: null | TValue | undefined,\n  options: ValidateOptions<TData, TSiblingData, TFieldConfig, TValue>,\n) => Promise<string | true> | string | true\n\nexport type OptionLabel =\n  | (() => React.JSX.Element)\n  | LabelFunction\n  | React.JSX.Element\n  | StaticLabel\n\nexport type OptionObject = {\n  label: OptionLabel\n  value: string\n}\n\nexport type Option = OptionObject | string\n\nexport type FieldGraphQLType = {\n  graphQL?: {\n    /**\n     * Complexity for the query. This is used to limit the complexity of the join query.\n     *\n     * @default 10\n     */\n    complexity?: number\n  }\n}\n\nexport interface FieldBase {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same field multiple times.\n   */\n  _sanitized?: boolean\n  access?: {\n    create?: FieldAccess\n    read?: FieldAccess\n    update?: FieldAccess\n  }\n  admin?: FieldAdmin\n  /** Extension point to add your custom data. Server only. */\n  custom?: FieldCustom\n  defaultValue?: DefaultValue\n  hidden?: boolean\n  hooks?: {\n    afterChange?: FieldHook[]\n    afterRead?: FieldHook[]\n    beforeChange?: FieldHook[]\n    /**\n     * Runs before a document is duplicated to prevent errors in unique fields or return null to use defaultValue.\n     */\n    beforeDuplicate?: FieldHook[]\n    beforeValidate?: FieldHook[]\n  }\n  index?: boolean\n  label?: false | LabelFunction | StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n  validate?: Validate\n  /**\n   * Pass `true` to disable field in the DB\n   * for [Virtual Fields](https://payloadcms.com/blog/learn-how-virtual-fields-can-help-solve-common-cms-challenges):\n   * A virtual field can be used in `admin.useAsTitle` only when linked to a relationship.\n   */\n  virtual?: boolean | string\n}\n\nexport interface FieldBaseClient {\n  admin?: AdminClient\n  hidden?: boolean\n  index?: boolean\n  label?: StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n}\n\nexport type NumberField = {\n  admin?: {\n    /** Set this property to a string that will be used for browser autocomplete. */\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<NumberFieldErrorClientComponent | NumberFieldErrorServerComponent>\n      Label?: CustomComponent<NumberFieldLabelClientComponent | NumberFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    /** Set this property to define a placeholder string for the field. */\n    placeholder?: Record<string, string> | string\n    /** Set a value for the number field to increment / decrement using browser controls. */\n    step?: number\n  } & FieldAdmin\n  /** Maximum value accepted. Used in the default `validate` function. */\n  max?: number\n  /** Minimum value accepted. Used in the default `validate` function. */\n  min?: number\n  type: 'number'\n} & (\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany: true\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: NumberFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany?: false | undefined\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: NumberFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type NumberFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: AdminClient & Pick<NumberField['admin'], 'autoComplete' | 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<NumberField, 'hasMany' | 'max' | 'maxRows' | 'min' | 'minRows' | 'type'>\n\nexport type TextField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextFieldErrorClientComponent | TextFieldErrorServerComponent>\n      Label?: CustomComponent<TextFieldLabelClientComponent | TextFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    placeholder?: Record<string, string> | string\n    rtl?: boolean\n  } & FieldAdmin\n  maxLength?: number\n  minLength?: number\n  type: 'text'\n} & (\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany: true\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: TextFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany?: false | undefined\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: TextFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type TextFieldClient = {\n  admin?: AdminClient &\n    PickPreserveOptional<NonNullable<TextField['admin']>, 'autoComplete' | 'placeholder' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextField, 'hasMany' | 'maxLength' | 'maxRows' | 'minLength' | 'minRows' | 'type'>\n\nexport type EmailField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<EmailFieldErrorClientComponent | EmailFieldErrorServerComponent>\n      Label?: CustomComponent<EmailFieldLabelClientComponent | EmailFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    placeholder?: Record<string, string> | string\n  } & FieldAdmin\n  type: 'email'\n  validate?: EmailFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type EmailFieldClient = {\n  admin?: AdminClient &\n    PickPreserveOptional<NonNullable<EmailField['admin']>, 'autoComplete' | 'placeholder'>\n} & FieldBaseClient &\n  Pick<EmailField, 'type'>\n\nexport type TextareaField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextareaFieldErrorClientComponent | TextareaFieldErrorServerComponent>\n      Label?: CustomComponent<TextareaFieldLabelClientComponent | TextareaFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    placeholder?: Record<string, string> | string\n    rows?: number\n    rtl?: boolean\n  } & FieldAdmin\n  maxLength?: number\n  minLength?: number\n  type: 'textarea'\n  validate?: TextareaFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type TextareaFieldClient = {\n  admin?: AdminClient &\n    PickPreserveOptional<NonNullable<TextareaField['admin']>, 'placeholder' | 'rows' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextareaField, 'maxLength' | 'minLength' | 'type'>\n\nexport type CheckboxField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CheckboxFieldErrorClientComponent | CheckboxFieldErrorServerComponent>\n      Label?: CustomComponent<CheckboxFieldLabelClientComponent | CheckboxFieldLabelServerComponent>\n    } & FieldAdmin['components']\n  } & FieldAdmin\n  type: 'checkbox'\n  validate?: CheckboxFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type CheckboxFieldClient = {\n  admin?: AdminClient\n} & FieldBaseClient &\n  Pick<CheckboxField, 'type'>\n\ntype DateFieldTimezoneConfigBase = {\n  /**\n   * Make only the timezone required in the admin interface. This means a timezone is always required to be selected.\n   */\n  required?: boolean\n  supportedTimezones?: Timezone[]\n} & Pick<TimezonesConfig, 'defaultTimezone'>\n\ntype DateFieldTimezoneConfig = {\n  /**\n   * A function used to override the timezone field at a granular level.\n   * Passes the base select field to you to manipulate beyond the exposed options.\n   * @example\n   * ```ts\n   * {\n   *   type: 'date',\n   *   name: 'publishedAt',\n   *   timezone: {\n   *     override: ({ baseField }) => ({\n   *       ...baseField,\n   *       admin: {\n   *         ...baseField.admin,\n   *         hidden: false,\n   *       },\n   *     }),\n   *   },\n   * }\n   * ```\n   */\n  override?: (args: { baseField: SelectField }) => Field\n} & DateFieldTimezoneConfigBase\n\ntype DateFieldTimezoneConfigClient = DateFieldTimezoneConfigBase\n\nexport type DateField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<DateFieldErrorClientComponent | DateFieldErrorServerComponent>\n      Label?: CustomComponent<DateFieldLabelClientComponent | DateFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    date?: ConditionalDateProps\n    placeholder?: Record<string, string> | string\n  } & FieldAdmin\n  /**\n   * Enable timezone selection in the admin interface.\n   */\n  timezone?: DateFieldTimezoneConfig | true\n  type: 'date'\n  validate?: DateFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type DateFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: AdminClient & Pick<DateField['admin'], 'date' | 'placeholder'>\n  /**\n   * Enable timezone selection in the admin interface.\n   * Note: The `override` function is stripped on the client.\n   */\n  timezone?: DateFieldTimezoneConfigClient | true\n} & FieldBaseClient &\n  Pick<DateField, 'type'>\n\nexport type GroupBase = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Label?: CustomComponent<GroupFieldLabelClientComponent | GroupFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    hideGutter?: boolean\n  } & FieldAdmin\n  fields: Field[]\n  type: 'group'\n  validate?: Validate<unknown, unknown, unknown, GroupField>\n} & Omit<FieldBase, 'validate'>\n\nexport type NamedGroupField = {\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n} & GroupBase\n\nexport type UnnamedGroupField = {\n  interfaceName?: never\n  localized?: never\n} & Omit<GroupBase, 'hooks' | 'name' | 'virtual'>\n\nexport type GroupField = NamedGroupField | UnnamedGroupField\n\nexport type UnnamedGroupFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: AdminClient & Pick<UnnamedGroupField['admin'], 'hideGutter'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'name' | 'required'> &\n  Pick<UnnamedGroupField, 'label' | 'type'>\n\nexport type NamedGroupFieldClient = Pick<NamedGroupField, 'name'> & UnnamedGroupFieldClient\n\nexport type GroupFieldClient = NamedGroupFieldClient | UnnamedGroupFieldClient\n\nexport type RowField = {\n  admin?: Omit<FieldAdmin, 'description'>\n  fields: Field[]\n  type: 'row'\n} & Omit<FieldBase, 'admin' | 'hooks' | 'label' | 'localized' | 'name' | 'validate' | 'virtual'>\n\nexport type RowFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'admin' | 'label' | 'name'> &\n  Pick<RowField, 'type'>\n\nexport type CollapsibleField = {\n  fields: Field[]\n  type: 'collapsible'\n} & (\n  | {\n      admin: {\n        components: {\n          afterInput?: CustomComponent[]\n          beforeInput?: CustomComponent[]\n          Label: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n        } & FieldAdmin['components']\n        initCollapsed?: boolean\n      } & FieldAdmin\n      label?: Required<FieldBase['label']>\n    }\n  | {\n      admin?: {\n        components?: {\n          afterInput?: CustomComponent[]\n          beforeInput?: CustomComponent[]\n          Label?: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n        } & FieldAdmin['components']\n        initCollapsed?: boolean\n      } & FieldAdmin\n      label: Required<FieldBase['label']>\n    }\n) &\n  Omit<FieldBase, 'hooks' | 'label' | 'localized' | 'name' | 'validate' | 'virtual'>\n\nexport type CollapsibleFieldClient = {\n  admin?: {\n    initCollapsed?: boolean\n  } & AdminClient\n  fields: ClientField[]\n  label: StaticLabel\n} & Omit<FieldBaseClient, 'label' | 'name' | 'validate'> &\n  Pick<CollapsibleField, 'type'>\n\ntype TabBase = {\n  /**\n   * @deprecated\n   * Use `admin.description` instead. This will be removed in a future major version.\n   */\n  description?: LabelFunction | StaticDescription\n  fields: Field[]\n  id?: string\n  interfaceName?: string\n  saveToJWT?: boolean | string\n} & Omit<FieldBase, 'required' | 'validate'>\n\nexport type NamedTab = {\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n} & TabBase\n\nexport type UnnamedTab = {\n  interfaceName?: never\n  /**\n   * Can be either:\n   * - A string, which will be used as the tab's label.\n   * - An object, where the key is the language code and the value is the label.\n   */\n  label:\n    | {\n        [selectedLanguage: string]: string\n      }\n    | LabelFunction\n    | string\n  localized?: never\n} & Omit<TabBase, 'hooks' | 'name' | 'virtual'>\n\nexport type Tab = NamedTab | UnnamedTab\nexport type TabsField = {\n  admin?: Omit<FieldAdmin, 'description'>\n  type: 'tabs'\n} & {\n  tabs: Tab[]\n} & Omit<FieldBase, 'admin' | 'localized' | 'name' | 'saveToJWT' | 'virtual'>\n\nexport type TabsFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  tabs: ClientTab[]\n} & Omit<FieldBaseClient, 'admin' | 'localized' | 'name' | 'saveToJWT'> &\n  Pick<TabsField, 'type'>\n\nexport type TabAsField = {\n  name?: string\n  type: 'tab'\n} & Tab\n\nexport type TabAsFieldClient = ClientTab & Pick<TabAsField, 'name' | 'type'>\n\nexport type UIField = {\n  admin: {\n    components?: {\n      /**\n       * Allow any custom components to be added to the UI field. This allows\n       * the UI field to be used as a vessel for getting components rendered.\n       */\n      [key: string]: PayloadComponent | undefined\n      Cell?: CustomComponent\n      // Can be optional, in case the UI field is just used as a vessel for custom components\n      Field?: CustomComponent\n      /**\n       * The Filter component has to be a client component\n       */\n      Filter?: PayloadComponent\n    } & FieldAdmin['components']\n    condition?: Condition\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    /**\n     * Set `false` make the UI field appear in the list view column selector. `true` by default for UI fields.\n     * @default true\n     */\n    disableBulkEdit?: boolean\n    /**\n     * Shows / hides fields from appearing in the list view column selector.\n     * @type boolean\n     */\n    disableListColumn?: boolean\n    position?: string\n    width?: CSSProperties['width']\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  label?: Record<string, string> | string\n  name: string\n  type: 'ui'\n}\n\nexport type UIFieldClient = {\n  // still include FieldBaseClient.admin (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n\n  admin: DeepUndefinable<FieldBaseClient['admin']> &\n    Pick<\n      UIField['admin'],\n      'custom' | 'disableBulkEdit' | 'disableListColumn' | 'position' | 'width'\n    >\n} & Omit<DeepUndefinable<FieldBaseClient>, 'admin'> & // still include FieldBaseClient (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n  Pick<UIField, 'label' | 'name' | 'type'>\n\ntype SharedUploadProperties = {\n  /**\n   * Toggle the preview in the admin interface.\n   */\n  displayPreview?: boolean\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'upload'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: UploadFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: UploadFieldSingleValidation\n    }\n) &\n  FieldGraphQLType &\n  Omit<FieldBase, 'validate'>\n\ntype SharedUploadPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedUploadProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype UploadAdmin = {\n  allowCreate?: boolean\n  components?: {\n    afterInput?: CustomComponent[]\n    beforeInput?: CustomComponent[]\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & FieldAdmin['components']\n  isSortable?: boolean\n} & FieldAdmin\n\ntype UploadAdminClient = AdminClient & Pick<UploadAdmin, 'allowCreate' | 'isSortable'>\n\nexport type PolymorphicUploadField = {\n  admin?: {\n    sortOptions?: Partial<Record<CollectionSlug, string>>\n  } & UploadAdmin\n  /**\n   * @todo v4: make relationTo: [] fail type checking\n   */\n  relationTo: CollectionSlug[]\n} & SharedUploadProperties\n\nexport type PolymorphicUploadFieldClient = {\n  admin?: {\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    sortOptions?: Pick<PolymorphicUploadField['admin'], 'sortOptions'>\n  } & UploadAdminClient\n} & Pick<PolymorphicUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type SingleUploadField = {\n  admin?: {\n    sortOptions?: string\n  } & UploadAdmin\n  relationTo: CollectionSlug\n} & SharedUploadProperties\n\nexport type SingleUploadFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: Pick<SingleUploadField['admin'], 'sortOptions'> & UploadAdminClient\n} & Pick<SingleUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type UploadField = PolymorphicUploadField | SingleUploadField\n\nexport type UploadFieldClient = PolymorphicUploadFieldClient | SingleUploadFieldClient\n\nexport type CodeField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CodeFieldErrorClientComponent | CodeFieldErrorServerComponent>\n      Label?: CustomComponent<CodeFieldLabelClientComponent | CodeFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    editorOptions?: EditorProps['options']\n    editorProps?: Partial<EditorProps>\n    language?: string\n  } & FieldAdmin\n  maxLength?: number\n  minLength?: number\n  type: 'code'\n  validate?: CodeFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type CodeFieldClient = {\n  admin?: AdminClient &\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    Partial<Pick<CodeField['admin'], 'editorOptions' | 'editorProps' | 'language'>>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<CodeField, 'maxLength' | 'minLength' | 'type'>\n\nexport type JSONField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<JSONFieldErrorClientComponent | JSONFieldErrorServerComponent>\n      Label?: CustomComponent<JSONFieldLabelClientComponent | JSONFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    editorOptions?: EditorProps['options']\n    maxHeight?: number\n  } & FieldAdmin\n\n  jsonSchema?: {\n    fileMatch: string[]\n    schema: JSONSchema4\n    uri: string\n  }\n  type: 'json'\n  validate?: JSONFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type JSONFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: AdminClient & Pick<JSONField['admin'], 'editorOptions' | 'maxHeight'>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<JSONField, 'jsonSchema' | 'type'>\n\nexport type SelectField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<SelectFieldErrorClientComponent | SelectFieldErrorServerComponent>\n      Label?: CustomComponent<SelectFieldLabelClientComponent | SelectFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    isClearable?: boolean\n    isSortable?: boolean\n    placeholder?: LabelFunction | string\n  } & FieldAdmin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  /**\n   * Reduce the available options based on the current user, value of another field, etc.\n   * Similar to the `filterOptions` property on `relationship` and `upload` fields, except with a different return type.\n   */\n  filterOptions?: (args: {\n    data: Data\n    options: Option[]\n    req: PayloadRequest\n    siblingData: Data\n  }) => Option[]\n  hasMany?: boolean\n  /**\n   * Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  options: Option[]\n  type: 'select'\n} & (\n  | {\n      hasMany: true\n      validate?: SelectFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      validate?: SelectFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type SelectFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: AdminClient & Pick<SelectField['admin'], 'isClearable' | 'isSortable' | 'placeholder'>\n} & FieldBaseClient &\n  Pick<SelectField, 'hasMany' | 'interfaceName' | 'options' | 'type'>\n\ntype SharedRelationshipProperties = {\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'relationship'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: RelationshipFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: RelationshipFieldSingleValidation\n    }\n) &\n  FieldGraphQLType &\n  Omit<FieldBase, 'validate'>\n\ntype SharedRelationshipPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedRelationshipProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype RelationshipAdmin = {\n  allowCreate?: boolean\n  allowEdit?: boolean\n  appearance?: 'drawer' | 'select'\n  components?: {\n    afterInput?: CustomComponent[]\n    beforeInput?: CustomComponent[]\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & FieldAdmin['components']\n  isSortable?: boolean\n  placeholder?: LabelFunction | string\n} & FieldAdmin\n\ntype RelationshipAdminClient = AdminClient &\n  Pick<RelationshipAdmin, 'allowCreate' | 'allowEdit' | 'appearance' | 'isSortable' | 'placeholder'>\n\nexport type PolymorphicRelationshipField = {\n  admin?: {\n    sortOptions?: Partial<Record<CollectionSlug, string>>\n  } & RelationshipAdmin\n  /**\n   * @todo v4: make relationTo: [] fail type checking\n   */\n  relationTo: CollectionSlug[]\n} & SharedRelationshipProperties\n\nexport type PolymorphicRelationshipFieldClient = {\n  admin?: {\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    sortOptions?: PolymorphicRelationshipField['admin']['sortOptions']\n  } & RelationshipAdminClient\n} & Pick<PolymorphicRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type SingleRelationshipField = {\n  admin?: {\n    sortOptions?: string\n  } & RelationshipAdmin\n  relationTo: CollectionSlug\n} & SharedRelationshipProperties\n\nexport type SingleRelationshipFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: Partial<Pick<SingleRelationshipField['admin'], 'sortOptions'>> & RelationshipAdminClient\n} & Pick<SingleRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type RelationshipField = PolymorphicRelationshipField | SingleRelationshipField\n\nexport type RelationshipFieldClient =\n  | PolymorphicRelationshipFieldClient\n  | SingleRelationshipFieldClient\n\nexport type ValueWithRelation = {\n  relationTo: CollectionSlug\n  value: number | string\n}\n\nexport function valueIsValueWithRelation(value: unknown): value is ValueWithRelation {\n  return value !== null && typeof value === 'object' && 'relationTo' in value && 'value' in value\n}\n\nexport type RelationshipValue = RelationshipValueMany | RelationshipValueSingle\n\nexport type RelationshipValueMany = (number | string)[] | ValueWithRelation[]\n\nexport type RelationshipValueSingle = number | string | ValueWithRelation\n\nexport type RichTextField<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent\n      Label?: CustomComponent\n    } & FieldAdmin['components']\n  } & FieldAdmin\n  editor?:\n    | RichTextAdapter<TValue, TAdapterProps, TExtraProperties>\n    | RichTextAdapterProvider<TValue, TAdapterProps, TExtraProperties>\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'richText'\n  validate?: RichTextFieldValidation\n} & Omit<FieldBase, 'validate'> &\n  TExtraProperties\n\nexport type RichTextFieldClient<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = FieldBaseClient &\n  Pick<RichTextField<TValue, TAdapterProps, TExtraProperties>, 'maxDepth' | 'type'> &\n  TExtraProperties\n\nexport type ArrayField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<ArrayFieldErrorClientComponent | ArrayFieldErrorServerComponent>\n      Label?: CustomComponent<ArrayFieldLabelClientComponent | ArrayFieldLabelServerComponent>\n      RowLabel?: RowLabelComponent\n    } & FieldAdmin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & FieldAdmin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'array'\n  validate?: ArrayFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type ArrayFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: AdminClient & Pick<ArrayField['admin'], 'initCollapsed' | 'isSortable'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<ArrayField, 'interfaceName' | 'maxRows' | 'minRows' | 'type'>\n\nexport type RadioField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<RadioFieldErrorClientComponent | RadioFieldErrorServerComponent>\n      Label?: CustomComponent<RadioFieldLabelClientComponent | RadioFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    layout?: 'horizontal' | 'vertical'\n  } & FieldAdmin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  options: Option[]\n  type: 'radio'\n  validate?: RadioFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type RadioFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: AdminClient & Pick<RadioField['admin'], 'layout'>\n} & FieldBaseClient &\n  Pick<RadioField, 'interfaceName' | 'options' | 'type'>\n\ntype BlockFields = {\n  [key: string]: any\n  blockName?: string\n  blockType?: string\n}\n\nexport type BlockJSX = {\n  /**\n   * Override the default regex used to search for the start of the block in the JSX.\n   * By default, it's <BlockSlugHere\n   */\n  customEndRegex?:\n    | {\n        /**\n         * Whether the end match is optional. If true, the end match is\n         * not required to match for the transformer to be triggered.\n         * The entire text from regexpStart to the end of the document will then be matched.\n         */\n        optional?: true\n        regExp: RegExp\n      }\n    | RegExp\n  /**\n   * Override the default regex used to search for the start of the block in the JSX.\n   * By default, it's <BlockSlugHere/>\n   */\n  customStartRegex?: RegExp\n  /**\n   * By default, all spaces at the beginning and end of every line of the\n   * children (text between the open and close match) are removed.\n   * Set this to true to disable this behavior.\n   */\n  doNotTrimChildren?: boolean\n  /**\n   * Function that receives the data for a given block and returns a JSX representation of it.\n   *\n   * This is used to convert Lexical => JSX\n   */\n  export: (props: {\n    fields: BlockFields\n    lexicalToMarkdown: (props: { editorState: Record<string, any> }) => string\n  }) =>\n    | {\n        children?: string\n        props?: object\n      }\n    | false\n    | string\n  /**\n   * Function that receives the markdown string and parsed\n   * JSX props for a given matched block and returns a Lexical representation of it.\n   *\n   * This is used to convert JSX => Lexical\n   */\n  import: (props: {\n    children: string\n    closeMatch: null | RegExpMatchArray // Only available when customEndRegex is set\n    htmlToLexical?: ((props: { html: string }) => any) | null\n    markdownToLexical: (props: { markdown: string }) => Record<string, any>\n    openMatch?: RegExpMatchArray\n    props: Record<string, any>\n  }) => BlockFields | false\n}\n\nexport type Block = {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same block multiple times.\n   */\n  _sanitized?: boolean\n  admin?: {\n    components?: {\n      /**\n       * This will replace the entire block component, including the block header / collapsible.\n       */\n      Block?: PayloadComponent<any, any>\n      Label?: PayloadComponent<any, any>\n    }\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    /**\n     * Hides the block name field from the Block's header\n     *\n     * @default false\n     */\n    disableBlockName?: boolean\n    group?: Record<string, string> | string\n    jsx?: PayloadComponent\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** @deprecated - please migrate to the interfaceName property instead. */\n  graphQL?: {\n    singularName?: string\n  }\n  imageAltText?: string\n  /**\n   * Preferred aspect ratio of the image is 3 : 2\n   */\n  imageURL?: string\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  jsx?: BlockJSX\n  labels?: Labels\n  slug: string\n}\n\nexport type ClientBlock = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: Pick<Block['admin'], 'custom' | 'disableBlockName' | 'group'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & Pick<Block, 'imageAltText' | 'imageURL' | 'jsx' | 'slug'>\n\nexport type BlocksField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<BlocksFieldErrorClientComponent | BlocksFieldErrorServerComponent>\n      Label?: CustomComponent<BlocksFieldLabelClientComponent | BlocksFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & FieldAdmin\n  /**\n   * Like `blocks`, but allows you to also pass strings that are slugs of blocks defined in `config.blocks`.\n   *\n   * @todo `blockReferences` will be merged with `blocks` in 4.0\n   */\n  blockReferences?: (Block | BlockSlug)[]\n  blocks: Block[]\n  defaultValue?: DefaultValue\n  /**\n   * Blocks can be conditionally enabled using the `filterOptions` property on the blocks field.\n   * It allows you to provide a function that returns which block slugs should be available based on the given context.\n   *\n   * @behavior\n   *\n   * - `filterOptions` is re-evaluated as part of the form state request, whenever the document data changes.\n   * - If a block is present in the field but no longer allowed by `filterOptions`, a validation error will occur when saving.\n   *\n   * @example\n   *\n   * ```ts\n   * {\n   *   name: 'blocksWithDynamicFilterOptions',\n   *   type: 'blocks',\n   *   filterOptions: ({ siblingData }) => {\n   *     return siblingData?.enabledBlocks?.length\n   *       ? [siblingData.enabledBlocks] // allow only the matching block\n   *       : true // allow all blocks if no value is set\n   *   },\n   *   blocks: [\n   *     { slug: 'block1', fields: [{ type: 'text', name: 'block1Text' }] },\n   *     { slug: 'block2', fields: [{ type: 'text', name: 'block2Text' }] },\n   *     { slug: 'block3', fields: [{ type: 'text', name: 'block3Text' }] },\n   *   ],\n   * }\n   * ```\n   * In this example, the list of available blocks is determined by the enabledBlocks sibling field. If no value is set, all blocks remain available.\n   */\n  filterOptions?: BlocksFilterOptions\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'blocks'\n  validate?: BlocksFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type BlocksFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: AdminClient & Pick<BlocksField['admin'], 'initCollapsed' | 'isSortable'>\n  /**\n   * Like `blocks`, but allows you to also pass strings that are slugs of blocks defined in `config.blocks`.\n   *\n   * @todo `blockReferences` will be merged with `blocks` in 4.0\n   */\n  blockReferences?: (ClientBlock | string)[]\n  blocks: ClientBlock[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<BlocksField, 'maxRows' | 'minRows' | 'type'>\n\nexport type PointField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<PointFieldErrorClientComponent | PointFieldErrorServerComponent>\n      Label?: CustomComponent<PointFieldLabelClientComponent | PointFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    placeholder?: Record<string, string> | string\n    step?: number\n  } & FieldAdmin\n  type: 'point'\n  validate?: PointFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type PointFieldClient = {\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n  admin?: AdminClient & Pick<PointField['admin'], 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<PointField, 'type'>\n\n/**\n * A virtual field that loads in related collections by querying a relationship or upload field.\n */\nexport type JoinField = {\n  access?: {\n    create?: never\n    read?: FieldAccess\n    update?: never\n  }\n  admin?: {\n    allowCreate?: boolean\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<JoinFieldErrorClientComponent | JoinFieldErrorServerComponent>\n      Label?: CustomComponent<JoinFieldLabelClientComponent | JoinFieldLabelServerComponent>\n    } & FieldAdmin['components']\n    defaultColumns?: string[]\n    disableBulkEdit?: never\n    disableRowTypes?: boolean\n    readOnly?: never\n  } & FieldAdmin\n  /**\n   * The slug of the collection to relate with.\n   */\n  collection: CollectionSlug | CollectionSlug[]\n  defaultLimit?: number\n  defaultSort?: Sort\n  defaultValue?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's hasMany property.\n   */\n  hasMany?: boolean\n  hidden?: false\n  index?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's localized property.\n   */\n  localized?: boolean\n  /**\n   * The maximum allowed depth to be permitted application-wide. This setting helps prevent against malicious queries.\n   *\n   * @see https://payloadcms.com/docs/getting-started/concepts#depth\n   *\n   * @default 1\n   */\n  maxDepth?: number\n  /**\n   * A string for the field in the collection being joined to.\n   */\n  on: string\n  /**\n   * If true, enables custom ordering for the collection with the relationship, and joined documents can be reordered via drag and drop.\n   * New documents are inserted at the end of the list according to this parameter.\n   *\n   * Under the hood, a field with {@link https://observablehq.com/@dgreensp/implementing-fractional-indexing|fractional indexing} is used to optimize inserts and reorderings.\n   *\n   * @default false\n   *\n   * @experimental There may be frequent breaking changes to this API\n   */\n  orderable?: boolean\n  sanitizedMany?: JoinField[]\n  type: 'join'\n  validate?: never\n  where?: Where\n} & FieldBase &\n  FieldGraphQLType\n\nexport type JoinFieldClient = {\n  admin?: AdminClient &\n    Pick<\n      JoinField['admin'],\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      'allowCreate' | 'defaultColumns' | 'disableBulkEdit' | 'disableRowTypes' | 'readOnly'\n    >\n} & { targetField: Pick<RelationshipFieldClient, 'relationTo'> } & FieldBaseClient &\n  Pick<\n    JoinField,\n    | 'collection'\n    | 'defaultLimit'\n    | 'defaultSort'\n    | 'index'\n    | 'maxDepth'\n    | 'on'\n    | 'orderable'\n    | 'type'\n    | 'where'\n  >\n\nexport type FlattenedBlock = {\n  flattenedFields: FlattenedField[]\n} & Block\n\nexport type FlattenedBlocksField = {\n  /**\n   * Like `blocks`, but allows you to also pass strings that are slugs of blocks defined in `config.blocks`.\n   *\n   * @todo `blockReferences` will be merged with `blocks` in 4.0\n   */\n  blockReferences?: (FlattenedBlock | string)[]\n  blocks: FlattenedBlock[]\n} & Omit<BlocksField, 'blockReferences' | 'blocks'>\n\nexport type FlattenedGroupField = {\n  flattenedFields: FlattenedField[]\n  name: string\n} & GroupField\n\nexport type FlattenedArrayField = {\n  flattenedFields: FlattenedField[]\n} & ArrayField\n\nexport type FlattenedTabAsField = {\n  flattenedFields: FlattenedField[]\n} & MarkRequired<TabAsField, 'name'>\n\nexport type FlattenedJoinField = {\n  targetField: RelationshipField | UploadField\n} & JoinField\n\nexport type FlattenedField =\n  | CheckboxField\n  | CodeField\n  | DateField\n  | EmailField\n  | FlattenedArrayField\n  | FlattenedBlocksField\n  | FlattenedGroupField\n  | FlattenedJoinField\n  | FlattenedTabAsField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | SelectField\n  | TextareaField\n  | TextField\n  | UploadField\nexport type Field =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | GroupField\n  | JoinField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UIField\n  | UploadField\n\nexport type ClientField =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UIFieldClient\n  | UploadFieldClient\n\nexport type ClientFieldProps =\n  | ArrayFieldClientProps\n  | BlocksFieldClientProps\n  | CheckboxFieldClientProps\n  | CodeFieldClientProps\n  | CollapsibleFieldClientProps\n  | DateFieldClientProps\n  | EmailFieldClientProps\n  | GroupFieldClientProps\n  | HiddenFieldProps\n  | JoinFieldClientProps\n  | JSONFieldClientProps\n  | NumberFieldClientProps\n  | PointFieldClientProps\n  | RadioFieldClientProps\n  | RelationshipFieldClientProps\n  | RichTextFieldClientProps\n  | RowFieldClientProps\n  | SelectFieldClientProps\n  | TabsFieldClientProps\n  | TextareaFieldClientProps\n  | TextFieldClientProps\n  | UploadFieldClientProps\n\ntype ExtractFieldTypes<T> = T extends { type: infer U } ? U : never\n\nexport type FieldTypes = ExtractFieldTypes<Field>\n\nexport type FieldAffectingData =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | DateField\n  | EmailField\n  | JoinField\n  | JSONField\n  | NamedGroupField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | SelectField\n  | TabAsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type FieldAffectingDataClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NamedGroupFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | SelectFieldClient\n  | TabAsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type NonPresentationalField =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | JSONField\n  | NamedGroupField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type NonPresentationalFieldClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | JSONFieldClient\n  | NamedGroupFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type FieldWithPath = {\n  path?: string\n} & Field\n\nexport type FieldWithPathClient = {\n  path?: string\n} & ClientField\n\nexport type FieldWithSubFields = ArrayField | CollapsibleField | GroupField | RowField\n\nexport type FieldWithSubFieldsClient =\n  | ArrayFieldClient\n  | CollapsibleFieldClient\n  | GroupFieldClient\n  | RowFieldClient\n\nexport type FieldPresentationalOnly = UIField\nexport type FieldPresentationalOnlyClient = UIFieldClient\n\nexport type FieldWithMany = RelationshipField | SelectField\nexport type FieldWithManyClient = RelationshipFieldClient | SelectFieldClient\n\nexport type FieldWithMaxDepth = RelationshipField | UploadField\nexport type FieldWithMaxDepthClient = JoinFieldClient | RelationshipFieldClient | UploadFieldClient\n\nexport function fieldHasSubFields<TField extends ClientField | Field | TabAsField>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithSubFieldsClient : FieldWithSubFields) {\n  return (\n    field.type === 'group' ||\n    field.type === 'array' ||\n    field.type === 'row' ||\n    field.type === 'collapsible'\n  )\n}\n\nexport function fieldIsArrayType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? ArrayFieldClient : ArrayField) {\n  return field.type === 'array'\n}\n\nexport function fieldIsBlockType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? BlocksFieldClient : BlocksField) {\n  return field.type === 'blocks'\n}\n\nexport function fieldIsGroupType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? GroupFieldClient : GroupField) {\n  return field.type === 'group'\n}\n\nexport function optionIsObject(option: Option): option is OptionObject {\n  return typeof option === 'object'\n}\n\nexport function optionsAreObjects(options: Option[]): options is OptionObject[] {\n  return Array.isArray(options) && typeof options?.[0] === 'object'\n}\n\nexport function optionIsValue(option: Option): option is string {\n  return typeof option === 'string'\n}\n\nexport function fieldSupportsMany<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithManyClient : FieldWithMany) {\n  return field.type === 'select' || field.type === 'relationship' || field.type === 'upload'\n}\n\nexport function fieldHasMaxDepth<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithMaxDepthClient : FieldWithMaxDepth) {\n  return (\n    (field.type === 'upload' || field.type === 'relationship' || field.type === 'join') &&\n    typeof field.maxDepth === 'number'\n  )\n}\n\nexport function fieldIsPresentationalOnly<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField & (TField extends ClientField | TabAsFieldClient ? UIFieldClient : UIField) {\n  return field.type === 'ui'\n}\n\nexport function fieldIsSidebar<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(\n  field: TField,\n): field is { admin: { position: 'sidebar' } } & TField {\n  return 'admin' in field && 'position' in field.admin! && field.admin.position === 'sidebar'\n}\n\nexport function fieldIsID<TField extends ClientField | Field>(\n  field: TField,\n): field is { name: 'id' } & TField {\n  return 'name' in field && field.name === 'id'\n}\n\nexport function fieldIsHiddenOrDisabled<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(field: TField): field is { admin: { hidden: true } } & TField {\n  return (\n    ('hidden' in field && field.hidden) ||\n    ('admin' in field && 'disabled' in field.admin! && field.admin.disabled!)\n  )\n}\n\nexport function fieldAffectsData<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField &\n  (TField extends ClientField | TabAsFieldClient ? FieldAffectingDataClient : FieldAffectingData) {\n  return 'name' in field && !fieldIsPresentationalOnly(field)\n}\n\nexport function tabHasName<TField extends ClientTab | Tab>(tab: TField): tab is NamedTab & TField {\n  return 'name' in tab\n}\n\nexport function groupHasName(\n  group: Partial<NamedGroupFieldClient>,\n): group is NamedGroupFieldClient {\n  return 'name' in group\n}\n\n/**\n * Check if a field has localized: true set. This does not check if a field *should*\n * be localized. To check if a field should be localized, use `fieldShouldBeLocalized`.\n *\n * @deprecated this will be removed or modified in v4.0, as `fieldIsLocalized` can easily lead to bugs due to\n * parent field localization not being taken into account.\n */\nexport function fieldIsLocalized(field: Field | Tab): boolean {\n  return 'localized' in field && field.localized!\n}\n\n/**\n * Similar to `fieldIsLocalized`, but returns `false` if any parent field is localized.\n */\nexport function fieldShouldBeLocalized({\n  field,\n  parentIsLocalized,\n}: {\n  field: ClientField | ClientTab | Field | Tab\n  parentIsLocalized: boolean\n}): boolean {\n  return (\n    'localized' in field &&\n    field.localized! &&\n    (!parentIsLocalized ||\n      process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized === 'true')\n  )\n}\n\nexport function fieldIsVirtual(field: Field | Tab): boolean {\n  return 'virtual' in field && Boolean(field.virtual)\n}\n\nexport type HookName =\n  | 'afterChange'\n  | 'afterRead'\n  | 'beforeChange'\n  | 'beforeRead'\n  | 'beforeValidate'\n"],"names":["valueIsValueWithRelation","value","fieldHasSubFields","field","type","fieldIsArrayType","fieldIsBlockType","fieldIsGroupType","optionIsObject","option","optionsAreObjects","options","Array","isArray","optionIsValue","fieldSupportsMany","fieldHasMaxDepth","maxDepth","fieldIsPresentationalOnly","fieldIsSidebar","admin","position","fieldIsID","name","fieldIsHiddenOrDisabled","hidden","disabled","fieldAffectsData","tabHasName","tab","groupHasName","group","fieldIsLocalized","localized","fieldShouldBeLocalized","parentIsLocalized","process","env","NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized","fieldIsVirtual","Boolean","virtual"],"mappings":"AAAA,qDAAqD,GA2yCrD,OAAO,SAASA,yBAAyBC,KAAc;IACrD,OAAOA,UAAU,QAAQ,OAAOA,UAAU,YAAY,gBAAgBA,SAAS,WAAWA;AAC5F;AA2pBA,OAAO,SAASC,kBACdC,KAAa;IAEb,OACEA,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,SACfD,MAAMC,IAAI,KAAK;AAEnB;AAEA,OAAO,SAASC,iBACdF,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEA,OAAO,SAASE,iBACdH,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEA,OAAO,SAASG,iBACdJ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEA,OAAO,SAASI,eAAeC,MAAc;IAC3C,OAAO,OAAOA,WAAW;AAC3B;AAEA,OAAO,SAASC,kBAAkBC,OAAiB;IACjD,OAAOC,MAAMC,OAAO,CAACF,YAAY,OAAOA,SAAS,CAAC,EAAE,KAAK;AAC3D;AAEA,OAAO,SAASG,cAAcL,MAAc;IAC1C,OAAO,OAAOA,WAAW;AAC3B;AAEA,OAAO,SAASM,kBACdZ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK;AACpF;AAEA,OAAO,SAASY,iBACdb,KAAa;IAEb,OACE,AAACA,CAAAA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK,MAAK,KACjF,OAAOD,MAAMc,QAAQ,KAAK;AAE9B;AAEA,OAAO,SAASC,0BAGdf,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEA,OAAO,SAASe,eACdhB,KAAa;IAEb,OAAO,WAAWA,SAAS,cAAcA,MAAMiB,KAAK,IAAKjB,MAAMiB,KAAK,CAACC,QAAQ,KAAK;AACpF;AAEA,OAAO,SAASC,UACdnB,KAAa;IAEb,OAAO,UAAUA,SAASA,MAAMoB,IAAI,KAAK;AAC3C;AAEA,OAAO,SAASC,wBAEdrB,KAAa;IACb,OACE,AAAC,YAAYA,SAASA,MAAMsB,MAAM,IACjC,WAAWtB,SAAS,cAAcA,MAAMiB,KAAK,IAAKjB,MAAMiB,KAAK,CAACM,QAAQ;AAE3E;AAEA,OAAO,SAASC,iBAGdxB,KAAa;IAGb,OAAO,UAAUA,SAAS,CAACe,0BAA0Bf;AACvD;AAEA,OAAO,SAASyB,WAA2CC,GAAW;IACpE,OAAO,UAAUA;AACnB;AAEA,OAAO,SAASC,aACdC,KAAqC;IAErC,OAAO,UAAUA;AACnB;AAEA;;;;;;CAMC,GACD,OAAO,SAASC,iBAAiB7B,KAAkB;IACjD,OAAO,eAAeA,SAASA,MAAM8B,SAAS;AAChD;AAEA;;CAEC,GACD,OAAO,SAASC,uBAAuB,EACrC/B,KAAK,EACLgC,iBAAiB,EAIlB;IACC,OACE,eAAehC,SACfA,MAAM8B,SAAS,IACd,CAAA,CAACE,qBACAC,QAAQC,GAAG,CAACC,+DAA+D,KAAK,MAAK;AAE3F;AAEA,OAAO,SAASC,eAAepC,KAAkB;IAC/C,OAAO,aAAaA,SAASqC,QAAQrC,MAAMsC,OAAO;AACpD"}