{"version":3,"sources":["../../../src/auth/operations/refresh.ts"],"sourcesContent":["import type { Collection } from '../../collections/config/types.js'\nimport type { Document, PayloadRequest } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport { Forbidden } from '../../errors/index.js'\nimport { commitTransaction } from '../../utilities/commitTransaction.js'\nimport { initTransaction } from '../../utilities/initTransaction.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { jwtSign } from '../jwt.js'\nimport { removeExpiredSessions } from '../sessions.js'\n\nexport type Result = {\n  exp: number\n  refreshedToken: string\n  setCookie?: boolean\n  /** @deprecated\n   * use:\n   * ```ts\n   * user._strategy\n   * ```\n   */\n  strategy?: string\n  user: Document\n}\n\nexport type Arguments = {\n  collection: Collection\n  req: PayloadRequest\n}\n\nexport const refreshOperation = async (incomingArgs: Arguments): Promise<Result> => {\n  let args = incomingArgs\n\n  try {\n    const shouldCommit = await initTransaction(args.req)\n\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'refresh',\n    })\n\n    // /////////////////////////////////////\n    // Refresh\n    // /////////////////////////////////////\n\n    const {\n      collection: { config: collectionConfig },\n      req,\n      req: {\n        payload: { config, secret },\n      },\n    } = args\n\n    if (!args.req.user) {\n      throw new Forbidden(args.req.t)\n    }\n\n    const pathname = new URL(args.req.url!).pathname\n\n    const isGraphQL = pathname === config.routes.graphQL\n\n    let user = await req.payload.db.findOne<any>({\n      collection: collectionConfig.slug,\n      req,\n      where: { id: { equals: args.req.user.id } },\n    })\n\n    const sid = args.req.user._sid\n\n    if (collectionConfig.auth.useSessions && !collectionConfig.auth.disableLocalStrategy) {\n      if (!Array.isArray(user.sessions) || !sid) {\n        throw new Forbidden(args.req.t)\n      }\n\n      const existingSession = user.sessions.find(({ id }: { id: number }) => id === sid)\n\n      const now = new Date()\n      const tokenExpInMs = collectionConfig.auth.tokenExpiration * 1000\n      existingSession.expiresAt = new Date(now.getTime() + tokenExpInMs)\n\n      // Prevent updatedAt from being updated when only refreshing a session\n      user.updatedAt = null\n\n      await req.payload.db.updateOne({\n        id: user.id,\n        collection: collectionConfig.slug,\n        data: {\n          ...user,\n          sessions: removeExpiredSessions(user.sessions),\n        },\n        req,\n        returning: false,\n      })\n    }\n\n    user = await req.payload.findByID({\n      id: user.id,\n      collection: collectionConfig.slug,\n      depth: isGraphQL ? 0 : args.collection.config.auth.depth,\n      req: args.req,\n    })\n\n    if (user) {\n      user.collection = args.req.user.collection\n      user._strategy = args.req.user._strategy\n    }\n\n    let result!: Result\n\n    // /////////////////////////////////////\n    // refresh hook - Collection\n    // /////////////////////////////////////\n\n    for (const refreshHook of args.collection.config.hooks.refresh) {\n      const hookResult = await refreshHook({ args, user })\n\n      if (hookResult) {\n        result = hookResult\n        break\n      }\n    }\n\n    if (!result) {\n      const fieldsToSign = getFieldsToSign({\n        collectionConfig,\n        email: user?.email as string,\n        sid,\n        user: args?.req?.user,\n      })\n\n      const { exp, token: refreshedToken } = await jwtSign({\n        fieldsToSign,\n        secret,\n        tokenExpiration: collectionConfig.auth.tokenExpiration,\n      })\n\n      result = {\n        exp,\n        refreshedToken,\n        setCookie: true,\n        /** @deprecated\n         * use:\n         * ```ts\n         * user._strategy\n         * ```\n         */\n        strategy: args.req.user._strategy,\n        user,\n      }\n    }\n\n    // /////////////////////////////////////\n    // After Refresh - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRefresh?.length) {\n      for (const hook of collectionConfig.hooks.afterRefresh) {\n        result =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            exp: result.exp,\n            req: args.req,\n            token: result.refreshedToken,\n          })) || result\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'refresh',\n      result,\n    })\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["buildAfterOperation","buildBeforeOperation","Forbidden","commitTransaction","initTransaction","killTransaction","getFieldsToSign","jwtSign","removeExpiredSessions","refreshOperation","incomingArgs","args","shouldCommit","req","collection","config","operation","collectionConfig","payload","secret","user","t","pathname","URL","url","isGraphQL","routes","graphQL","db","findOne","slug","where","id","equals","sid","_sid","auth","useSessions","disableLocalStrategy","Array","isArray","sessions","existingSession","find","now","Date","tokenExpInMs","tokenExpiration","expiresAt","getTime","updatedAt","updateOne","data","returning","findByID","depth","_strategy","result","refreshHook","hooks","refresh","hookResult","fieldsToSign","email","exp","token","refreshedToken","setCookie","strategy","afterRefresh","length","hook","context","error"],"mappings":"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"}