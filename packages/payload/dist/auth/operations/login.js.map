{"version":3,"sources":["../../../src/auth/operations/login.ts"],"sourcesContent":["import type {\n  AuthOperationsFromCollectionSlug,\n  Collection,\n  DataFromCollectionSlug,\n} from '../../collections/config/types.js'\nimport type { CollectionSlug, TypedUser } from '../../index.js'\nimport type { PayloadRequest, Where } from '../../types/index.js'\n\nimport { buildAfterOperation } from '../../collections/operations/utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from '../../collections/operations/utilities/buildBeforeOperation.js'\nimport {\n  AuthenticationError,\n  LockedAuth,\n  UnverifiedEmail,\n  ValidationError,\n} from '../../errors/index.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { commitTransaction, Forbidden, initTransaction } from '../../index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { getFieldsToSign } from '../getFieldsToSign.js'\nimport { getLoginOptions } from '../getLoginOptions.js'\nimport { isUserLocked } from '../isUserLocked.js'\nimport { jwtSign } from '../jwt.js'\nimport { addSessionToUser, revokeSession } from '../sessions.js'\nimport { authenticateLocalStrategy } from '../strategies/local/authenticate.js'\nimport { incrementLoginAttempts } from '../strategies/local/incrementLoginAttempts.js'\nimport { resetLoginAttempts } from '../strategies/local/resetLoginAttempts.js'\n\nexport type Result = {\n  exp?: number\n  token?: string\n  user?: TypedUser\n}\n\nexport type Arguments<TSlug extends CollectionSlug> = {\n  collection: Collection\n  data: AuthOperationsFromCollectionSlug<TSlug>['login']\n  depth?: number\n  overrideAccess?: boolean\n  req: PayloadRequest\n  showHiddenFields?: boolean\n}\n\ntype CheckLoginPermissionArgs = {\n  loggingInWithUsername?: boolean\n  req: PayloadRequest\n  user: any\n}\n\n/**\n * Throws an error if the user is locked or does not exist.\n * This does not check the login attempts, only the lock status. Whoever increments login attempts\n * is responsible for locking the user properly, not whoever checks the login permission.\n */\nexport const checkLoginPermission = ({\n  loggingInWithUsername,\n  req,\n  user,\n}: CheckLoginPermissionArgs) => {\n  if (!user) {\n    throw new AuthenticationError(req.t, Boolean(loggingInWithUsername))\n  }\n\n  if (isUserLocked(new Date(user.lockUntil))) {\n    throw new LockedAuth(req.t)\n  }\n}\n\nexport const loginOperation = async <TSlug extends CollectionSlug>(\n  incomingArgs: Arguments<TSlug>,\n): Promise<{ user: DataFromCollectionSlug<TSlug> } & Result> => {\n  let args = incomingArgs\n\n  if (args.collection.config.auth.disableLocalStrategy) {\n    throw new Forbidden(args.req.t)\n  }\n\n  // /////////////////////////////////////\n  // beforeOperation - Collection\n  // /////////////////////////////////////\n\n  args = await buildBeforeOperation({\n    args,\n    collection: args.collection.config,\n    operation: 'login',\n  })\n\n  const {\n    collection: { config: collectionConfig },\n    data,\n    depth,\n    overrideAccess,\n    req,\n    req: {\n      fallbackLocale,\n      locale,\n      payload,\n      payload: { secret },\n    },\n    showHiddenFields,\n  } = args\n\n  // /////////////////////////////////////\n  // Login\n  // /////////////////////////////////////\n\n  const { email: unsanitizedEmail, password } = data\n  const loginWithUsername = collectionConfig.auth.loginWithUsername\n\n  const sanitizedEmail =\n    typeof unsanitizedEmail === 'string' ? unsanitizedEmail.toLowerCase().trim() : null\n  const sanitizedUsername =\n    'username' in data && typeof data?.username === 'string'\n      ? data.username.toLowerCase().trim()\n      : null\n\n  const { canLoginWithEmail, canLoginWithUsername } = getLoginOptions(loginWithUsername)\n\n  // cannot login with email, did not provide username\n  if (!canLoginWithEmail && !sanitizedUsername) {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [{ message: req.i18n.t('validation:required'), path: 'username' }],\n    })\n  }\n\n  // cannot login with username, did not provide email\n  if (!canLoginWithUsername && !sanitizedEmail) {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [{ message: req.i18n.t('validation:required'), path: 'email' }],\n    })\n  }\n\n  // can login with either email or username, did not provide either\n  if (!sanitizedUsername && !sanitizedEmail) {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [\n        { message: req.i18n.t('validation:required'), path: 'email' },\n        { message: req.i18n.t('validation:required'), path: 'username' },\n      ],\n    })\n  }\n\n  // did not provide password for login\n  if (typeof password !== 'string' || password.trim() === '') {\n    throw new ValidationError({\n      collection: collectionConfig.slug,\n      errors: [{ message: req.i18n.t('validation:required'), path: 'password' }],\n    })\n  }\n\n  let whereConstraint: Where = {}\n  const emailConstraint: Where = {\n    email: {\n      equals: sanitizedEmail,\n    },\n  }\n  const usernameConstraint: Where = {\n    username: {\n      equals: sanitizedUsername,\n    },\n  }\n\n  if (canLoginWithEmail && canLoginWithUsername && (sanitizedUsername || sanitizedEmail)) {\n    if (sanitizedUsername) {\n      whereConstraint = {\n        or: [\n          usernameConstraint,\n          {\n            email: {\n              equals: sanitizedUsername,\n            },\n          },\n        ],\n      }\n    } else {\n      whereConstraint = {\n        or: [\n          emailConstraint,\n          {\n            username: {\n              equals: sanitizedEmail,\n            },\n          },\n        ],\n      }\n    }\n  } else if (canLoginWithEmail && sanitizedEmail) {\n    whereConstraint = emailConstraint\n  } else if (canLoginWithUsername && sanitizedUsername) {\n    whereConstraint = usernameConstraint\n  }\n\n  // Exclude trashed users\n  whereConstraint = appendNonTrashedFilter({\n    enableTrash: collectionConfig.trash,\n    trash: false,\n    where: whereConstraint,\n  })\n\n  let user = (await payload.db.findOne<TypedUser>({\n    collection: collectionConfig.slug,\n    req,\n    where: whereConstraint,\n  })) as TypedUser\n\n  checkLoginPermission({\n    loggingInWithUsername: Boolean(canLoginWithUsername && sanitizedUsername),\n    req,\n    user,\n  })\n\n  user.collection = collectionConfig.slug\n  user._strategy = 'local-jwt'\n\n  const authResult = await authenticateLocalStrategy({ doc: user, password })\n  user = sanitizeInternalFields(user)\n\n  const maxLoginAttemptsEnabled = args.collection.config.auth.maxLoginAttempts > 0\n\n  if (!authResult) {\n    if (maxLoginAttemptsEnabled) {\n      await incrementLoginAttempts({\n        collection: collectionConfig,\n        payload: req.payload,\n        user,\n      })\n\n      // Re-check login permissions and max attempts after incrementing attempts, in case parallel updates occurred\n      checkLoginPermission({\n        loggingInWithUsername: Boolean(canLoginWithUsername && sanitizedUsername),\n        req,\n        user,\n      })\n    }\n\n    throw new AuthenticationError(req.t)\n  }\n\n  if (collectionConfig.auth.verify && user._verified === false) {\n    throw new UnverifiedEmail({ t: req.t })\n  }\n\n  // Authentication successful - start transaction for remaining operations\n  const shouldCommit = await initTransaction(args.req)\n  let sid: string | undefined\n\n  try {\n    /*\n     * Correct password accepted - reâ€‘check that the account didn't\n     * get locked by parallel bad attempts in the meantime.\n     */\n    if (maxLoginAttemptsEnabled) {\n      const { lockUntil, loginAttempts } = (await payload.db.findOne<TypedUser>({\n        collection: collectionConfig.slug,\n        req,\n        select: {\n          lockUntil: true,\n          loginAttempts: true,\n        },\n        where: { id: { equals: user.id } },\n      }))!\n\n      user.lockUntil = lockUntil\n      user.loginAttempts = loginAttempts\n\n      checkLoginPermission({\n        req,\n        user,\n      })\n    }\n\n    const fieldsToSignArgs: Parameters<typeof getFieldsToSign>[0] = {\n      collectionConfig,\n      email: sanitizedEmail!,\n      user,\n    }\n\n    const session = await addSessionToUser({\n      collectionConfig,\n      payload,\n      req,\n      user,\n    })\n    sid = session.sid\n\n    if (sid) {\n      fieldsToSignArgs.sid = sid\n    }\n\n    const fieldsToSign = getFieldsToSign(fieldsToSignArgs)\n\n    if (maxLoginAttemptsEnabled) {\n      await resetLoginAttempts({\n        collection: collectionConfig,\n        doc: user,\n        payload: req.payload,\n        req,\n      })\n    }\n\n    // /////////////////////////////////////\n    // beforeLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.beforeLogin?.length) {\n      for (const hook of collectionConfig.hooks.beforeLogin) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            user,\n          })) || user\n      }\n    }\n\n    const { exp, token } = await jwtSign({\n      fieldsToSign,\n      secret,\n      tokenExpiration: collectionConfig.auth.tokenExpiration,\n    })\n\n    req.user = user\n\n    // /////////////////////////////////////\n    // afterLogin - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterLogin?.length) {\n      for (const hook of collectionConfig.hooks.afterLogin) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: args.req.context,\n            req: args.req,\n            token,\n            user,\n          })) || user\n      }\n    }\n\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    user = await afterRead({\n      collection: collectionConfig,\n      context: req.context,\n      depth: depth!,\n      doc: user,\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      draft: undefined,\n      fallbackLocale: fallbackLocale!,\n      global: null,\n      locale: locale!,\n      overrideAccess: overrideAccess!,\n      req,\n      showHiddenFields: showHiddenFields!,\n    })\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks?.afterRead?.length) {\n      for (const hook of collectionConfig.hooks.afterRead) {\n        user =\n          (await hook({\n            collection: args.collection?.config,\n            context: req.context,\n            doc: user,\n            req,\n          })) || user\n      }\n    }\n\n    let result: { user: DataFromCollectionSlug<TSlug> } & Result = {\n      exp,\n      token,\n      user,\n    }\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: args.collection?.config,\n      operation: 'login',\n      result,\n    })\n\n    if (shouldCommit) {\n      await commitTransaction(req)\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n\n    return result\n  } catch (error: unknown) {\n    if (sid) {\n      await revokeSession({\n        collectionConfig,\n        payload,\n        req,\n        sid,\n        user,\n      })\n    }\n    await killTransaction(args.req)\n    throw error\n  }\n}\n"],"names":["buildAfterOperation","buildBeforeOperation","AuthenticationError","LockedAuth","UnverifiedEmail","ValidationError","afterRead","commitTransaction","Forbidden","initTransaction","appendNonTrashedFilter","killTransaction","sanitizeInternalFields","getFieldsToSign","getLoginOptions","isUserLocked","jwtSign","addSessionToUser","revokeSession","authenticateLocalStrategy","incrementLoginAttempts","resetLoginAttempts","checkLoginPermission","loggingInWithUsername","req","user","t","Boolean","Date","lockUntil","loginOperation","incomingArgs","args","collection","config","auth","disableLocalStrategy","operation","collectionConfig","data","depth","overrideAccess","fallbackLocale","locale","payload","secret","showHiddenFields","email","unsanitizedEmail","password","loginWithUsername","sanitizedEmail","toLowerCase","trim","sanitizedUsername","username","canLoginWithEmail","canLoginWithUsername","slug","errors","message","i18n","path","whereConstraint","emailConstraint","equals","usernameConstraint","or","enableTrash","trash","where","db","findOne","_strategy","authResult","doc","maxLoginAttemptsEnabled","maxLoginAttempts","verify","_verified","shouldCommit","sid","loginAttempts","select","id","fieldsToSignArgs","session","fieldsToSign","hooks","beforeLogin","length","hook","context","exp","token","tokenExpiration","afterLogin","draft","undefined","global","result","error"],"mappings":"AAQA,SAASA,mBAAmB,QAAQ,gEAA+D;AACnG,SAASC,oBAAoB,QAAQ,iEAAgE;AACrG,SACEC,mBAAmB,EACnBC,UAAU,EACVC,eAAe,EACfC,eAAe,QACV,wBAAuB;AAC9B,SAASC,SAAS,QAAQ,wCAAuC;AACjE,SAASC,iBAAiB,EAAEC,SAAS,EAAEC,eAAe,QAAQ,iBAAgB;AAC9E,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,eAAe,QAAQ,wBAAuB;AACvD,SAASC,eAAe,QAAQ,wBAAuB;AACvD,SAASC,YAAY,QAAQ,qBAAoB;AACjD,SAASC,OAAO,QAAQ,YAAW;AACnC,SAASC,gBAAgB,EAAEC,aAAa,QAAQ,iBAAgB;AAChE,SAASC,yBAAyB,QAAQ,sCAAqC;AAC/E,SAASC,sBAAsB,QAAQ,gDAA+C;AACtF,SAASC,kBAAkB,QAAQ,4CAA2C;AAuB9E;;;;CAIC,GACD,OAAO,MAAMC,uBAAuB,CAAC,EACnCC,qBAAqB,EACrBC,GAAG,EACHC,IAAI,EACqB;IACzB,IAAI,CAACA,MAAM;QACT,MAAM,IAAIvB,oBAAoBsB,IAAIE,CAAC,EAAEC,QAAQJ;IAC/C;IAEA,IAAIR,aAAa,IAAIa,KAAKH,KAAKI,SAAS,IAAI;QAC1C,MAAM,IAAI1B,WAAWqB,IAAIE,CAAC;IAC5B;AACF,EAAC;AAED,OAAO,MAAMI,iBAAiB,OAC5BC;IAEA,IAAIC,OAAOD;IAEX,IAAIC,KAAKC,UAAU,CAACC,MAAM,CAACC,IAAI,CAACC,oBAAoB,EAAE;QACpD,MAAM,IAAI5B,UAAUwB,KAAKR,GAAG,CAACE,CAAC;IAChC;IAEA,wCAAwC;IACxC,+BAA+B;IAC/B,wCAAwC;IAExCM,OAAO,MAAM/B,qBAAqB;QAChC+B;QACAC,YAAYD,KAAKC,UAAU,CAACC,MAAM;QAClCG,WAAW;IACb;IAEA,MAAM,EACJJ,YAAY,EAAEC,QAAQI,gBAAgB,EAAE,EACxCC,IAAI,EACJC,KAAK,EACLC,cAAc,EACdjB,GAAG,EACHA,KAAK,EACHkB,cAAc,EACdC,MAAM,EACNC,OAAO,EACPA,SAAS,EAAEC,MAAM,EAAE,EACpB,EACDC,gBAAgB,EACjB,GAAGd;IAEJ,wCAAwC;IACxC,QAAQ;IACR,wCAAwC;IAExC,MAAM,EAAEe,OAAOC,gBAAgB,EAAEC,QAAQ,EAAE,GAAGV;IAC9C,MAAMW,oBAAoBZ,iBAAiBH,IAAI,CAACe,iBAAiB;IAEjE,MAAMC,iBACJ,OAAOH,qBAAqB,WAAWA,iBAAiBI,WAAW,GAAGC,IAAI,KAAK;IACjF,MAAMC,oBACJ,cAAcf,QAAQ,OAAOA,MAAMgB,aAAa,WAC5ChB,KAAKgB,QAAQ,CAACH,WAAW,GAAGC,IAAI,KAChC;IAEN,MAAM,EAAEG,iBAAiB,EAAEC,oBAAoB,EAAE,GAAG3C,gBAAgBoC;IAEpE,oDAAoD;IACpD,IAAI,CAACM,qBAAqB,CAACF,mBAAmB;QAC5C,MAAM,IAAIjD,gBAAgB;YACxB4B,YAAYK,iBAAiBoB,IAAI;YACjCC,QAAQ;gBAAC;oBAAEC,SAASpC,IAAIqC,IAAI,CAACnC,CAAC,CAAC;oBAAwBoC,MAAM;gBAAW;aAAE;QAC5E;IACF;IAEA,oDAAoD;IACpD,IAAI,CAACL,wBAAwB,CAACN,gBAAgB;QAC5C,MAAM,IAAI9C,gBAAgB;YACxB4B,YAAYK,iBAAiBoB,IAAI;YACjCC,QAAQ;gBAAC;oBAAEC,SAASpC,IAAIqC,IAAI,CAACnC,CAAC,CAAC;oBAAwBoC,MAAM;gBAAQ;aAAE;QACzE;IACF;IAEA,kEAAkE;IAClE,IAAI,CAACR,qBAAqB,CAACH,gBAAgB;QACzC,MAAM,IAAI9C,gBAAgB;YACxB4B,YAAYK,iBAAiBoB,IAAI;YACjCC,QAAQ;gBACN;oBAAEC,SAASpC,IAAIqC,IAAI,CAACnC,CAAC,CAAC;oBAAwBoC,MAAM;gBAAQ;gBAC5D;oBAAEF,SAASpC,IAAIqC,IAAI,CAACnC,CAAC,CAAC;oBAAwBoC,MAAM;gBAAW;aAChE;QACH;IACF;IAEA,qCAAqC;IACrC,IAAI,OAAOb,aAAa,YAAYA,SAASI,IAAI,OAAO,IAAI;QAC1D,MAAM,IAAIhD,gBAAgB;YACxB4B,YAAYK,iBAAiBoB,IAAI;YACjCC,QAAQ;gBAAC;oBAAEC,SAASpC,IAAIqC,IAAI,CAACnC,CAAC,CAAC;oBAAwBoC,MAAM;gBAAW;aAAE;QAC5E;IACF;IAEA,IAAIC,kBAAyB,CAAC;IAC9B,MAAMC,kBAAyB;QAC7BjB,OAAO;YACLkB,QAAQd;QACV;IACF;IACA,MAAMe,qBAA4B;QAChCX,UAAU;YACRU,QAAQX;QACV;IACF;IAEA,IAAIE,qBAAqBC,wBAAyBH,CAAAA,qBAAqBH,cAAa,GAAI;QACtF,IAAIG,mBAAmB;YACrBS,kBAAkB;gBAChBI,IAAI;oBACFD;oBACA;wBACEnB,OAAO;4BACLkB,QAAQX;wBACV;oBACF;iBACD;YACH;QACF,OAAO;YACLS,kBAAkB;gBAChBI,IAAI;oBACFH;oBACA;wBACET,UAAU;4BACRU,QAAQd;wBACV;oBACF;iBACD;YACH;QACF;IACF,OAAO,IAAIK,qBAAqBL,gBAAgB;QAC9CY,kBAAkBC;IACpB,OAAO,IAAIP,wBAAwBH,mBAAmB;QACpDS,kBAAkBG;IACpB;IAEA,wBAAwB;IACxBH,kBAAkBrD,uBAAuB;QACvC0D,aAAa9B,iBAAiB+B,KAAK;QACnCA,OAAO;QACPC,OAAOP;IACT;IAEA,IAAItC,OAAQ,MAAMmB,QAAQ2B,EAAE,CAACC,OAAO,CAAY;QAC9CvC,YAAYK,iBAAiBoB,IAAI;QACjClC;QACA8C,OAAOP;IACT;IAEAzC,qBAAqB;QACnBC,uBAAuBI,QAAQ8B,wBAAwBH;QACvD9B;QACAC;IACF;IAEAA,KAAKQ,UAAU,GAAGK,iBAAiBoB,IAAI;IACvCjC,KAAKgD,SAAS,GAAG;IAEjB,MAAMC,aAAa,MAAMvD,0BAA0B;QAAEwD,KAAKlD;QAAMwB;IAAS;IACzExB,OAAOb,uBAAuBa;IAE9B,MAAMmD,0BAA0B5C,KAAKC,UAAU,CAACC,MAAM,CAACC,IAAI,CAAC0C,gBAAgB,GAAG;IAE/E,IAAI,CAACH,YAAY;QACf,IAAIE,yBAAyB;YAC3B,MAAMxD,uBAAuB;gBAC3Ba,YAAYK;gBACZM,SAASpB,IAAIoB,OAAO;gBACpBnB;YACF;YAEA,6GAA6G;YAC7GH,qBAAqB;gBACnBC,uBAAuBI,QAAQ8B,wBAAwBH;gBACvD9B;gBACAC;YACF;QACF;QAEA,MAAM,IAAIvB,oBAAoBsB,IAAIE,CAAC;IACrC;IAEA,IAAIY,iBAAiBH,IAAI,CAAC2C,MAAM,IAAIrD,KAAKsD,SAAS,KAAK,OAAO;QAC5D,MAAM,IAAI3E,gBAAgB;YAAEsB,GAAGF,IAAIE,CAAC;QAAC;IACvC;IAEA,yEAAyE;IACzE,MAAMsD,eAAe,MAAMvE,gBAAgBuB,KAAKR,GAAG;IACnD,IAAIyD;IAEJ,IAAI;QACF;;;KAGC,GACD,IAAIL,yBAAyB;YAC3B,MAAM,EAAE/C,SAAS,EAAEqD,aAAa,EAAE,GAAI,MAAMtC,QAAQ2B,EAAE,CAACC,OAAO,CAAY;gBACxEvC,YAAYK,iBAAiBoB,IAAI;gBACjClC;gBACA2D,QAAQ;oBACNtD,WAAW;oBACXqD,eAAe;gBACjB;gBACAZ,OAAO;oBAAEc,IAAI;wBAAEnB,QAAQxC,KAAK2D,EAAE;oBAAC;gBAAE;YACnC;YAEA3D,KAAKI,SAAS,GAAGA;YACjBJ,KAAKyD,aAAa,GAAGA;YAErB5D,qBAAqB;gBACnBE;gBACAC;YACF;QACF;QAEA,MAAM4D,mBAA0D;YAC9D/C;YACAS,OAAOI;YACP1B;QACF;QAEA,MAAM6D,UAAU,MAAMrE,iBAAiB;YACrCqB;YACAM;YACApB;YACAC;QACF;QACAwD,MAAMK,QAAQL,GAAG;QAEjB,IAAIA,KAAK;YACPI,iBAAiBJ,GAAG,GAAGA;QACzB;QAEA,MAAMM,eAAe1E,gBAAgBwE;QAErC,IAAIT,yBAAyB;YAC3B,MAAMvD,mBAAmB;gBACvBY,YAAYK;gBACZqC,KAAKlD;gBACLmB,SAASpB,IAAIoB,OAAO;gBACpBpB;YACF;QACF;QAEA,wCAAwC;QACxC,2BAA2B;QAC3B,wCAAwC;QAExC,IAAIc,iBAAiBkD,KAAK,EAAEC,aAAaC,QAAQ;YAC/C,KAAK,MAAMC,QAAQrD,iBAAiBkD,KAAK,CAACC,WAAW,CAAE;gBACrDhE,OACE,AAAC,MAAMkE,KAAK;oBACV1D,YAAYD,KAAKC,UAAU,EAAEC;oBAC7B0D,SAAS5D,KAAKR,GAAG,CAACoE,OAAO;oBACzBpE,KAAKQ,KAAKR,GAAG;oBACbC;gBACF,MAAOA;YACX;QACF;QAEA,MAAM,EAAEoE,GAAG,EAAEC,KAAK,EAAE,GAAG,MAAM9E,QAAQ;YACnCuE;YACA1C;YACAkD,iBAAiBzD,iBAAiBH,IAAI,CAAC4D,eAAe;QACxD;QAEAvE,IAAIC,IAAI,GAAGA;QAEX,wCAAwC;QACxC,0BAA0B;QAC1B,wCAAwC;QAExC,IAAIa,iBAAiBkD,KAAK,EAAEQ,YAAYN,QAAQ;YAC9C,KAAK,MAAMC,QAAQrD,iBAAiBkD,KAAK,CAACQ,UAAU,CAAE;gBACpDvE,OACE,AAAC,MAAMkE,KAAK;oBACV1D,YAAYD,KAAKC,UAAU,EAAEC;oBAC7B0D,SAAS5D,KAAKR,GAAG,CAACoE,OAAO;oBACzBpE,KAAKQ,KAAKR,GAAG;oBACbsE;oBACArE;gBACF,MAAOA;YACX;QACF;QAEA,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExCA,OAAO,MAAMnB,UAAU;YACrB2B,YAAYK;YACZsD,SAASpE,IAAIoE,OAAO;YACpBpD,OAAOA;YACPmC,KAAKlD;YACL,oFAAoF;YACpFwE,OAAOC;YACPxD,gBAAgBA;YAChByD,QAAQ;YACRxD,QAAQA;YACRF,gBAAgBA;YAChBjB;YACAsB,kBAAkBA;QACpB;QAEA,wCAAwC;QACxC,yBAAyB;QACzB,wCAAwC;QAExC,IAAIR,iBAAiBkD,KAAK,EAAElF,WAAWoF,QAAQ;YAC7C,KAAK,MAAMC,QAAQrD,iBAAiBkD,KAAK,CAAClF,SAAS,CAAE;gBACnDmB,OACE,AAAC,MAAMkE,KAAK;oBACV1D,YAAYD,KAAKC,UAAU,EAAEC;oBAC7B0D,SAASpE,IAAIoE,OAAO;oBACpBjB,KAAKlD;oBACLD;gBACF,MAAOC;YACX;QACF;QAEA,IAAI2E,SAA2D;YAC7DP;YACAC;YACArE;QACF;QAEA,wCAAwC;QACxC,8BAA8B;QAC9B,wCAAwC;QAExC2E,SAAS,MAAMpG,oBAAoB;YACjCgC;YACAC,YAAYD,KAAKC,UAAU,EAAEC;YAC7BG,WAAW;YACX+D;QACF;QAEA,IAAIpB,cAAc;YAChB,MAAMzE,kBAAkBiB;QAC1B;QAEA,wCAAwC;QACxC,iBAAiB;QACjB,wCAAwC;QAExC,OAAO4E;IACT,EAAE,OAAOC,OAAgB;QACvB,IAAIpB,KAAK;YACP,MAAM/D,cAAc;gBAClBoB;gBACAM;gBACApB;gBACAyD;gBACAxD;YACF;QACF;QACA,MAAMd,gBAAgBqB,KAAKR,GAAG;QAC9B,MAAM6E;IACR;AACF,EAAC"}