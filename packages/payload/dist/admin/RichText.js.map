{"version":3,"sources":["../../src/admin/RichText.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { GenericLanguages, I18n } from '@payloadcms/translations'\nimport type { JSONSchema4 } from 'json-schema'\n\nimport type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { ImportMapGenerators, PayloadComponent, SanitizedConfig } from '../config/types.js'\nimport type { ValidationFieldError } from '../errors/ValidationError.js'\nimport type {\n  FieldAffectingData,\n  RichTextField,\n  RichTextFieldClient,\n  Validate,\n} from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { RequestContext, TypedFallbackLocale } from '../index.js'\nimport type { JsonObject, PayloadRequest, PopulateType } from '../types/index.js'\nimport type { RichTextFieldClientProps, RichTextFieldServerProps } from './fields/RichText.js'\nimport type { FieldDiffClientProps, FieldDiffServerProps, FieldSchemaMap } from './types.js'\n\nexport type AfterReadRichTextHookArgs<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TData extends TypeWithID = any,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TValue = any,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TSiblingData = any,\n> = {\n  currentDepth?: number\n\n  depth?: number\n\n  draft?: boolean\n\n  fallbackLocale?: TypedFallbackLocale\n  fieldPromises?: Promise<void>[]\n\n  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */\n  findMany?: boolean\n\n  flattenLocales?: boolean\n\n  locale?: string\n\n  /** A string relating to which operation the field type is currently executing within. */\n  operation?: 'create' | 'delete' | 'read' | 'update'\n\n  overrideAccess?: boolean\n\n  populate?: PopulateType\n\n  populationPromises?: Promise<void>[]\n  showHiddenFields?: boolean\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\nexport type AfterChangeRichTextHookArgs<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = {\n  /** A string relating to which operation the field type is currently executing within. */\n  operation: 'create' | 'update'\n  /** The document before changes were applied. */\n  previousDoc?: TData\n  /** The sibling data of the document before changes being applied. */\n  previousSiblingDoc?: TSiblingData\n  /** The previous value of the field, before changes */\n  previousValue?: TValue\n}\n\nexport type BeforeValidateRichTextHookArgs<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = {\n  /** A string relating to which operation the field type is currently executing within. */\n  operation: 'create' | 'update'\n  overrideAccess?: boolean\n  /** The sibling data of the document before changes being applied. */\n  previousSiblingDoc?: TSiblingData\n  /** The previous value of the field, before changes */\n  previousValue?: TValue\n}\n\nexport type BeforeChangeRichTextHookArgs<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = {\n  /**\n   * The original data with locales (not modified by any hooks). Only available in `beforeChange` and `beforeDuplicate` field hooks.\n   */\n  docWithLocales?: JsonObject\n\n  duplicate?: boolean\n\n  errors?: ValidationFieldError[]\n  /**\n   * Built up field label\n   *\n   * @example \"Group Field > Tab Field > Rich Text Field\"\n   */\n  fieldLabelPath: string\n  /** Only available in `beforeChange` field hooks */\n  mergeLocaleActions?: (() => Promise<void> | void)[]\n  /** A string relating to which operation the field type is currently executing within. */\n  operation?: 'create' | 'delete' | 'read' | 'update'\n  overrideAccess: boolean\n  /** The sibling data of the document before changes being applied. */\n  previousSiblingDoc?: TSiblingData\n  /** The previous value of the field, before changes */\n  previousValue?: TValue\n  /**\n   * The original siblingData with locales (not modified by any hooks).\n   */\n  siblingDocWithLocales?: JsonObject\n  skipValidation?: boolean\n}\n\nexport type BaseRichTextHookArgs<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = {\n  /** The collection which the field belongs to. If the field belongs to a global, this will be null. */\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /** The data passed to update the document within create and update operations, and the full document itself in the afterRead hook. */\n  data?: Partial<TData>\n  /** The field which the hook is running against. */\n  field: FieldAffectingData\n  /** The global which the field belongs to. If the field belongs to a collection, this will be null. */\n  global: null | SanitizedGlobalConfig\n  indexPath: number[]\n  /** The full original document in `update` operations. In the `afterChange` hook, this is the resulting document of the operation. */\n  originalDoc?: TData\n  parentIsLocalized: boolean\n  /**\n   * The path of the field, e.g. [\"group\", \"myArray\", 1, \"textField\"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.\n   */\n  path: (number | string)[]\n  /** The Express request object. It is mocked for Local API operations. */\n  req: PayloadRequest\n  /**\n   * The schemaPath of the field, e.g. [\"group\", \"myArray\", \"textField\"]. The schemaPath is the path but without indexes and would be used in the context of field schemas, not field data.\n   */\n  schemaPath: string[]\n  /** The sibling data passed to a field that the hook is running against. */\n  siblingData: Partial<TSiblingData>\n  /** The value of the field. */\n  value?: TValue\n}\n\nexport type AfterReadRichTextHook<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = (\n  args: AfterReadRichTextHookArgs<TData, TValue, TSiblingData> &\n    BaseRichTextHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type AfterChangeRichTextHook<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = (\n  args: AfterChangeRichTextHookArgs<TData, TValue, TSiblingData> &\n    BaseRichTextHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type BeforeChangeRichTextHook<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = (\n  args: BaseRichTextHookArgs<TData, TValue, TSiblingData> &\n    BeforeChangeRichTextHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type BeforeValidateRichTextHook<\n  TData extends TypeWithID = any,\n  TValue = any,\n  TSiblingData = any,\n> = (\n  args: BaseRichTextHookArgs<TData, TValue, TSiblingData> &\n    BeforeValidateRichTextHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type RichTextHooks = {\n  afterChange?: AfterChangeRichTextHook[]\n  afterRead?: AfterReadRichTextHook[]\n  beforeChange?: BeforeChangeRichTextHook[]\n  beforeValidate?: BeforeValidateRichTextHook[]\n}\n\ntype RichTextAdapterBase<\n  Value extends object = object,\n  AdapterProps = any,\n  ExtraFieldProperties = {},\n> = {\n  /**\n   * Provide a function that can be used to add items to the import map. This is useful for\n   * making modules available to the client.\n   */\n  generateImportMap?: ImportMapGenerators[0]\n  /**\n   * Provide a function that can be used to add items to the schema map. This is useful for\n   * richtext sub-fields the server needs to \"know\" about in order to do things like calculate form state.\n   *\n   * This function is run within `buildFieldSchemaMap`.\n   */\n  generateSchemaMap?: (args: {\n    config: SanitizedConfig\n    field: RichTextField\n    i18n: I18n<any, any>\n    schemaMap: FieldSchemaMap\n    schemaPath: string\n  }) => FieldSchemaMap\n  /**\n   * Like an afterRead hook, but runs only for the GraphQL resolver. For populating data, this should be used, as afterRead hooks do not have a depth in graphQL.\n   *\n   * To populate stuff / resolve field hooks, mutate the incoming populationPromises or fieldPromises array. They will then be awaited in the correct order within payload itself.\n   * @param data\n   */\n  graphQLPopulationPromises?: (data: {\n    context: RequestContext\n    currentDepth?: number\n    depth: number\n    draft: boolean\n    field: RichTextField<Value, AdapterProps, ExtraFieldProperties>\n    fieldPromises: Promise<void>[]\n    findMany: boolean\n    flattenLocales: boolean\n    overrideAccess?: boolean\n    parentIsLocalized: boolean\n    populateArg?: PopulateType\n    populationPromises: Promise<void>[]\n    req: PayloadRequest\n    showHiddenFields: boolean\n    siblingDoc: JsonObject\n  }) => void\n  hooks?: RichTextHooks\n  /**\n   * @deprecated - manually merge i18n translations into the config.i18n.translations object within the adapter provider instead.\n   * This property will be removed in v4.\n   */\n  i18n?: Partial<GenericLanguages>\n  /**\n   * Return the JSON schema for the field value. The JSON schema is read by\n   * `json-schema-to-typescript` which is used to generate types for this richtext field\n   * payload-types.ts)\n   */\n  outputSchema?: (args: {\n    collectionIDFieldTypes: { [key: string]: 'number' | 'string' }\n    config?: SanitizedConfig\n    field: RichTextField<Value, AdapterProps, ExtraFieldProperties>\n    i18n?: I18n\n    /**\n     * Allows you to define new top-level interfaces that can be re-used in the output schema.\n     */\n    interfaceNameDefinitions: Map<string, JSONSchema4>\n    isRequired: boolean\n  }) => JSONSchema4\n  /**\n   * Provide validation function for the richText field. This function is run the same way\n   * as other field validation functions.\n   */\n  validate: Validate<\n    Value,\n    Value,\n    unknown,\n    RichTextField<Value, AdapterProps, ExtraFieldProperties>\n  >\n}\n\nexport type RichTextAdapter<\n  Value extends object = any,\n  AdapterProps = any,\n  ExtraFieldProperties = any,\n> = {\n  /**\n   * Component that will be displayed in the list view. Can be typed as\n   * `DefaultCellComponentProps` or `DefaultServerCellComponentProps`.\n   */\n  CellComponent: PayloadComponent<never>\n  /**\n   * Component that will be displayed in the version diff view.\n   * If not provided, richtext content will be diffed as JSON.\n   */\n  DiffComponent?: PayloadComponent<\n    FieldDiffServerProps<RichTextField, RichTextFieldClient>,\n    FieldDiffClientProps<RichTextFieldClient>\n  >\n  /**\n   * Component that will be displayed in the edit view.\n   */\n  FieldComponent: PayloadComponent<RichTextFieldServerProps, RichTextFieldClientProps>\n} & RichTextAdapterBase<Value, AdapterProps, ExtraFieldProperties>\n\nexport type RichTextAdapterProvider<\n  Value extends object = object,\n  AdapterProps = any,\n  ExtraFieldProperties = {},\n> = ({\n  config,\n  isRoot,\n  parentIsLocalized,\n}: {\n  config: SanitizedConfig\n  /**\n   * Whether or not this is the root richText editor, defined in the top-level `editor` property\n   * of the Payload Config.\n   *\n   * @default false\n   */\n  isRoot?: boolean\n  parentIsLocalized: boolean\n}) =>\n  | Promise<RichTextAdapter<Value, AdapterProps, ExtraFieldProperties>>\n  | RichTextAdapter<Value, AdapterProps, ExtraFieldProperties>\n"],"names":[],"mappings":"AAAA,qDAAqD,GA+SrD,WAoB8D"}