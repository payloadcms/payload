{"version":3,"sources":["../../src/uploads/getRangeRequestInfo.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport { parseRangeHeader } from './parseRangeHeader.js'\n\nexport type RangeRequestResult =\n  | {\n      headers: {\n        'Accept-Ranges': string\n        'Content-Length': string\n        'Content-Range'?: string\n      }\n      rangeEnd: number\n      rangeStart: number\n      status: 206\n      type: 'partial'\n    }\n  | {\n      headers: {\n        'Accept-Ranges': string\n        'Content-Length': string\n      }\n      status: 200\n      type: 'full'\n    }\n  | {\n      headers: {\n        'Content-Range': string\n      }\n      status: 416\n      type: 'invalid'\n    }\n\n/**\n * Gets HTTP Range request information according to RFC 7233\n *\n * @param fileSize - The total size of the file in bytes\n * @param rangeHeader - The Range header value from the request (e.g., \"bytes=0-1023\")\n * @returns Result object with headers and status code for the response\n */\nexport function getRangeRequestInfo({\n  fileSize,\n  rangeHeader,\n}: {\n  fileSize: number\n  rangeHeader: null | string\n}): RangeRequestResult {\n  // Parse the Range header\n  const rangeResult = parseRangeHeader({\n    fileSize,\n    rangeHeader,\n  })\n\n  // Handle invalid range\n  if (rangeResult.type === 'invalid') {\n    return {\n      type: 'invalid',\n      headers: {\n        'Content-Range': `bytes */${fileSize}`,\n      },\n      status: httpStatus.REQUESTED_RANGE_NOT_SATISFIABLE,\n    }\n  }\n\n  // Handle partial range request\n  if (rangeResult.type === 'partial' && rangeResult.range) {\n    const { end, start } = rangeResult.range\n    const contentLength = end - start + 1\n\n    return {\n      type: 'partial',\n      headers: {\n        'Accept-Ranges': 'bytes',\n        'Content-Length': String(contentLength),\n        'Content-Range': `bytes ${start}-${end}/${fileSize}`,\n      },\n      rangeEnd: end,\n      rangeStart: start,\n      status: httpStatus.PARTIAL_CONTENT,\n    }\n  }\n\n  // Handle full file request (no range or invalid)\n  return {\n    type: 'full',\n    headers: {\n      'Accept-Ranges': 'bytes',\n      'Content-Length': String(fileSize),\n    },\n    status: httpStatus.OK,\n  }\n}\n"],"names":["status","httpStatus","parseRangeHeader","getRangeRequestInfo","fileSize","rangeHeader","rangeResult","type","headers","REQUESTED_RANGE_NOT_SATISFIABLE","range","end","start","contentLength","String","rangeEnd","rangeStart","PARTIAL_CONTENT","OK"],"mappings":"AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAElD,SAASC,gBAAgB,QAAQ,wBAAuB;AA8BxD;;;;;;CAMC,GACD,OAAO,SAASC,oBAAoB,EAClCC,QAAQ,EACRC,WAAW,EAIZ;IACC,yBAAyB;IACzB,MAAMC,cAAcJ,iBAAiB;QACnCE;QACAC;IACF;IAEA,uBAAuB;IACvB,IAAIC,YAAYC,IAAI,KAAK,WAAW;QAClC,OAAO;YACLA,MAAM;YACNC,SAAS;gBACP,iBAAiB,CAAC,QAAQ,EAAEJ,UAAU;YACxC;YACAJ,QAAQC,WAAWQ,+BAA+B;QACpD;IACF;IAEA,+BAA+B;IAC/B,IAAIH,YAAYC,IAAI,KAAK,aAAaD,YAAYI,KAAK,EAAE;QACvD,MAAM,EAAEC,GAAG,EAAEC,KAAK,EAAE,GAAGN,YAAYI,KAAK;QACxC,MAAMG,gBAAgBF,MAAMC,QAAQ;QAEpC,OAAO;YACLL,MAAM;YACNC,SAAS;gBACP,iBAAiB;gBACjB,kBAAkBM,OAAOD;gBACzB,iBAAiB,CAAC,MAAM,EAAED,MAAM,CAAC,EAAED,IAAI,CAAC,EAAEP,UAAU;YACtD;YACAW,UAAUJ;YACVK,YAAYJ;YACZZ,QAAQC,WAAWgB,eAAe;QACpC;IACF;IAEA,iDAAiD;IACjD,OAAO;QACLV,MAAM;QACNC,SAAS;YACP,iBAAiB;YACjB,kBAAkBM,OAAOV;QAC3B;QACAJ,QAAQC,WAAWiB,EAAE;IACvB;AACF"}