{"version":3,"sources":["../../src/uploads/generateFileData.ts"],"sourcesContent":["import type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs/promises'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { Document, PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, Forbidden, MissingFile } from '../errors/index.js'\nimport { isNumber } from '../utilities/isNumber.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { checkFileRestrictions } from './checkFileRestrictions.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { createImageSizes } from './image-resizing/createImageSizes.js'\nimport { isImage } from './isImage.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc?: T\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nconst shouldReupload = (\n  uploadEdits: UploadEdits,\n  fileData: Record<string, unknown> | undefined,\n) => {\n  if (!fileData) {\n    return false\n  }\n\n  if (uploadEdits.crop || uploadEdits.heightInPixels || uploadEdits.widthInPixels) {\n    return true\n  }\n\n  // Since uploadEdits always has focalPoint, compare to the value in the data if it was changed\n  if (uploadEdits.focalPoint) {\n    const incomingFocalX = uploadEdits.focalPoint.x\n    const incomingFocalY = uploadEdits.focalPoint.y\n\n    const currentFocalX = 'focalX' in fileData && fileData.focalX\n    const currentFocalY = 'focalY' in fileData && fileData.focalY\n\n    const isEqual = incomingFocalX === currentFocalX && incomingFocalY === currentFocalY\n    return !isEqual\n  }\n\n  return false\n}\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  isDuplicating,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { serverURL, sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    isDuplicating,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    constructorOptions,\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n    withMetadata,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  const incomingFileData: Document = isDuplicating ? originalDoc : data\n  let isLocalFile = false\n\n  if (\n    !file &&\n    (isDuplicating || shouldReupload(uploadEdits, incomingFileData as Record<string, unknown>))\n  ) {\n    const { filename, url } = incomingFileData as unknown as FileData\n    if (filename && (filename.includes('../') || filename.includes('..\\\\'))) {\n      throw new Forbidden(req.t)\n    }\n\n    if ((serverURL && url?.startsWith(serverURL)) || url?.startsWith('/')) {\n      isLocalFile = true\n    }\n\n    try {\n      if (!disableLocalStorage && isLocalFile) {\n        // File is stored locally\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        overwriteExistingFiles = true\n      } else if (filename && url) {\n        // File is remote\n        file = await getExternalFile({\n          data: incomingFileData as unknown as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        overwriteExistingFiles = true\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (isDuplicating) {\n    overwriteExistingFiles = false\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) {\n      throw new MissingFile(req.t)\n    }\n\n    return {\n      data: incomingFileData!,\n      files: [],\n    }\n  }\n\n  await checkFileRestrictions({\n    collection: collectionConfig,\n    file,\n    req,\n  })\n\n  if (!disableLocalStorage) {\n    await fs.mkdir(staticPath!, { recursive: true })\n  }\n\n  let newData = incomingFileData as T\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer!: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(\n        resizeOptions || formatOptions || trimOptions || constructorOptions || file.tempFilePath,\n      )\n\n    const sharpOptions: SharpOptions = { ...constructorOptions }\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      sharpFile = await optionallyAppendMetadata({\n        req,\n        sharpFile,\n        withMetadata: withMetadata!,\n      })\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = (await fileTypeFromBuffer(fileBuffer.data))!) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop()?.split('?')[0]\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adjust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') {\n      mime = 'image/svg+xml'\n    }\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      // Extract prefix if present (added by plugin-cloud-storage)\n      const prefix = (data as Record<string, unknown>)?.prefix as string | undefined\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        prefix,\n        req,\n        staticPath: staticPath!,\n      })\n    }\n\n    fileData.filename = fsSafeName\n\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({\n        cropData,\n        dimensions: dimensions!,\n        file,\n        heightInPixels: uploadEdits.heightInPixels!,\n        req,\n        sharp,\n        widthInPixels: uploadEdits.widthInPixels!,\n        withMetadata,\n      })\n\n      // Apply resize after cropping to ensure it conforms to resizeOptions\n      if (resizeOptions && !resizeOptions.withoutEnlargement) {\n        const resizedAfterCrop = await sharp(croppedImage)\n          .resize({\n            fit: resizeOptions?.fit || 'cover',\n            height: resizeOptions?.height,\n            position: resizeOptions?.position || 'center',\n            width: resizeOptions?.width,\n          })\n          .toBuffer({ resolveWithObject: true })\n\n        filesToSave.push({\n          buffer: resizedAfterCrop.data,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...fileForResize,\n          data: resizedAfterCrop.data,\n          size: resizedAfterCrop.info.size,\n        }\n\n        fileData.width = resizedAfterCrop.info.width\n        fileData.height = resizedAfterCrop.info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages\n            ? resizedAfterCrop.info.height / metadata.pages\n            : resizedAfterCrop.info.height\n        }\n        fileData.filesize = resizedAfterCrop.info.size\n      } else {\n        // If resizeOptions is not present, just save the cropped image\n        filesToSave.push({\n          buffer: croppedImage,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...file,\n          data: croppedImage,\n          size: info.size,\n        }\n\n        fileData.width = info.width\n        fileData.height = info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile!.metadata()\n          fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n        }\n        fileData.filesize = info.size\n      }\n\n      if (file.tempFilePath) {\n        await fs.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      // Focal point adjustments\n      const focalPoint =\n        focalPointEnabled && uploadEdits?.focalPoint\n          ? {\n              x: isNumber(uploadEdits.focalPoint.x) ? Math.round(uploadEdits.focalPoint.x) : 50,\n              y: isNumber(uploadEdits.focalPoint.y) ? Math.round(uploadEdits.focalPoint.y) : 50,\n            }\n          : undefined\n\n      const { sizeData, sizesToSave } = await createImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions!\n          : {\n              ...dimensions,\n              height: fileData.height!,\n              width: fileData.width!,\n            },\n        file: fileForResize,\n        focalPoint,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath: staticPath!,\n        withMetadata,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequest\n}): UploadEdits {\n  const { data, isDuplicating, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const uploadEdits =\n    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'\n      ? (req.query.uploadEdits as UploadEdits)\n      : {}\n\n  if (uploadEdits.focalPoint) {\n    return uploadEdits\n  }\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {\n    // If no change in focal point, return undefined.\n    // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n    if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n      return undefined!\n    }\n\n    if (isDuplicating) {\n      uploadEdits.focalPoint = {\n        x: incomingData?.focalX || origDoc.focalX!,\n        y: incomingData?.focalY || origDoc.focalY!,\n      }\n      return uploadEdits\n    }\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","FileRetrievalError","FileUploadError","Forbidden","MissingFile","isNumber","canResizeImage","checkFileRestrictions","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","createImageSizes","isImage","optionallyAppendMetadata","shouldReupload","uploadEdits","fileData","crop","heightInPixels","widthInPixels","focalPoint","incomingFocalX","x","incomingFocalY","y","currentFocalX","focalX","currentFocalY","focalY","isEqual","generateFileData","collection","config","collectionConfig","data","isDuplicating","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","serverURL","sharp","payload","file","parseUploadEditsFromReqOrIncomingData","constructorOptions","disableLocalStorage","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","withMetadata","staticPath","incomingFileData","isLocalFile","filename","url","includes","t","startsWith","filePath","response","uploadConfig","err","Error","message","undefined","mkdir","recursive","newData","filesToSave","fileIsAnimatedType","mimetype","cropData","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","prefix","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","withoutEnlargement","resizedAfterCrop","fit","position","push","buffer","path","writeFile","Array","isArray","payloadUploadSizes","Math","round","sizeData","sizesToSave","savedFilename","sizes","logger","error","args","query","incomingData","origDoc"],"mappings":"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"}