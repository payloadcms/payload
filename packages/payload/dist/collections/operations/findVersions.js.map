{"version":3,"sources":["../../../src/collections/operations/findVersions.ts"],"sourcesContent":["import type { AccessResult } from '../../config/types.js'\nimport type { PaginatedDocs } from '../../database/types.js'\nimport type { PayloadRequest, PopulateType, SelectType, Sort, Where } from '../../types/index.js'\nimport type { TypeWithVersion } from '../../versions/types.js'\nimport type { Collection } from '../config/types.js'\n\nimport { executeAccess } from '../../auth/executeAccess.js'\nimport { combineQueries } from '../../database/combineQueries.js'\nimport { validateQueryPaths } from '../../database/queryValidation/validateQueryPaths.js'\nimport { sanitizeWhereQuery } from '../../database/sanitizeWhereQuery.js'\nimport { afterRead } from '../../fields/hooks/afterRead/index.js'\nimport { appendNonTrashedFilter } from '../../utilities/appendNonTrashedFilter.js'\nimport { killTransaction } from '../../utilities/killTransaction.js'\nimport { sanitizeInternalFields } from '../../utilities/sanitizeInternalFields.js'\nimport { sanitizeSelect } from '../../utilities/sanitizeSelect.js'\nimport { buildVersionCollectionFields } from '../../versions/buildCollectionFields.js'\nimport { getQueryDraftsSelect } from '../../versions/drafts/getQueryDraftsSelect.js'\nimport { buildAfterOperation } from './utilities/buildAfterOperation.js'\nimport { buildBeforeOperation } from './utilities/buildBeforeOperation.js'\n\nexport type Arguments = {\n  collection: Collection\n  depth?: number\n  limit?: number\n  overrideAccess?: boolean\n  page?: number\n  pagination?: boolean\n  populate?: PopulateType\n  req?: PayloadRequest\n  select?: SelectType\n  showHiddenFields?: boolean\n  sort?: Sort\n  trash?: boolean\n  where?: Where\n}\n\nexport const findVersionsOperation = async <TData extends TypeWithVersion<TData>>(\n  args: Arguments,\n): Promise<PaginatedDocs<TData>> => {\n  try {\n    // /////////////////////////////////////\n    // beforeOperation - Collection\n    // /////////////////////////////////////\n\n    args = await buildBeforeOperation({\n      args,\n      collection: args.collection.config,\n      operation: 'findVersions',\n    })\n\n    const {\n      collection: { config: collectionConfig },\n      depth,\n      limit,\n      overrideAccess,\n      page,\n      pagination = true,\n      populate,\n      select: incomingSelect,\n      showHiddenFields,\n      sort,\n      trash = false,\n      where,\n    } = args\n\n    const req = args.req!\n    const { fallbackLocale, locale, payload } = req\n\n    // /////////////////////////////////////\n    // Access\n    // /////////////////////////////////////\n\n    let accessResults!: AccessResult\n\n    if (!overrideAccess) {\n      accessResults = await executeAccess({ req }, collectionConfig.access.readVersions)\n    }\n\n    const versionFields = buildVersionCollectionFields(payload.config, collectionConfig, true)\n\n    await validateQueryPaths({\n      collectionConfig,\n      overrideAccess: overrideAccess!,\n      req,\n      versionFields,\n      where: where!,\n    })\n\n    let fullWhere = combineQueries(where!, accessResults)\n\n    // Exclude trashed documents when trash: false\n    fullWhere = appendNonTrashedFilter({\n      deletedAtPath: 'version.deletedAt',\n      enableTrash: collectionConfig.trash,\n      trash,\n      where: fullWhere,\n    })\n\n    sanitizeWhereQuery({ fields: versionFields, payload, where: fullWhere })\n\n    const select = sanitizeSelect({\n      fields: versionFields,\n      forceSelect: getQueryDraftsSelect({ select: collectionConfig.forceSelect }),\n      select: incomingSelect,\n      versions: true,\n    })\n\n    // /////////////////////////////////////\n    // Find\n    // /////////////////////////////////////\n\n    const usePagination = pagination && limit !== 0\n    const sanitizedLimit = limit ?? (usePagination ? 10 : 0)\n    const sanitizedPage = page || 1\n\n    const paginatedDocs = await payload.db.findVersions<TData>({\n      collection: collectionConfig.slug,\n      limit: sanitizedLimit,\n      locale: locale!,\n      page: sanitizedPage,\n      pagination,\n      req,\n      select,\n      sort,\n      where: fullWhere,\n    })\n\n    // /////////////////////////////////////\n    // beforeRead - Collection\n    // /////////////////////////////////////\n    let result: PaginatedDocs<TData> = paginatedDocs as unknown as PaginatedDocs<TData>\n    result.docs = (await Promise.all(\n      paginatedDocs.docs.map(async (doc) => {\n        const docRef = doc\n        // Fallback if not selected\n        if (!docRef.version) {\n          ;(docRef as any).version = {}\n        }\n\n        if (collectionConfig.hooks?.beforeRead?.length) {\n          for (const hook of collectionConfig.hooks.beforeRead) {\n            docRef.version =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: docRef.version,\n                query: fullWhere,\n                req,\n              })) || docRef.version\n          }\n        }\n\n        return docRef\n      }),\n    )) as TData[]\n    // /////////////////////////////////////\n    // afterRead - Fields\n    // /////////////////////////////////////\n\n    result.docs = await Promise.all(\n      result.docs.map(async (data) => {\n        data.version = await afterRead({\n          collection: collectionConfig,\n          context: req.context,\n          depth: depth!,\n          doc: data.version,\n          // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n          draft: undefined,\n          fallbackLocale: fallbackLocale!,\n          findMany: true,\n          global: null,\n          locale: locale!,\n          overrideAccess: overrideAccess!,\n          populate,\n          req,\n          select: typeof select?.version === 'object' ? select.version : undefined,\n          showHiddenFields: showHiddenFields!,\n        })\n        return data\n      }),\n    )\n\n    // /////////////////////////////////////\n    // afterRead - Collection\n    // /////////////////////////////////////\n\n    if (collectionConfig.hooks.afterRead?.length) {\n      result.docs = await Promise.all(\n        result.docs.map(async (doc) => {\n          const docRef = doc\n\n          for (const hook of collectionConfig.hooks.afterRead) {\n            docRef.version =\n              (await hook({\n                collection: collectionConfig,\n                context: req.context,\n                doc: doc.version,\n                findMany: true,\n                query: fullWhere,\n                req,\n              })) || doc.version\n          }\n\n          return docRef\n        }),\n      )\n    }\n\n    // /////////////////////////////////////\n    // Return results\n    // /////////////////////////////////////\n    result.docs = result.docs.map((doc) => sanitizeInternalFields<TData>(doc))\n\n    // /////////////////////////////////////\n    // afterOperation - Collection\n    // /////////////////////////////////////\n\n    result = await buildAfterOperation({\n      args,\n      collection: collectionConfig,\n      operation: 'findVersions',\n      result,\n    })\n\n    return result\n  } catch (error: unknown) {\n    await killTransaction(args.req!)\n    throw error\n  }\n}\n"],"names":["executeAccess","combineQueries","validateQueryPaths","sanitizeWhereQuery","afterRead","appendNonTrashedFilter","killTransaction","sanitizeInternalFields","sanitizeSelect","buildVersionCollectionFields","getQueryDraftsSelect","buildAfterOperation","buildBeforeOperation","findVersionsOperation","args","collection","config","operation","collectionConfig","depth","limit","overrideAccess","page","pagination","populate","select","incomingSelect","showHiddenFields","sort","trash","where","req","fallbackLocale","locale","payload","accessResults","access","readVersions","versionFields","fullWhere","deletedAtPath","enableTrash","fields","forceSelect","versions","usePagination","sanitizedLimit","sanitizedPage","paginatedDocs","db","findVersions","slug","result","docs","Promise","all","map","doc","docRef","version","hooks","beforeRead","length","hook","context","query","data","draft","undefined","findMany","global","error"],"mappings":"AAMA,SAASA,aAAa,QAAQ,8BAA6B;AAC3D,SAASC,cAAc,QAAQ,mCAAkC;AACjE,SAASC,kBAAkB,QAAQ,uDAAsD;AACzF,SAASC,kBAAkB,QAAQ,uCAAsC;AACzE,SAASC,SAAS,QAAQ,wCAAuC;AACjE,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,eAAe,QAAQ,qCAAoC;AACpE,SAASC,sBAAsB,QAAQ,4CAA2C;AAClF,SAASC,cAAc,QAAQ,oCAAmC;AAClE,SAASC,4BAA4B,QAAQ,0CAAyC;AACtF,SAASC,oBAAoB,QAAQ,gDAA+C;AACpF,SAASC,mBAAmB,QAAQ,qCAAoC;AACxE,SAASC,oBAAoB,QAAQ,sCAAqC;AAkB1E,OAAO,MAAMC,wBAAwB,OACnCC;IAEA,IAAI;QACF,wCAAwC;QACxC,+BAA+B;QAC/B,wCAAwC;QAExCA,OAAO,MAAMF,qBAAqB;YAChCE;YACAC,YAAYD,KAAKC,UAAU,CAACC,MAAM;YAClCC,WAAW;QACb;QAEA,MAAM,EACJF,YAAY,EAAEC,QAAQE,gBAAgB,EAAE,EACxCC,KAAK,EACLC,KAAK,EACLC,cAAc,EACdC,IAAI,EACJC,aAAa,IAAI,EACjBC,QAAQ,EACRC,QAAQC,cAAc,EACtBC,gBAAgB,EAChBC,IAAI,EACJC,QAAQ,KAAK,EACbC,KAAK,EACN,GAAGhB;QAEJ,MAAMiB,MAAMjB,KAAKiB,GAAG;QACpB,MAAM,EAAEC,cAAc,EAAEC,MAAM,EAAEC,OAAO,EAAE,GAAGH;QAE5C,wCAAwC;QACxC,SAAS;QACT,wCAAwC;QAExC,IAAII;QAEJ,IAAI,CAACd,gBAAgB;YACnBc,gBAAgB,MAAMnC,cAAc;gBAAE+B;YAAI,GAAGb,iBAAiBkB,MAAM,CAACC,YAAY;QACnF;QAEA,MAAMC,gBAAgB7B,6BAA6ByB,QAAQlB,MAAM,EAAEE,kBAAkB;QAErF,MAAMhB,mBAAmB;YACvBgB;YACAG,gBAAgBA;YAChBU;YACAO;YACAR,OAAOA;QACT;QAEA,IAAIS,YAAYtC,eAAe6B,OAAQK;QAEvC,8CAA8C;QAC9CI,YAAYlC,uBAAuB;YACjCmC,eAAe;YACfC,aAAavB,iBAAiBW,KAAK;YACnCA;YACAC,OAAOS;QACT;QAEApC,mBAAmB;YAAEuC,QAAQJ;YAAeJ;YAASJ,OAAOS;QAAU;QAEtE,MAAMd,SAASjB,eAAe;YAC5BkC,QAAQJ;YACRK,aAAajC,qBAAqB;gBAAEe,QAAQP,iBAAiByB,WAAW;YAAC;YACzElB,QAAQC;YACRkB,UAAU;QACZ;QAEA,wCAAwC;QACxC,OAAO;QACP,wCAAwC;QAExC,MAAMC,gBAAgBtB,cAAcH,UAAU;QAC9C,MAAM0B,iBAAiB1B,SAAUyB,CAAAA,gBAAgB,KAAK,CAAA;QACtD,MAAME,gBAAgBzB,QAAQ;QAE9B,MAAM0B,gBAAgB,MAAMd,QAAQe,EAAE,CAACC,YAAY,CAAQ;YACzDnC,YAAYG,iBAAiBiC,IAAI;YACjC/B,OAAO0B;YACPb,QAAQA;YACRX,MAAMyB;YACNxB;YACAQ;YACAN;YACAG;YACAE,OAAOS;QACT;QAEA,wCAAwC;QACxC,0BAA0B;QAC1B,wCAAwC;QACxC,IAAIa,SAA+BJ;QACnCI,OAAOC,IAAI,GAAI,MAAMC,QAAQC,GAAG,CAC9BP,cAAcK,IAAI,CAACG,GAAG,CAAC,OAAOC;YAC5B,MAAMC,SAASD;YACf,2BAA2B;YAC3B,IAAI,CAACC,OAAOC,OAAO,EAAE;;gBACjBD,OAAeC,OAAO,GAAG,CAAC;YAC9B;YAEA,IAAIzC,iBAAiB0C,KAAK,EAAEC,YAAYC,QAAQ;gBAC9C,KAAK,MAAMC,QAAQ7C,iBAAiB0C,KAAK,CAACC,UAAU,CAAE;oBACpDH,OAAOC,OAAO,GACZ,AAAC,MAAMI,KAAK;wBACVhD,YAAYG;wBACZ8C,SAASjC,IAAIiC,OAAO;wBACpBP,KAAKC,OAAOC,OAAO;wBACnBM,OAAO1B;wBACPR;oBACF,MAAO2B,OAAOC,OAAO;gBACzB;YACF;YAEA,OAAOD;QACT;QAEF,wCAAwC;QACxC,qBAAqB;QACrB,wCAAwC;QAExCN,OAAOC,IAAI,GAAG,MAAMC,QAAQC,GAAG,CAC7BH,OAAOC,IAAI,CAACG,GAAG,CAAC,OAAOU;YACrBA,KAAKP,OAAO,GAAG,MAAMvD,UAAU;gBAC7BW,YAAYG;gBACZ8C,SAASjC,IAAIiC,OAAO;gBACpB7C,OAAOA;gBACPsC,KAAKS,KAAKP,OAAO;gBACjB,oFAAoF;gBACpFQ,OAAOC;gBACPpC,gBAAgBA;gBAChBqC,UAAU;gBACVC,QAAQ;gBACRrC,QAAQA;gBACRZ,gBAAgBA;gBAChBG;gBACAO;gBACAN,QAAQ,OAAOA,QAAQkC,YAAY,WAAWlC,OAAOkC,OAAO,GAAGS;gBAC/DzC,kBAAkBA;YACpB;YACA,OAAOuC;QACT;QAGF,wCAAwC;QACxC,yBAAyB;QACzB,wCAAwC;QAExC,IAAIhD,iBAAiB0C,KAAK,CAACxD,SAAS,EAAE0D,QAAQ;YAC5CV,OAAOC,IAAI,GAAG,MAAMC,QAAQC,GAAG,CAC7BH,OAAOC,IAAI,CAACG,GAAG,CAAC,OAAOC;gBACrB,MAAMC,SAASD;gBAEf,KAAK,MAAMM,QAAQ7C,iBAAiB0C,KAAK,CAACxD,SAAS,CAAE;oBACnDsD,OAAOC,OAAO,GACZ,AAAC,MAAMI,KAAK;wBACVhD,YAAYG;wBACZ8C,SAASjC,IAAIiC,OAAO;wBACpBP,KAAKA,IAAIE,OAAO;wBAChBU,UAAU;wBACVJ,OAAO1B;wBACPR;oBACF,MAAO0B,IAAIE,OAAO;gBACtB;gBAEA,OAAOD;YACT;QAEJ;QAEA,wCAAwC;QACxC,iBAAiB;QACjB,wCAAwC;QACxCN,OAAOC,IAAI,GAAGD,OAAOC,IAAI,CAACG,GAAG,CAAC,CAACC,MAAQlD,uBAA8BkD;QAErE,wCAAwC;QACxC,8BAA8B;QAC9B,wCAAwC;QAExCL,SAAS,MAAMzC,oBAAoB;YACjCG;YACAC,YAAYG;YACZD,WAAW;YACXmC;QACF;QAEA,OAAOA;IACT,EAAE,OAAOmB,OAAgB;QACvB,MAAMjE,gBAAgBQ,KAAKiB,GAAG;QAC9B,MAAMwC;IACR;AACF,EAAC"}