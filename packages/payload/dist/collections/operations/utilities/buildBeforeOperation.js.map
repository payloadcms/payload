{"version":3,"sources":["../../../../src/collections/operations/utilities/buildBeforeOperation.ts"],"sourcesContent":["import type { CollectionSlug } from '../../../index.js'\nimport type { BeforeOperationArg, OperationArgs, OperationMap } from './types.js'\n\nimport { operationToHookOperation } from './types.js'\n// Specific overloads with TArgs (these take priority over the general overload)\n// Overload for 'read' operation (deprecated, backward compatibility)\n\n/**\n * TODO V4: remove overloads and operations should be the literal operation that was called\n *\n * - `read`: replace with `find` and `findByID` in both operations\n * - `delete`: replace with `deleteByID` in deleteByID operation\n * - `update`: replace with `updateByID` in updateByID operation\n */\n\n/**\n * @deprecated\n *\n * Should use `find` or `findByID`\n */\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'read'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n/**\n * Overload for 'readDistinct' operation\n *\n * @deprecated - use `findDistinct`\n */\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'readDistinct'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n// Overload for 'update' operation (can be called by both update and updateByID)\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'update'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n// Overload for 'updateByID' operation\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'updateByID'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'delete'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n// Overload for 'deleteByID' operation\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug, TArgs>(\n  operationArgs: {\n    args: TArgs\n    operation: 'deleteByID'\n  } & Omit<BeforeOperationArg<TOperationGeneric>, 'args' | 'context' | 'operation' | 'req'>,\n): Promise<TArgs>\n\n// General overload for operations that exist in OperationMap (fallback)\nexport async function buildBeforeOperation<\n  TOperationGeneric extends CollectionSlug,\n  O extends keyof OperationMap<TOperationGeneric>,\n>(\n  operationArgs: { operation: O } & Omit<BeforeOperationArg<TOperationGeneric>, 'context' | 'req'>,\n): Promise<OperationArgs<TOperationGeneric, O>>\n\n// Implementation\nexport async function buildBeforeOperation<TOperationGeneric extends CollectionSlug>(\n  operationArgs: Omit<BeforeOperationArg<TOperationGeneric>, 'context' | 'req'>,\n): Promise<unknown> {\n  const { args, collection, operation } = operationArgs\n\n  let newArgs = args\n\n  if (args.collection.config.hooks?.beforeOperation?.length) {\n    // TODO: v4 should not need this mapping\n    // Map the operation to the hook operation type for backward compatibility\n    const hookOperation = operationToHookOperation[operation]\n\n    for (const hook of args.collection.config.hooks.beforeOperation) {\n      const hookResult = await hook({\n        args: newArgs,\n        collection,\n        context: args.req!.context,\n        operation: hookOperation,\n        req: args.req!,\n      } as BeforeOperationArg<TOperationGeneric>)\n\n      if (hookResult !== undefined) {\n        newArgs = hookResult\n      }\n    }\n  }\n\n  return newArgs\n}\n"],"names":["operationToHookOperation","buildBeforeOperation","operationArgs","args","collection","operation","newArgs","config","hooks","beforeOperation","length","hookOperation","hook","hookResult","context","req","undefined"],"mappings":"AAGA,SAASA,wBAAwB,QAAQ,aAAY;AA2ErD,iBAAiB;AACjB,OAAO,eAAeC,qBACpBC,aAA6E;IAE7E,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,SAAS,EAAE,GAAGH;IAExC,IAAII,UAAUH;IAEd,IAAIA,KAAKC,UAAU,CAACG,MAAM,CAACC,KAAK,EAAEC,iBAAiBC,QAAQ;QACzD,wCAAwC;QACxC,0EAA0E;QAC1E,MAAMC,gBAAgBX,wBAAwB,CAACK,UAAU;QAEzD,KAAK,MAAMO,QAAQT,KAAKC,UAAU,CAACG,MAAM,CAACC,KAAK,CAACC,eAAe,CAAE;YAC/D,MAAMI,aAAa,MAAMD,KAAK;gBAC5BT,MAAMG;gBACNF;gBACAU,SAASX,KAAKY,GAAG,CAAED,OAAO;gBAC1BT,WAAWM;gBACXI,KAAKZ,KAAKY,GAAG;YACf;YAEA,IAAIF,eAAeG,WAAW;gBAC5BV,UAAUO;YACZ;QACF;IACF;IAEA,OAAOP;AACT"}