{"version":3,"sources":["../../../src/database/queryValidation/validateQueryPaths.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../collections/config/types.js'\nimport type { FlattenedField } from '../../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type { Operator, PayloadRequest, Where, WhereField } from '../../types/index.js'\nimport type { EntityPolicies } from './types.js'\n\nimport { QueryError } from '../../errors/QueryError.js'\nimport { validOperatorSet } from '../../types/constants.js'\nimport { validateSearchParam } from './validateSearchParams.js'\n\ntype Args = {\n  errors?: { path: string }[]\n  overrideAccess: boolean\n  // TODO: Rename to permissions or entityPermissions in 4.0\n  policies?: EntityPolicies\n  polymorphicJoin?: boolean\n  req: PayloadRequest\n  versionFields?: FlattenedField[]\n  where: Where\n} & (\n  | {\n      collectionConfig: SanitizedCollectionConfig\n      globalConfig?: never | undefined\n    }\n  | {\n      collectionConfig?: never | undefined\n      globalConfig: SanitizedGlobalConfig\n    }\n)\n\nexport async function validateQueryPaths({\n  collectionConfig,\n  errors = [],\n  globalConfig,\n  overrideAccess,\n  policies = {\n    collections: {},\n    globals: {},\n  },\n  polymorphicJoin,\n  req,\n  versionFields,\n  where,\n}: Args): Promise<void> {\n  const fields = versionFields || (globalConfig || collectionConfig).flattenedFields\n\n  if (typeof where === 'object') {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    const promises: Promise<void>[] = []\n    for (const path in where) {\n      const constraint = where[path]\n\n      if ((path === 'and' || path === 'or') && Array.isArray(constraint)) {\n        for (const item of constraint) {\n          if (collectionConfig) {\n            promises.push(\n              validateQueryPaths({\n                collectionConfig,\n                errors,\n                overrideAccess,\n                policies,\n                polymorphicJoin,\n                req,\n                versionFields,\n                where: item,\n              }),\n            )\n          } else {\n            promises.push(\n              validateQueryPaths({\n                errors,\n                globalConfig,\n                overrideAccess,\n                policies,\n                polymorphicJoin,\n                req,\n                versionFields,\n                where: item,\n              }),\n            )\n          }\n        }\n      } else if (!Array.isArray(constraint)) {\n        for (const operator in constraint) {\n          const val = constraint[operator as keyof typeof constraint]\n          if (validOperatorSet.has(operator as Operator)) {\n            promises.push(\n              validateSearchParam({\n                collectionConfig,\n                constraint: where as WhereField,\n                errors,\n                fields,\n                globalConfig,\n                operator,\n                overrideAccess,\n                path,\n                policies,\n                polymorphicJoin,\n                req,\n                val,\n                versionFields,\n              }),\n            )\n          }\n        }\n      }\n    }\n\n    await Promise.all(promises)\n    if (errors.length > 0) {\n      throw new QueryError(errors)\n    }\n  }\n}\n"],"names":["QueryError","validOperatorSet","validateSearchParam","validateQueryPaths","collectionConfig","errors","globalConfig","overrideAccess","policies","collections","globals","polymorphicJoin","req","versionFields","where","fields","flattenedFields","promises","path","constraint","Array","isArray","item","push","operator","val","has","Promise","all","length"],"mappings":"AAMA,SAASA,UAAU,QAAQ,6BAA4B;AACvD,SAASC,gBAAgB,QAAQ,2BAA0B;AAC3D,SAASC,mBAAmB,QAAQ,4BAA2B;AAsB/D,OAAO,eAAeC,mBAAmB,EACvCC,gBAAgB,EAChBC,SAAS,EAAE,EACXC,YAAY,EACZC,cAAc,EACdC,WAAW;IACTC,aAAa,CAAC;IACdC,SAAS,CAAC;AACZ,CAAC,EACDC,eAAe,EACfC,GAAG,EACHC,aAAa,EACbC,KAAK,EACA;IACL,MAAMC,SAASF,iBAAiB,AAACP,CAAAA,gBAAgBF,gBAAe,EAAGY,eAAe;IAElF,IAAI,OAAOF,UAAU,UAAU;QAC7B,uEAAuE;QACvE,MAAMG,WAA4B,EAAE;QACpC,IAAK,MAAMC,QAAQJ,MAAO;YACxB,MAAMK,aAAaL,KAAK,CAACI,KAAK;YAE9B,IAAI,AAACA,CAAAA,SAAS,SAASA,SAAS,IAAG,KAAME,MAAMC,OAAO,CAACF,aAAa;gBAClE,KAAK,MAAMG,QAAQH,WAAY;oBAC7B,IAAIf,kBAAkB;wBACpBa,SAASM,IAAI,CACXpB,mBAAmB;4BACjBC;4BACAC;4BACAE;4BACAC;4BACAG;4BACAC;4BACAC;4BACAC,OAAOQ;wBACT;oBAEJ,OAAO;wBACLL,SAASM,IAAI,CACXpB,mBAAmB;4BACjBE;4BACAC;4BACAC;4BACAC;4BACAG;4BACAC;4BACAC;4BACAC,OAAOQ;wBACT;oBAEJ;gBACF;YACF,OAAO,IAAI,CAACF,MAAMC,OAAO,CAACF,aAAa;gBACrC,IAAK,MAAMK,YAAYL,WAAY;oBACjC,MAAMM,MAAMN,UAAU,CAACK,SAAoC;oBAC3D,IAAIvB,iBAAiByB,GAAG,CAACF,WAAuB;wBAC9CP,SAASM,IAAI,CACXrB,oBAAoB;4BAClBE;4BACAe,YAAYL;4BACZT;4BACAU;4BACAT;4BACAkB;4BACAjB;4BACAW;4BACAV;4BACAG;4BACAC;4BACAa;4BACAZ;wBACF;oBAEJ;gBACF;YACF;QACF;QAEA,MAAMc,QAAQC,GAAG,CAACX;QAClB,IAAIZ,OAAOwB,MAAM,GAAG,GAAG;YACrB,MAAM,IAAI7B,WAAWK;QACvB;IACF;AACF"}