{"version":3,"sources":["../../src/database/types.ts"],"sourcesContent":["import type { TypeWithID } from '../collections/config/types.js'\nimport type { CollectionSlug, GlobalSlug, Job } from '../index.js'\nimport type {\n  Document,\n  JoinQuery,\n  JsonObject,\n  Payload,\n  PayloadRequest,\n  SelectType,\n  Sort,\n  Where,\n} from '../types/index.js'\nimport type { TypeWithVersion } from '../versions/types.js'\n\nexport type { TypeWithVersion }\n\nexport interface BaseDatabaseAdapter {\n  allowIDOnCreate?: boolean\n  /**\n   * Start a transaction, requiring commitTransaction() to be called for any changes to be made.\n   * @returns an identifier for the transaction or null if one cannot be established\n   */\n  beginTransaction: BeginTransaction\n  /**\n   * When true, bulk operations will process documents one at a time\n   * in separate transactions instead of all at once in a single transaction.\n   * Useful for avoiding transaction limitations with large datasets.\n   *\n   * @default false\n   */\n  bulkOperationsSingleTransaction?: boolean\n\n  /**\n   * Persist the changes made since the start of the transaction.\n   */\n  commitTransaction: CommitTransaction\n\n  /**\n   * Open the connection to the database\n   */\n  connect?: Connect\n  count: Count\n  countGlobalVersions: CountGlobalVersions\n  countVersions: CountVersions\n\n  create: Create\n\n  createGlobal: CreateGlobal\n\n  createGlobalVersion: CreateGlobalVersion\n  /**\n   * Output a migration file\n   */\n  createMigration: CreateMigration\n\n  createVersion: CreateVersion\n\n  /**\n   * Specify if the ID is a text or number field by default within this database adapter.\n   */\n  defaultIDType: 'number' | 'text'\n\n  deleteMany: DeleteMany\n\n  deleteOne: DeleteOne\n  deleteVersions: DeleteVersions\n\n  /**\n   * Terminate the connection with the database\n   */\n  destroy?: Destroy\n\n  find: Find\n\n  findDistinct: FindDistinct\n\n  findGlobal: FindGlobal\n\n  findGlobalVersions: FindGlobalVersions\n\n  findOne: FindOne\n\n  findVersions: FindVersions\n\n  generateSchema?: GenerateSchema\n\n  /**\n   * Perform startup tasks required to interact with the database such as building Schema and models\n   */\n  init?: Init\n\n  /**\n   * Run any migration up functions that have not yet been performed and update the status\n   */\n  migrate: (args?: { migrations?: Migration[] }) => Promise<void>\n  /**\n   * Run any migration down functions that have been performed\n   */\n  migrateDown: () => Promise<void>\n\n  /**\n   * Drop the current database and run all migrate up functions\n   */\n  migrateFresh: (args: { forceAcceptWarning?: boolean }) => Promise<void>\n  /**\n   * Run all migration down functions before running up\n   */\n  migrateRefresh: () => Promise<void>\n  /**\n   * Run all migrate down functions\n   */\n  migrateReset: () => Promise<void>\n  /**\n   * Read the current state of migrations and output the result to show which have been run\n   */\n  migrateStatus: () => Promise<void>\n\n  /**\n   * Path to read and write migration files from\n   */\n  migrationDir: string\n\n  /**\n   * The name of the database adapter\n   */\n  name: string\n  /**\n   * Full package name of the database adapter\n   *\n   * @example @payloadcms/db-postgres\n   */\n  packageName: string\n  /**\n   * reference to the instance of payload\n   */\n  payload: Payload\n\n  queryDrafts: QueryDrafts\n\n  /**\n   * Abort any changes since the start of the transaction.\n   */\n  rollbackTransaction: RollbackTransaction\n\n  /**\n   * A key-value store of all sessions open (used for transactions)\n   */\n  sessions?: {\n    [id: string]: {\n      db: unknown\n      reject: () => Promise<void>\n      resolve: () => Promise<void>\n    }\n  }\n\n  /**\n   * Updates a global that exists. If the global doesn't exist yet, this will not work - you should use `createGlobal` instead.\n   */\n  updateGlobal: UpdateGlobal\n\n  updateGlobalVersion: UpdateGlobalVersion\n\n  updateJobs: UpdateJobs\n\n  updateMany: UpdateMany\n\n  updateOne: UpdateOne\n  updateVersion: UpdateVersion\n  upsert: Upsert\n}\n\nexport type Init = () => Promise<void> | void\n\ntype ConnectArgs = {\n  hotReload: boolean\n}\n\nexport type Connect = (args?: ConnectArgs) => Promise<void>\n\nexport type Destroy = () => Promise<void>\n\nexport type CreateMigration = (args: {\n  file?: string\n  forceAcceptWarning?: boolean\n  migrationName?: string\n  payload: Payload\n  /**\n   * Skips the prompt asking to create empty migrations\n   */\n  skipEmpty?: boolean\n}) => Promise<void> | void\n\nexport type Transaction = (\n  callback: () => Promise<void>,\n  options?: Record<string, unknown>,\n) => Promise<void>\n\nexport type BeginTransaction = (\n  options?: Record<string, unknown>,\n) => Promise<null | number | string>\n\nexport type RollbackTransaction = (id: number | Promise<number | string> | string) => Promise<void>\n\nexport type CommitTransaction = (id: number | Promise<number | string> | string) => Promise<void>\n\nexport type QueryDraftsArgs = {\n  collection: CollectionSlug\n  joins?: JoinQuery\n  limit?: number\n  locale?: string\n  page?: number\n  pagination?: boolean\n  req?: Partial<PayloadRequest>\n  select?: SelectType\n  sort?: Sort\n  where?: Where\n}\n\nexport type QueryDrafts = <T = TypeWithID>(args: QueryDraftsArgs) => Promise<PaginatedDocs<T>>\n\nexport type FindOneArgs = {\n  collection: CollectionSlug\n  draftsEnabled?: boolean\n  joins?: JoinQuery\n  locale?: string\n  req?: Partial<PayloadRequest>\n  select?: SelectType\n  where?: Where\n}\n\nexport type FindOne = <T extends TypeWithID>(args: FindOneArgs) => Promise<null | T>\n\nexport type FindArgs = {\n  collection: CollectionSlug\n  draftsEnabled?: boolean\n  joins?: JoinQuery\n  /** Setting limit to 1 is equal to the previous Model.findOne(). Setting limit to 0 disables the limit */\n  limit?: number\n  locale?: string\n  page?: number\n  pagination?: boolean\n  projection?: Record<string, unknown>\n  req?: Partial<PayloadRequest>\n  select?: SelectType\n  /**\n   * @deprecated This parameter is going to be removed in the next major version. Use page instead.\n   */\n  skip?: number\n  sort?: Sort\n  versions?: boolean\n  where?: Where\n}\n\nexport type Find = <T = TypeWithID>(args: FindArgs) => Promise<PaginatedDocs<T>>\n\nexport type CountArgs = {\n  collection: CollectionSlug\n  locale?: string\n  req?: Partial<PayloadRequest>\n  where?: Where\n}\n\nexport type Count = (args: CountArgs) => Promise<{ totalDocs: number }>\n\nexport type CountVersions = (args: CountArgs) => Promise<{ totalDocs: number }>\n\nexport type CountGlobalVersionArgs = {\n  global: string\n  locale?: string\n  req?: Partial<PayloadRequest>\n  where?: Where\n}\n\nexport type CountGlobalVersions = (args: CountGlobalVersionArgs) => Promise<{ totalDocs: number }>\n\ntype BaseVersionArgs = {\n  limit?: number\n  locale?: string\n  page?: number\n  pagination?: boolean\n  req?: Partial<PayloadRequest>\n  select?: SelectType\n  /**\n   * @deprecated This parameter is going to be removed in the next major version. Use page instead.\n   */\n  skip?: number\n  sort?: Sort\n  versions?: boolean\n  where?: Where\n}\n\nexport type FindVersionsArgs = {\n  collection: CollectionSlug\n} & BaseVersionArgs\n\nexport type FindVersions = <T = JsonObject>(\n  args: FindVersionsArgs,\n) => Promise<PaginatedDocs<TypeWithVersion<T>>>\n\nexport type FindGlobalVersionsArgs = {\n  global: GlobalSlug\n} & BaseVersionArgs\n\nexport type FindGlobalArgs = {\n  locale?: string\n  req?: Partial<PayloadRequest>\n  select?: SelectType\n  slug: string\n  where?: Where\n}\n\nexport type UpdateGlobalVersionArgs<T extends JsonObject = JsonObject> = {\n  global: GlobalSlug\n  locale?: string\n  /**\n   * Additional database adapter specific options to pass to the query\n   */\n  options?: Record<string, unknown>\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n  versionData: {\n    createdAt?: string\n    latest?: boolean\n    parent?: number | string\n    publishedLocale?: string\n    updatedAt?: string\n    version: T\n  }\n} & (\n  | {\n      id: number | string\n      where?: never\n    }\n  | {\n      id?: never\n      where: Where\n    }\n)\n\n/**\n * @todo type as Promise<TypeWithVersion<T> | null> in 4.0\n */\nexport type UpdateGlobalVersion = <T extends JsonObject = JsonObject>(\n  args: UpdateGlobalVersionArgs<T>,\n) => Promise<TypeWithVersion<T>>\n\nexport type FindGlobal = <T extends Record<string, unknown> = any>(\n  args: FindGlobalArgs,\n) => Promise<T>\n\nexport type CreateGlobalArgs<T extends Record<string, unknown> = any> = {\n  data: T\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  slug: string\n}\nexport type CreateGlobal = <T extends Record<string, unknown> = any>(\n  args: CreateGlobalArgs<T>,\n) => Promise<T>\n\nexport type UpdateGlobalArgs<T extends Record<string, unknown> = any> = {\n  data: T\n  /**\n   * Additional database adapter specific options to pass to the query\n   */\n  options?: Record<string, unknown>\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n  slug: string\n}\n/**\n * @todo type as Promise<T | null> in 4.0\n */\nexport type UpdateGlobal = <T extends Record<string, unknown> = any>(\n  args: UpdateGlobalArgs<T>,\n) => Promise<T>\n// export type UpdateOne = (args: UpdateOneArgs) => Promise<Document>\n\nexport type FindGlobalVersions = <T = JsonObject>(\n  args: FindGlobalVersionsArgs,\n) => Promise<PaginatedDocs<TypeWithVersion<T>>>\n\nexport type DeleteVersionsArgs = {\n  collection?: CollectionSlug\n  globalSlug?: GlobalSlug\n  locale?: string\n  req?: Partial<PayloadRequest>\n  sort?: {\n    [key: string]: string\n  }\n  where: Where\n}\n\nexport type CreateVersionArgs<T extends JsonObject = JsonObject> = {\n  autosave: boolean\n  collectionSlug: CollectionSlug\n  createdAt: string\n  /** ID of the parent document for which the version should be created for */\n  parent: number | string\n  publishedLocale?: string\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n  /**\n   * If provided, the snapshot will be created\n   * after a version is created (not during autosave)\n   */\n  snapshot?: true\n  updatedAt: string\n  versionData: T\n}\n\nexport type CreateVersion = <T extends JsonObject = JsonObject>(\n  args: CreateVersionArgs<T>,\n) => Promise<TypeWithVersion<T>>\n\nexport type CreateGlobalVersionArgs<T extends JsonObject = JsonObject> = {\n  autosave: boolean\n  createdAt: string\n  globalSlug: GlobalSlug\n  publishedLocale?: string\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n  /**\n   * If provided, the snapshot will be created\n   * after a version is created (not during autosave)\n   */\n  snapshot?: true\n  updatedAt: string\n  versionData: T\n}\n\nexport type CreateGlobalVersion = <T extends JsonObject = JsonObject>(\n  args: CreateGlobalVersionArgs<T>,\n) => Promise<Omit<TypeWithVersion<T>, 'parent'>>\n\nexport type DeleteVersions = (args: DeleteVersionsArgs) => Promise<void>\n\nexport type UpdateVersionArgs<T extends JsonObject = JsonObject> = {\n  collection: CollectionSlug\n  locale?: string\n  /**\n   * Additional database adapter specific options to pass to the query\n   */\n  options?: Record<string, unknown>\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n  versionData: {\n    createdAt?: string\n    latest?: boolean\n    parent?: number | string\n    publishedLocale?: string\n    updatedAt?: string\n    version: T\n  }\n} & (\n  | {\n      id: number | string\n      where?: never\n    }\n  | {\n      id?: never\n      where: Where\n    }\n)\n\n/**\n * @todo type as Promise<TypeWithVersion<T> | null> in 4.0\n */\nexport type UpdateVersion = <T extends JsonObject = JsonObject>(\n  args: UpdateVersionArgs<T>,\n) => Promise<TypeWithVersion<T>>\n\nexport type CreateArgs = {\n  collection: CollectionSlug\n  data: Record<string, unknown>\n  draft?: boolean\n  locale?: string\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n}\n\nexport type FindDistinctArgs = {\n  collection: CollectionSlug\n  field: string\n  limit?: number\n  locale?: string\n  page?: number\n  req?: Partial<PayloadRequest>\n  sort?: Sort\n  where?: Where\n}\n\nexport type PaginatedDistinctDocs<T extends Record<string, unknown>> = {\n  hasNextPage: boolean\n  hasPrevPage: boolean\n  limit: number\n  nextPage?: null | number | undefined\n  page: number\n  pagingCounter: number\n  prevPage?: null | number | undefined\n  totalDocs: number\n  totalPages: number\n  values: T[]\n}\n\nexport type FindDistinct = (\n  args: FindDistinctArgs,\n) => Promise<PaginatedDistinctDocs<Record<string, any>>>\n\nexport type Create = (args: CreateArgs) => Promise<Document>\n\nexport type UpdateOneArgs = {\n  collection: CollectionSlug\n  data: Record<string, unknown>\n  draft?: boolean\n  joins?: JoinQuery\n  locale?: string\n  /**\n   * Additional database adapter specific options to pass to the query\n   */\n  options?: Record<string, unknown>\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n} & (\n  | {\n      id: number | string\n      where?: never\n    }\n  | {\n      id?: never\n      where: Where\n    }\n)\n\n/**\n * @todo type as Promise<Document | null> in 4.0\n */\nexport type UpdateOne = (args: UpdateOneArgs) => Promise<Document>\n\nexport type UpdateManyArgs = {\n  collection: CollectionSlug\n  data: Record<string, unknown>\n  draft?: boolean\n  joins?: JoinQuery\n  limit?: number\n  locale?: string\n  /**\n   * Additional database adapter specific options to pass to the query\n   */\n  options?: Record<string, unknown>\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n  sort?: Sort\n  where: Where\n}\n\nexport type UpdateMany = (args: UpdateManyArgs) => Promise<Document[] | null>\n\nexport type UpdateJobsArgs = {\n  data: Record<string, unknown>\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n} & (\n  | {\n      id: number | string\n      limit?: never\n      sort?: never\n      where?: never\n    }\n  | {\n      id?: never\n      limit?: number\n      sort?: Sort\n      where: Where\n    }\n)\n\nexport type UpdateJobs = (args: UpdateJobsArgs) => Promise<Job[] | null>\n\nexport type UpsertArgs = {\n  collection: CollectionSlug\n  data: Record<string, unknown>\n  joins?: JoinQuery\n  locale?: string\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n  where: Where\n}\n\nexport type Upsert = (args: UpsertArgs) => Promise<Document>\n\nexport type DeleteOneArgs = {\n  collection: CollectionSlug\n  joins?: JoinQuery\n  req?: Partial<PayloadRequest>\n  /**\n   * If true, returns the updated documents\n   *\n   * @default true\n   */\n  returning?: boolean\n  select?: SelectType\n  where: Where\n}\n\n/**\n * @todo type as Promise<Document | null> in 4.0\n */\nexport type DeleteOne = (args: DeleteOneArgs) => Promise<Document>\n\nexport type DeleteManyArgs = {\n  collection: CollectionSlug\n  joins?: JoinQuery\n  req?: Partial<PayloadRequest>\n  where: Where\n}\n\nexport type DeleteMany = (args: DeleteManyArgs) => Promise<void>\n\nexport type Migration = {\n  down: (args: unknown) => Promise<void>\n  up: (args: unknown) => Promise<void>\n} & MigrationData\n\nexport type MigrationData = {\n  batch?: number\n  id?: string\n  name: string\n}\n\nexport type PaginatedDocs<T = any> = {\n  docs: T[]\n  hasNextPage: boolean\n  hasPrevPage: boolean\n  limit: number\n  nextPage?: null | number | undefined\n  page?: number\n  pagingCounter: number\n  prevPage?: null | number | undefined\n  totalDocs: number\n  totalPages: number\n}\n\nexport type DatabaseAdapterResult<T = BaseDatabaseAdapter> = {\n  allowIDOnCreate?: boolean\n  defaultIDType: 'number' | 'text'\n  init: (args: { payload: Payload }) => T\n  /**\n   * The name of the database adapter. For example, \"postgres\" or \"mongoose\".\n   *\n   * @todo make required in 4.0\n   */\n  name?: string\n}\n\nexport type DBIdentifierName =\n  | ((Args: {\n      /** The name of the parent table when using relational DBs */\n      tableName?: string\n    }) => string)\n  | string\n\nexport type MigrationTemplateArgs = {\n  downSQL?: string\n  imports?: string\n  packageName?: string\n  upSQL?: string\n}\n\nexport type GenerateSchemaArgs = {\n  log?: boolean\n  outputFile?: string\n  prettify?: boolean\n}\n\nexport type GenerateSchema = (args?: GenerateSchemaArgs) => Promise<void>\n"],"names":[],"mappings":"AAmuBA,WAAyE"}