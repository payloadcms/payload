{"version":3,"sources":["../../../src/bin/generateImportMap/index.ts"],"sourcesContent":["/* eslint-disable no-console */\nimport fs from 'fs/promises'\nimport process from 'node:process'\n\nimport type { PayloadComponent, SanitizedConfig } from '../../config/types.js'\n\nimport { iterateConfig } from './iterateConfig.js'\nimport { addPayloadComponentToImportMap } from './utilities/addPayloadComponentToImportMap.js'\nimport { getImportMapToBaseDirPath } from './utilities/getImportMapToBaseDirPath.js'\nimport { resolveImportMapFilePath } from './utilities/resolveImportMapFilePath.js'\n\ntype ImportIdentifier = string\ntype ImportSpecifier = string\ntype ImportPath = string\ntype UserImportPath = string\n\n/**\n * Import Map before being written to the file. Only contains all paths\n */\nexport type InternalImportMap = {\n  [path: UserImportPath]: ImportIdentifier\n}\n\n/**\n * Imports of the import map.\n */\nexport type Imports = {\n  [identifier: ImportIdentifier]: {\n    path: ImportPath\n    specifier: ImportSpecifier\n  }\n}\n\n/**\n * Import Map after being imported from the actual import map. Contains all the actual imported components\n */\nexport type ImportMap = {\n  [path: UserImportPath]: any\n}\n\nexport type AddToImportMap = (payloadComponent?: PayloadComponent | PayloadComponent[]) => void\n\nexport async function generateImportMap(\n  config: SanitizedConfig,\n  options?: {\n    force?: boolean /**\n     * If true, will not throw an error if the import map file path cannot be resolved\n    Instead, it will return silently.\n     */\n    ignoreResolveError?: boolean\n    log: boolean\n  },\n): Promise<void> {\n  const shouldLog = options?.log ?? true\n\n  if (shouldLog) {\n    console.log('Generating import map')\n  }\n\n  const importMap: InternalImportMap = {}\n  const imports: Imports = {}\n\n  // Determine the root directory of the project - usually the directory where the src or app folder is located\n  const rootDir = process.env.ROOT_DIR ?? process.cwd()\n\n  const baseDir = config.admin.importMap.baseDir ?? process.cwd()\n\n  const importMapFilePath = await resolveImportMapFilePath({\n    adminRoute: config.routes.admin,\n    importMapFile: config?.admin?.importMap?.importMapFile,\n    rootDir,\n  })\n\n  if (importMapFilePath instanceof Error) {\n    if (options?.ignoreResolveError) {\n      return\n    } else {\n      throw importMapFilePath\n    }\n  }\n\n  const importMapToBaseDirPath = getImportMapToBaseDirPath({\n    baseDir,\n    importMapPath: importMapFilePath,\n  })\n\n  const addToImportMap: AddToImportMap = (payloadComponent) => {\n    if (!payloadComponent) {\n      return\n    }\n\n    if (typeof payloadComponent !== 'object' && typeof payloadComponent !== 'string') {\n      console.error(payloadComponent)\n      throw new Error('addToImportMap > Payload component must be an object or a string')\n    }\n\n    if (Array.isArray(payloadComponent)) {\n      for (const component of payloadComponent) {\n        addPayloadComponentToImportMap({\n          importMap,\n          importMapToBaseDirPath,\n          imports,\n          payloadComponent: component,\n        })\n      }\n    } else {\n      addPayloadComponentToImportMap({\n        importMap,\n        importMapToBaseDirPath,\n        imports,\n        payloadComponent,\n      })\n    }\n  }\n\n  iterateConfig({\n    addToImportMap,\n    baseDir: config.admin.importMap.baseDir,\n    config,\n    importMap,\n    imports,\n  })\n\n  await writeImportMap({\n    componentMap: importMap,\n    force: options?.force,\n    importMap: imports,\n    importMapFilePath,\n    log: shouldLog,\n  })\n}\n\nexport async function writeImportMap({\n  componentMap,\n  force,\n  importMap,\n  importMapFilePath,\n  log,\n}: {\n  componentMap: InternalImportMap\n  force?: boolean\n  importMap: Imports\n  importMapFilePath: string\n  log?: boolean\n}) {\n  const imports: string[] = []\n  for (const [identifier, { path, specifier }] of Object.entries(importMap)) {\n    imports.push(`import { ${specifier} as ${identifier} } from '${path}'`)\n  }\n\n  const mapKeys: string[] = []\n  for (const [userPath, identifier] of Object.entries(componentMap)) {\n    mapKeys.push(`  \"${userPath}\": ${identifier}`)\n  }\n\n  const importMapOutputFile = `${imports.join('\\n')}\n\nexport const importMap = {\n${mapKeys.join(',\\n')}\n}\n`\n\n  if (!force) {\n    // Read current import map and check in the IMPORTS if there are any new imports. If not, don't write the file.\n    const currentImportMap = await fs.readFile(importMapFilePath, 'utf-8')\n\n    if (currentImportMap?.trim() === importMapOutputFile?.trim()) {\n      if (log) {\n        console.log('No new imports found, skipping writing import map')\n      }\n      return\n    }\n  }\n\n  if (log) {\n    console.log('Writing import map to', importMapFilePath)\n  }\n\n  await fs.writeFile(importMapFilePath, importMapOutputFile)\n}\n"],"names":["fs","process","iterateConfig","addPayloadComponentToImportMap","getImportMapToBaseDirPath","resolveImportMapFilePath","generateImportMap","config","options","shouldLog","log","console","importMap","imports","rootDir","env","ROOT_DIR","cwd","baseDir","admin","importMapFilePath","adminRoute","routes","importMapFile","Error","ignoreResolveError","importMapToBaseDirPath","importMapPath","addToImportMap","payloadComponent","error","Array","isArray","component","writeImportMap","componentMap","force","identifier","path","specifier","Object","entries","push","mapKeys","userPath","importMapOutputFile","join","currentImportMap","readFile","trim","writeFile"],"mappings":"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"}