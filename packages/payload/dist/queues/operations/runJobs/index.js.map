{"version":3,"sources":["../../../../src/queues/operations/runJobs/index.ts"],"sourcesContent":["import type { Job } from '../../../index.js'\nimport type { PayloadRequest, Sort, Where } from '../../../types/index.js'\nimport type { WorkflowJSON } from '../../config/types/workflowJSONTypes.js'\nimport type { WorkflowConfig, WorkflowHandler } from '../../config/types/workflowTypes.js'\nimport type { RunJobsSilent } from '../../localAPI.js'\nimport type { RunJobResult } from './runJob/index.js'\n\nimport { Forbidden } from '../../../errors/Forbidden.js'\nimport { isolateObjectProperty } from '../../../utilities/isolateObjectProperty.js'\nimport { jobsCollectionSlug } from '../../config/collection.js'\nimport { JobCancelledError } from '../../errors/index.js'\nimport { getCurrentDate } from '../../utilities/getCurrentDate.js'\nimport { updateJob, updateJobs } from '../../utilities/updateJob.js'\nimport { getUpdateJobFunction } from './runJob/getUpdateJobFunction.js'\nimport { importHandlerPath } from './runJob/importHandlerPath.js'\nimport { runJob } from './runJob/index.js'\nimport { runJSONJob } from './runJSONJob/index.js'\n\nexport type RunJobsArgs = {\n  /**\n   * If you want to run jobs from all queues, set this to true.\n   * If you set this to true, the `queue` property will be ignored.\n   *\n   * @default false\n   */\n  allQueues?: boolean\n  /**\n   * ID of the job to run\n   */\n  id?: number | string\n  /**\n   * The maximum number of jobs to run in this invocation\n   *\n   * @default 10\n   */\n  limit?: number\n  overrideAccess?: boolean\n  /**\n   * Adjust the job processing order\n   *\n   * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n   *\n   * @default all jobs for all queues will be executed in FIFO order.\n   */\n  processingOrder?: Sort\n  /**\n   * If you want to run jobs from a specific queue, set this to the queue name.\n   *\n   * @default jobs from the `default` queue will be executed.\n   */\n  queue?: string\n  req: PayloadRequest\n  /**\n   * By default, jobs are run in parallel.\n   * If you want to run them in sequence, set this to true.\n   */\n  sequential?: boolean\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  where?: Where\n}\n\nexport type RunJobsResult = {\n  jobStatus?: Record<string, RunJobResult>\n  /**\n   * If this is true, there for sure are no jobs remaining, regardless of the limit\n   */\n  noJobsRemaining?: boolean\n  /**\n   * Out of the jobs that were queried & processed (within the set limit), how many are remaining and retryable?\n   */\n  remainingJobsFromQueried: number\n}\n\nexport const runJobs = async (args: RunJobsArgs): Promise<RunJobsResult> => {\n  const {\n    id,\n    allQueues = false,\n    limit = 10,\n    overrideAccess,\n    processingOrder,\n    queue = 'default',\n    req,\n    req: {\n      payload,\n      payload: {\n        config: { jobs: jobsConfig },\n      },\n    },\n    sequential,\n    silent = false,\n    where: whereFromProps,\n  } = args\n\n  if (!overrideAccess) {\n    /**\n     * By default, jobsConfig.access.run will be `defaultAccess` which is a function that returns `true` if the user is logged in.\n     */\n    const accessFn = jobsConfig?.access?.run ?? (() => true)\n    const hasAccess = await accessFn({ req })\n    if (!hasAccess) {\n      throw new Forbidden(req.t)\n    }\n  }\n  const and: Where[] = [\n    {\n      completedAt: {\n        exists: false,\n      },\n    },\n    {\n      hasError: {\n        not_equals: true,\n      },\n    },\n    {\n      processing: {\n        equals: false,\n      },\n    },\n    {\n      or: [\n        {\n          waitUntil: {\n            exists: false,\n          },\n        },\n        {\n          waitUntil: {\n            less_than: getCurrentDate().toISOString(),\n          },\n        },\n      ],\n    },\n  ]\n\n  if (allQueues !== true) {\n    and.push({\n      queue: {\n        equals: queue ?? 'default',\n      },\n    })\n  }\n\n  if (whereFromProps) {\n    and.push(whereFromProps)\n  }\n\n  // Only enforce concurrency controls if the feature is enabled\n  if (jobsConfig.enableConcurrencyControl) {\n    // Find currently running jobs with concurrency keys to enforce exclusive concurrency\n    // Jobs with the same concurrencyKey should not run in parallel\n    const runningJobsWithConcurrency = await payload.db.find({\n      collection: jobsCollectionSlug,\n      limit: 0,\n      pagination: false,\n      req: { transactionID: undefined },\n      select: {\n        concurrencyKey: true,\n      },\n      where: {\n        and: [{ processing: { equals: true } }, { concurrencyKey: { exists: true } }],\n      },\n    })\n\n    const runningConcurrencyKeys = new Set<string>()\n    if (runningJobsWithConcurrency?.docs) {\n      for (const doc of runningJobsWithConcurrency.docs) {\n        const concurrencyKey = (doc as Job).concurrencyKey\n        if (concurrencyKey) {\n          runningConcurrencyKeys.add(concurrencyKey)\n        }\n      }\n    }\n\n    // Exclude jobs whose concurrencyKey is already running\n    if (runningConcurrencyKeys.size > 0) {\n      and.push({\n        or: [\n          // Jobs without a concurrency key can always run\n          { concurrencyKey: { exists: false } },\n          // Jobs with a concurrency key that is not currently running can run\n          { concurrencyKey: { not_in: [...runningConcurrencyKeys] } },\n        ],\n      })\n    }\n  }\n\n  // Find all jobs and ensure we set job to processing: true as early as possible to reduce the chance of\n  // the same job being picked up by another worker\n  let jobs: Job[] = []\n\n  if (id) {\n    // Only one job to run\n    const job = await updateJob({\n      id,\n      data: {\n        processing: true,\n      },\n      depth: jobsConfig.depth,\n      disableTransaction: true,\n      req,\n      returning: true,\n    })\n    if (job) {\n      jobs = [job]\n    }\n  } else {\n    let defaultProcessingOrder: Sort =\n      payload.collections[jobsCollectionSlug]?.config.defaultSort ?? 'createdAt'\n\n    const processingOrderConfig = jobsConfig.processingOrder\n    if (typeof processingOrderConfig === 'function') {\n      defaultProcessingOrder = await processingOrderConfig(args)\n    } else if (typeof processingOrderConfig === 'object' && !Array.isArray(processingOrderConfig)) {\n      if (\n        !allQueues &&\n        queue &&\n        processingOrderConfig.queues &&\n        processingOrderConfig.queues[queue]\n      ) {\n        defaultProcessingOrder = processingOrderConfig.queues[queue]\n      } else if (processingOrderConfig.default) {\n        defaultProcessingOrder = processingOrderConfig.default\n      }\n    } else if (typeof processingOrderConfig === 'string') {\n      defaultProcessingOrder = processingOrderConfig\n    }\n    const updatedDocs = await updateJobs({\n      data: {\n        processing: true,\n      },\n      depth: jobsConfig.depth,\n      disableTransaction: true,\n      limit,\n      req,\n      returning: true,\n      sort: processingOrder ?? defaultProcessingOrder,\n      where: { and },\n    })\n\n    if (updatedDocs) {\n      jobs = updatedDocs\n    }\n  }\n\n  if (!jobs.length) {\n    return {\n      noJobsRemaining: true,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  // Only handle concurrency deduplication if the feature is enabled\n  if (jobsConfig.enableConcurrencyControl) {\n    // Handle the case where multiple jobs with the same concurrencyKey were picked up in the same batch\n    // We should only run one job per concurrencyKey, release the others back to pending\n    const seenConcurrencyKeys = new Set<string>()\n    const jobsToRun: Job[] = []\n    const jobsToRelease: Job[] = []\n\n    for (const job of jobs) {\n      if (job.concurrencyKey) {\n        if (seenConcurrencyKeys.has(job.concurrencyKey)) {\n          // This job has the same concurrencyKey as another job we're already running\n          jobsToRelease.push(job)\n        } else {\n          seenConcurrencyKeys.add(job.concurrencyKey)\n          jobsToRun.push(job)\n        }\n      } else {\n        jobsToRun.push(job)\n      }\n    }\n\n    // Release duplicate concurrencyKey jobs back to pending state\n    if (jobsToRelease.length > 0) {\n      const releaseIds = jobsToRelease.map((job) => job.id)\n      await updateJobs({\n        data: { processing: false },\n        disableTransaction: true,\n        req,\n        returning: false,\n        where: { id: { in: releaseIds } },\n      })\n    }\n\n    // Use only the filtered jobs going forward\n    jobs = jobsToRun\n  }\n\n  if (!jobs.length) {\n    return {\n      noJobsRemaining: false,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  /**\n   * Just for logging purposes, we want to know how many jobs are new and how many are existing (= already been tried).\n   * This is only for logs - in the end we still want to run all jobs, regardless of whether they are new or existing.\n   */\n  const { existingJobs, newJobs } = jobs.reduce(\n    (acc, job) => {\n      if (job.totalTried > 0) {\n        acc.existingJobs.push(job)\n      } else {\n        acc.newJobs.push(job)\n      }\n      return acc\n    },\n    { existingJobs: [] as Job[], newJobs: [] as Job[] },\n  )\n\n  if (!silent || (typeof silent === 'object' && !silent.info)) {\n    payload.logger.info({\n      msg: `Running ${jobs.length} jobs.`,\n      new: newJobs?.length,\n      retrying: existingJobs?.length,\n    })\n  }\n\n  const successfullyCompletedJobs: (number | string)[] = []\n\n  const runSingleJob = async (\n    job: Job,\n  ): Promise<{\n    id: number | string\n    result: RunJobResult\n  }> => {\n    if (!job.workflowSlug && !job.taskSlug) {\n      throw new Error('Job must have either a workflowSlug or a taskSlug')\n    }\n    const jobReq = isolateObjectProperty(req, 'transactionID')\n\n    const workflowConfig: WorkflowConfig =\n      job.workflowSlug && jobsConfig.workflows?.length\n        ? jobsConfig.workflows.find(({ slug }) => slug === job.workflowSlug)!\n        : {\n            slug: 'singleTask',\n            handler: async ({ job, tasks }) => {\n              await tasks[job.taskSlug as string]!('1', {\n                input: job.input,\n              })\n            },\n          }\n\n    if (!workflowConfig) {\n      return {\n        id: job.id,\n        result: {\n          status: 'error',\n        },\n      } // Skip jobs with no workflow configuration\n    }\n\n    try {\n      const updateJob = getUpdateJobFunction(job, jobReq)\n\n      // the runner will either be passed to the config\n      // OR it will be a path, which we will need to import via eval to avoid\n      // Next.js compiler dynamic import expression errors\n      let workflowHandler: WorkflowHandler | WorkflowJSON\n      if (\n        typeof workflowConfig.handler === 'function' ||\n        (typeof workflowConfig.handler === 'object' && Array.isArray(workflowConfig.handler))\n      ) {\n        workflowHandler = workflowConfig.handler\n      } else {\n        workflowHandler = await importHandlerPath<typeof workflowHandler>(workflowConfig.handler)\n\n        if (!workflowHandler) {\n          const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n          const errorMessage = `Can't find runner while importing with the path ${workflowConfig.handler} in job type ${jobLabel}.`\n          if (!silent || (typeof silent === 'object' && !silent.error)) {\n            payload.logger.error(errorMessage)\n          }\n\n          await updateJob({\n            error: {\n              error: errorMessage,\n            },\n            hasError: true,\n            processing: false,\n          })\n\n          return {\n            id: job.id,\n            result: {\n              status: 'error-reached-max-retries',\n            },\n          }\n        }\n      }\n\n      if (typeof workflowHandler === 'function') {\n        const result = await runJob({\n          job,\n          req: jobReq,\n          silent,\n          updateJob,\n          workflowConfig,\n          workflowHandler,\n        })\n\n        if (result.status === 'success') {\n          successfullyCompletedJobs.push(job.id)\n        }\n\n        return { id: job.id, result }\n      } else {\n        const result = await runJSONJob({\n          job,\n          req: jobReq,\n          silent,\n          updateJob,\n          workflowConfig,\n          workflowHandler,\n        })\n\n        if (result.status === 'success') {\n          successfullyCompletedJobs.push(job.id)\n        }\n\n        return { id: job.id, result }\n      }\n    } catch (error) {\n      if (error instanceof JobCancelledError) {\n        if (\n          !(job.error as Record<string, unknown> | undefined)?.cancelled ||\n          !job.hasError ||\n          job.processing ||\n          job.completedAt ||\n          job.waitUntil\n        ) {\n          // When using the local API to cancel jobs, the local API will update the job data for us to ensure the job is cancelled.\n          // But when throwing a JobCancelledError within a task or workflow handler, we are responsible for updating the job data ourselves.\n          await updateJob({\n            id: job.id,\n            data: {\n              completedAt: null,\n              error: {\n                cancelled: true,\n                message: error.message,\n              },\n              hasError: true,\n              processing: false,\n              waitUntil: null,\n            },\n            depth: 0,\n            disableTransaction: true,\n            req,\n            returning: false,\n          })\n        }\n\n        return {\n          id: job.id,\n          result: {\n            status: 'error-reached-max-retries',\n          },\n        }\n      }\n      throw error\n    }\n  }\n\n  let resultsArray: { id: number | string; result: RunJobResult }[] = []\n  if (sequential) {\n    for (const job of jobs) {\n      const result = await runSingleJob(job)\n      if (result) {\n        resultsArray.push(result)\n      }\n    }\n  } else {\n    const jobPromises = jobs.map(runSingleJob)\n    resultsArray = (await Promise.all(jobPromises)) as {\n      id: number | string\n      result: RunJobResult\n    }[]\n  }\n\n  if (jobsConfig.deleteJobOnComplete && successfullyCompletedJobs.length) {\n    try {\n      if (jobsConfig.runHooks) {\n        await payload.delete({\n          collection: jobsCollectionSlug,\n          depth: 0, // can be 0 since we're not returning anything\n          disableTransaction: true,\n          where: { id: { in: successfullyCompletedJobs } },\n        })\n      } else {\n        await payload.db.deleteMany({\n          collection: jobsCollectionSlug,\n          where: { id: { in: successfullyCompletedJobs } },\n        })\n      }\n    } catch (err) {\n      if (!silent || (typeof silent === 'object' && !silent.error)) {\n        payload.logger.error({\n          err,\n          msg: `Failed to delete jobs ${successfullyCompletedJobs.join(', ')} on complete`,\n        })\n      }\n    }\n  }\n\n  const resultsObject: RunJobsResult['jobStatus'] = resultsArray.reduce(\n    (acc, cur) => {\n      if (cur !== null) {\n        // Check if there's a valid result to include\n        acc[cur.id] = cur.result\n      }\n      return acc\n    },\n    {} as Record<string, RunJobResult>,\n  )\n\n  let remainingJobsFromQueried = 0\n  for (const jobID in resultsObject) {\n    const jobResult = resultsObject[jobID]\n    if (jobResult?.status === 'error') {\n      remainingJobsFromQueried++ // Can be retried\n    }\n  }\n\n  return {\n    jobStatus: resultsObject,\n    remainingJobsFromQueried,\n  }\n}\n"],"names":["Forbidden","isolateObjectProperty","jobsCollectionSlug","JobCancelledError","getCurrentDate","updateJob","updateJobs","getUpdateJobFunction","importHandlerPath","runJob","runJSONJob","runJobs","args","id","allQueues","limit","overrideAccess","processingOrder","queue","req","payload","config","jobs","jobsConfig","sequential","silent","where","whereFromProps","accessFn","access","run","hasAccess","t","and","completedAt","exists","hasError","not_equals","processing","equals","or","waitUntil","less_than","toISOString","push","enableConcurrencyControl","runningJobsWithConcurrency","db","find","collection","pagination","transactionID","undefined","select","concurrencyKey","runningConcurrencyKeys","Set","docs","doc","add","size","not_in","job","data","depth","disableTransaction","returning","defaultProcessingOrder","collections","defaultSort","processingOrderConfig","Array","isArray","queues","default","updatedDocs","sort","length","noJobsRemaining","remainingJobsFromQueried","seenConcurrencyKeys","jobsToRun","jobsToRelease","has","releaseIds","map","in","existingJobs","newJobs","reduce","acc","totalTried","info","logger","msg","new","retrying","successfullyCompletedJobs","runSingleJob","workflowSlug","taskSlug","Error","jobReq","workflowConfig","workflows","slug","handler","tasks","input","result","status","workflowHandler","jobLabel","errorMessage","error","cancelled","message","resultsArray","jobPromises","Promise","all","deleteJobOnComplete","runHooks","delete","deleteMany","err","join","resultsObject","cur","jobID","jobResult","jobStatus"],"mappings":"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"}