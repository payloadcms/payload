{"version":3,"sources":["../../src/queues/localAPI.ts"],"sourcesContent":["import type { BaseJob, RunningJobFromTask } from './config/types/workflowTypes.js'\n\nimport {\n  createLocalReq,\n  Forbidden,\n  type Job,\n  type Payload,\n  type PayloadRequest,\n  type Sort,\n  type TypedJobs,\n  type Where,\n} from '../index.js'\nimport { jobAfterRead, jobsCollectionSlug } from './config/collection.js'\nimport { handleSchedules, type HandleSchedulesResult } from './operations/handleSchedules/index.js'\nimport { runJobs } from './operations/runJobs/index.js'\nimport { updateJob, updateJobs } from './utilities/updateJob.js'\n\nexport type RunJobsSilent =\n  | {\n      error?: boolean\n      info?: boolean\n    }\n  | boolean\nexport const getJobsLocalAPI = (payload: Payload) => ({\n  handleSchedules: async (args?: {\n    /**\n     * If you want to schedule jobs from all queues, set this to true.\n     * If you set this to true, the `queue` property will be ignored.\n     *\n     * @default false\n     */\n    allQueues?: boolean\n    // By default, schedule all queues - only scheduling jobs scheduled to be added to the `default` queue would not make sense\n    // here, as you'd usually specify a different queue than `default` here, especially if this is used in combination with autorun.\n    // The `queue` property for setting up schedules is required, and not optional.\n    /**\n     * If you want to only schedule jobs that are set to schedule in a specific queue, set this to the queue name.\n     *\n     * @default jobs from the `default` queue will be executed.\n     */\n    queue?: string\n    req?: PayloadRequest\n  }): Promise<HandleSchedulesResult> => {\n    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))\n\n    return await handleSchedules({\n      allQueues: args?.allQueues,\n      queue: args?.queue,\n      req: newReq,\n    })\n  },\n  queue: async <\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] | keyof TypedJobs['workflows'],\n  >(\n    args:\n      | {\n          input: TypedJobs['tasks'][TTaskOrWorkflowSlug]['input']\n          meta?: BaseJob['meta']\n          /**\n           * If set to false, access control as defined in jobsConfig.access.queue will be run.\n           * By default, this is true and no access control will be run.\n           * If you set this to false and do not have jobsConfig.access.queue defined, the default access control will be\n           * run (which is a function that returns `true` if the user is logged in).\n           *\n           * @default true\n           */\n          overrideAccess?: boolean\n          /**\n           * The queue to add the job to.\n           * If not specified, the job will be added to the default queue.\n           *\n           * @default 'default'\n           */\n          queue?: string\n          req?: PayloadRequest\n          task: TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] ? TTaskOrWorkflowSlug : never\n          waitUntil?: Date\n          workflow?: never\n        }\n      | {\n          input: TypedJobs['workflows'][TTaskOrWorkflowSlug]['input']\n          meta?: BaseJob['meta']\n          /**\n           * If set to false, access control as defined in jobsConfig.access.queue will be run.\n           * By default, this is true and no access control will be run.\n           * If you set this to false and do not have jobsConfig.access.queue defined, the default access control will be\n           * run (which is a function that returns `true` if the user is logged in).\n           *\n           * @default true\n           */\n          overrideAccess?: boolean\n          /**\n           * The queue to add the job to.\n           * If not specified, the job will be added to the default queue.\n           *\n           * @default 'default'\n           */\n          queue?: string\n          req?: PayloadRequest\n          task?: never\n          waitUntil?: Date\n          workflow: TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n            ? TTaskOrWorkflowSlug\n            : never\n        },\n  ): Promise<\n    TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? Job<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug>\n  > => {\n    const overrideAccess = args?.overrideAccess !== false\n    const req: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    if (!overrideAccess) {\n      /**\n       * By default, jobsConfig.access.queue will be `defaultAccess` which is a function that returns `true` if the user is logged in.\n       */\n      const accessFn = payload.config.jobs?.access?.queue ?? (() => true)\n      const hasAccess = await accessFn({ req })\n      if (!hasAccess) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    let queue: string | undefined = undefined\n\n    // If user specifies queue, use that\n    if (args.queue) {\n      queue = args.queue\n    } else if (args.workflow) {\n      // Otherwise, if there is a workflow specified, and it has a default queue to use,\n      // use that\n      const workflow = payload.config.jobs?.workflows?.find(({ slug }) => slug === args.workflow)\n      if (workflow?.queue) {\n        queue = workflow.queue\n      }\n    }\n\n    const data: Partial<Job> = {\n      input: args.input,\n    }\n\n    if (queue) {\n      data.queue = queue\n    }\n    if (args.waitUntil) {\n      data.waitUntil = args.waitUntil?.toISOString()\n    }\n    if (args.workflow) {\n      data.workflowSlug = args.workflow as string\n    }\n    if (args.task) {\n      data.taskSlug = args.task as string\n    }\n\n    if (args.meta) {\n      data.meta = args.meta\n    }\n\n    // Compute concurrency key from workflow or task config (only if feature is enabled)\n    if (payload.config.jobs?.enableConcurrencyControl) {\n      let concurrencyKey: null | string = null\n      let supersedes = false\n      const queueName = queue || 'default'\n\n      if (args.workflow) {\n        const workflow = payload.config.jobs?.workflows?.find(({ slug }) => slug === args.workflow)\n        if (workflow?.concurrency) {\n          const concurrencyConfig = workflow.concurrency\n          if (typeof concurrencyConfig === 'function') {\n            concurrencyKey = concurrencyConfig({ input: args.input, queue: queueName })\n          } else {\n            concurrencyKey = concurrencyConfig.key({ input: args.input, queue: queueName })\n            supersedes = concurrencyConfig.supersedes ?? false\n          }\n        }\n      } else if (args.task) {\n        const task = payload.config.jobs?.tasks?.find(({ slug }) => slug === args.task)\n        if (task?.concurrency) {\n          const concurrencyConfig = task.concurrency\n          if (typeof concurrencyConfig === 'function') {\n            concurrencyKey = concurrencyConfig({ input: args.input, queue: queueName })\n          } else {\n            concurrencyKey = concurrencyConfig.key({ input: args.input, queue: queueName })\n            supersedes = concurrencyConfig.supersedes ?? false\n          }\n        }\n      }\n\n      if (concurrencyKey) {\n        data.concurrencyKey = concurrencyKey\n\n        // If supersedes is enabled, delete older pending jobs with the same key\n        if (supersedes) {\n          if (payload.config.jobs.runHooks) {\n            await payload.delete({\n              collection: jobsCollectionSlug,\n              depth: 0,\n              disableTransaction: true,\n              where: {\n                and: [\n                  { concurrencyKey: { equals: concurrencyKey } },\n                  { processing: { equals: false } },\n                  { completedAt: { exists: false } },\n                ],\n              },\n            })\n          } else {\n            await payload.db.deleteMany({\n              collection: jobsCollectionSlug,\n              req,\n              where: {\n                and: [\n                  { concurrencyKey: { equals: concurrencyKey } },\n                  { processing: { equals: false } },\n                  { completedAt: { exists: false } },\n                ],\n              },\n            })\n          }\n        }\n      }\n    }\n\n    type ReturnType = TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? Job<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug> // Type assertion is still needed here\n\n    if (payload?.config?.jobs?.depth || payload?.config?.jobs?.runHooks) {\n      return (await payload.create({\n        collection: jobsCollectionSlug,\n        data,\n        depth: payload.config.jobs.depth ?? 0,\n        overrideAccess,\n        req,\n      })) as ReturnType\n    } else {\n      return jobAfterRead({\n        config: payload.config,\n        doc: await payload.db.create({\n          collection: jobsCollectionSlug,\n          data,\n          req,\n        }),\n      }) as unknown as ReturnType\n    }\n  },\n\n  run: async (args?: {\n    /**\n     * If you want to run jobs from all queues, set this to true.\n     * If you set this to true, the `queue` property will be ignored.\n     *\n     * @default false\n     */\n    allQueues?: boolean\n    /**\n     * The maximum number of jobs to run in this invocation\n     *\n     * @default 10\n     */\n    limit?: number\n    /**\n     * If set to false, access control as defined in jobsConfig.access.run will be run.\n     * By default, this is true and no access control will be run.\n     * If you set this to false and do not have jobsConfig.access.run defined, the default access control will be\n     * run (which is a function that returns `true` if the user is logged in).\n     *\n     * @default true\n     */\n    overrideAccess?: boolean\n    /**\n     * Adjust the job processing order using a Payload sort string.\n     *\n     * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n     */\n    processingOrder?: Sort\n    /**\n     * If you want to run jobs from a specific queue, set this to the queue name.\n     *\n     * @default jobs from the `default` queue will be executed.\n     */\n    queue?: string\n    req?: PayloadRequest\n    /**\n     * By default, jobs are run in parallel.\n     * If you want to run them in sequence, set this to true.\n     */\n    sequential?: boolean\n    /**\n     * If set to true, the job system will not log any output to the console (for both info and error logs).\n     * Can be an option for more granular control over logging.\n     *\n     * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n     *\n     * @default false\n     */\n    silent?: RunJobsSilent\n    where?: Where\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))\n\n    return await runJobs({\n      allQueues: args?.allQueues,\n      limit: args?.limit,\n      overrideAccess: args?.overrideAccess !== false,\n      processingOrder: args?.processingOrder,\n      queue: args?.queue,\n      req: newReq,\n      sequential: args?.sequential,\n      silent: args?.silent,\n      where: args?.where,\n    })\n  },\n\n  runByID: async (args: {\n    id: number | string\n    /**\n     * If set to false, access control as defined in jobsConfig.access.run will be run.\n     * By default, this is true and no access control will be run.\n     * If you set this to false and do not have jobsConfig.access.run defined, the default access control will be\n     * run (which is a function that returns `true` if the user is logged in).\n     *\n     * @default true\n     */\n    overrideAccess?: boolean\n    req?: PayloadRequest\n    /**\n     * If set to true, the job system will not log any output to the console (for both info and error logs).\n     * Can be an option for more granular control over logging.\n     *\n     * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n     *\n     * @default false\n     */\n    silent?: RunJobsSilent\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    return await runJobs({\n      id: args.id,\n      overrideAccess: args.overrideAccess !== false,\n      req: newReq,\n      silent: args.silent,\n    })\n  },\n\n  cancel: async (args: {\n    /**\n     * If set to false, access control as defined in jobsConfig.access.cancel will be run.\n     * By default, this is true and no access control will be run.\n     * If you set this to false and do not have jobsConfig.access.cancel defined, the default access control will be\n     * run (which is a function that returns `true` if the user is logged in).\n     *\n     * @default true\n     */\n    overrideAccess?: boolean\n    queue?: string\n    req?: PayloadRequest\n    where: Where\n  }): Promise<void> => {\n    const req: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    const overrideAccess = args.overrideAccess !== false\n    if (!overrideAccess) {\n      /**\n       * By default, jobsConfig.access.cancel will be `defaultAccess` which is a function that returns `true` if the user is logged in.\n       */\n      const accessFn = payload.config.jobs?.access?.cancel ?? (() => true)\n      const hasAccess = await accessFn({ req })\n      if (!hasAccess) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    const and: Where[] = [\n      args.where,\n      {\n        completedAt: {\n          exists: false,\n        },\n      },\n      {\n        hasError: {\n          not_equals: true,\n        },\n      },\n    ]\n\n    if (args.queue) {\n      and.push({\n        queue: {\n          equals: args.queue,\n        },\n      })\n    }\n\n    await updateJobs({\n      data: {\n        completedAt: null,\n        error: {\n          cancelled: true,\n        },\n        hasError: true,\n        processing: false,\n        waitUntil: null,\n      },\n      depth: 0, // No depth, since we're not returning\n      disableTransaction: true,\n      req,\n      returning: false,\n      where: { and },\n    })\n  },\n\n  cancelByID: async (args: {\n    id: number | string\n    /**\n     * If set to false, access control as defined in jobsConfig.access.cancel will be run.\n     * By default, this is true and no access control will be run.\n     * If you set this to false and do not have jobsConfig.access.cancel defined, the default access control will be\n     * run (which is a function that returns `true` if the user is logged in).\n     *\n     * @default true\n     */\n    overrideAccess?: boolean\n    req?: PayloadRequest\n  }): Promise<void> => {\n    const req: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    const overrideAccess = args.overrideAccess !== false\n    if (!overrideAccess) {\n      /**\n       * By default, jobsConfig.access.cancel will be `defaultAccess` which is a function that returns `true` if the user is logged in.\n       */\n      const accessFn = payload.config.jobs?.access?.cancel ?? (() => true)\n      const hasAccess = await accessFn({ req })\n      if (!hasAccess) {\n        throw new Forbidden(req.t)\n      }\n    }\n\n    await updateJob({\n      id: args.id,\n      data: {\n        completedAt: null,\n        error: {\n          cancelled: true,\n        },\n        hasError: true,\n        processing: false,\n        waitUntil: null,\n      },\n      depth: 0, // No depth, since we're not returning\n      disableTransaction: true,\n      req,\n      returning: false,\n    })\n  },\n})\n"],"names":["createLocalReq","Forbidden","jobAfterRead","jobsCollectionSlug","handleSchedules","runJobs","updateJob","updateJobs","getJobsLocalAPI","payload","args","newReq","req","allQueues","queue","overrideAccess","accessFn","config","jobs","access","hasAccess","t","undefined","workflow","workflows","find","slug","data","input","waitUntil","toISOString","workflowSlug","task","taskSlug","meta","enableConcurrencyControl","concurrencyKey","supersedes","queueName","concurrency","concurrencyConfig","key","tasks","runHooks","delete","collection","depth","disableTransaction","where","and","equals","processing","completedAt","exists","db","deleteMany","create","doc","run","limit","processingOrder","sequential","silent","runByID","id","cancel","hasError","not_equals","push","error","cancelled","returning","cancelByID"],"mappings":"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"}