{"version":3,"sources":["../../../../src/queues/config/types/workflowTypes.ts"],"sourcesContent":["import type { Field } from '../../../fields/config/types.js'\nimport type {\n  Job,\n  MaybePromise,\n  PayloadRequest,\n  StringKeyOf,\n  TypedCollection,\n  TypedJobs,\n} from '../../../index.js'\nimport type { TaskParent } from '../../operations/runJobs/runJob/getRunTaskFunction.js'\nimport type { ScheduleConfig } from './index.js'\nimport type {\n  RetryConfig,\n  RunInlineTaskFunction,\n  RunTaskFunctions,\n  TaskInput,\n  TaskOutput,\n  TaskType,\n} from './taskTypes.js'\nimport type { WorkflowJSON } from './workflowJSONTypes.js'\n\nexport type JobLog = {\n  completedAt: string\n  error?: unknown\n  executedAt: string\n  /**\n   * ID added by the array field when the log is saved in the database\n   */\n  id: string\n  input?: Record<string, any>\n  output?: Record<string, any>\n  /**\n   * Sub-tasks (tasks that are run within a task) will have a parent task ID\n   */\n  parent?: TaskParent\n  state: 'failed' | 'succeeded'\n  taskID: string\n  taskSlug: TaskType\n}\n\n/**\n * @deprecated - will be made private in 4.0. Please use the `Job` type instead.\n */\nexport type BaseJob<\n  TWorkflowSlugOrInput extends false | keyof TypedJobs['workflows'] | object = false,\n> = {\n  completedAt?: null | string\n  /**\n   * Used for concurrency control. Jobs with the same key are subject to exclusive/supersedes rules.\n   */\n  concurrencyKey?: null | string\n  createdAt: string\n  error?: unknown\n  hasError?: boolean\n  id: number | string\n  input: TWorkflowSlugOrInput extends false\n    ? object\n    : TWorkflowSlugOrInput extends keyof TypedJobs['workflows']\n      ? TypedJobs['workflows'][TWorkflowSlugOrInput]['input']\n      : TWorkflowSlugOrInput\n  log?: JobLog[]\n  meta?: {\n    [key: string]: unknown\n    /**\n     * If true, this job was queued by the scheduling system.\n     */\n    scheduled?: boolean\n  }\n  processing?: boolean\n  queue?: string\n  taskSlug?: null | TaskType\n  taskStatus: JobTaskStatus\n  totalTried: number\n  updatedAt: string\n  waitUntil?: null | string\n  workflowSlug?: null | WorkflowTypes\n}\n\n/**\n * @todo rename to WorkflowSlug in 4.0, similar to CollectionSlug\n */\nexport type WorkflowTypes = StringKeyOf<TypedJobs['workflows']>\n\n/**\n * @deprecated - will be removed in 4.0. Use `Job` type instead.\n */\nexport type RunningJob<TWorkflowSlugOrInput extends keyof TypedJobs['workflows'] | object> = {\n  input: TWorkflowSlugOrInput extends keyof TypedJobs['workflows']\n    ? TypedJobs['workflows'][TWorkflowSlugOrInput]['input']\n    : TWorkflowSlugOrInput\n  taskStatus: JobTaskStatus\n} & Omit<TypedCollection['payload-jobs'], 'input' | 'taskStatus'>\n\n/**\n * @deprecated - will be removed in 4.0. Use `Job` type instead.\n */\nexport type RunningJobSimple<TWorkflowInput extends object> = {\n  input: TWorkflowInput\n} & TypedCollection['payload-jobs']\n\n// Simplified version of RunningJob that doesn't break TypeScript (TypeScript seems to stop evaluating RunningJob when it's too complex)\nexport type RunningJobFromTask<TTaskSlug extends keyof TypedJobs['tasks']> = {\n  input: TypedJobs['tasks'][TTaskSlug]['input']\n} & TypedCollection['payload-jobs']\n\nexport type WorkflowHandler<\n  TWorkflowSlugOrInput extends false | keyof TypedJobs['workflows'] | object = false,\n> = (args: {\n  inlineTask: RunInlineTaskFunction\n  job: Job<TWorkflowSlugOrInput>\n  req: PayloadRequest\n  tasks: RunTaskFunctions\n}) => MaybePromise<void>\n\nexport type SingleTaskStatus<T extends keyof TypedJobs['tasks']> = {\n  complete: boolean\n  input: TaskInput<T>\n  output: TaskOutput<T>\n  taskSlug: TaskType\n  totalTried: number\n}\n\n/**\n * Task IDs mapped to their status\n */\nexport type JobTaskStatus = {\n  // Wrap in taskSlug to improve typing\n  [taskSlug in TaskType]: {\n    [taskID: string]: SingleTaskStatus<taskSlug>\n  }\n}\n\n/**\n * Concurrency configuration for workflows and tasks.\n * Controls how jobs with the same concurrency key are handled.\n */\nexport type ConcurrencyConfig<TInput = object> =\n  | ((args: { input: TInput; queue: string }) => string)\n  // Shorthand: key function only, exclusive defaults to true, supersedes defaults to false\n  | {\n      /**\n       * Only one job with this key can run at a time.\n       * Other jobs with the same key remain queued until the running job completes.\n       * @default true\n       */\n      exclusive?: boolean\n      /**\n       * Function that returns a key to group related jobs.\n       * Jobs with the same key are subject to concurrency rules.\n       * The queue name is provided to allow for queue-specific concurrency keys if needed.\n       */\n      key: (args: { input: TInput; queue: string }) => string\n      /**\n       * When a new job is queued, delete older pending (not yet running) jobs with the same key.\n       * Already-running jobs are not affected.\n       * Useful when only the latest state matters (e.g., regenerating data after multiple rapid edits).\n       * @default false\n       */\n      supersedes?: boolean\n    }\n\nexport type WorkflowConfig<\n  TWorkflowSlugOrInput extends false | keyof TypedJobs['workflows'] | object = false,\n> = {\n  /**\n   * Job concurrency controls for preventing race conditions.\n   *\n   * Can be an object with full options, or a shorthand function that just returns the key\n   * (in which case exclusive defaults to true).\n   */\n  concurrency?: ConcurrencyConfig<\n    TWorkflowSlugOrInput extends false\n      ? object\n      : TWorkflowSlugOrInput extends keyof TypedJobs['workflows']\n        ? TypedJobs['workflows'][TWorkflowSlugOrInput]['input']\n        : TWorkflowSlugOrInput\n  >\n  /**\n   * You can either pass a string-based path to the workflow function file, or the workflow function itself.\n   *\n   * If you are using large dependencies within your workflow control flow, you might prefer to pass the string path\n   * because that will avoid bundling large dependencies in your Next.js app. Passing a string path is an advanced feature\n   * that may require a sophisticated build pipeline in order to work.\n   */\n  handler:\n    | string\n    | WorkflowHandler<TWorkflowSlugOrInput>\n    | WorkflowJSON<TWorkflowSlugOrInput extends object ? string : TWorkflowSlugOrInput>\n  /**\n   * Define the input field schema  - payload will generate a type for this schema.\n   */\n  inputSchema?: Field[]\n  /**\n   * You can use interfaceName to change the name of the interface that is generated for this workflow. By default, this is \"Workflow\" + the capitalized workflow slug.\n   */\n  interfaceName?: string\n  /**\n   * Define a human-friendly label for this workflow.\n   */\n  label?: string\n  /**\n   * Optionally, define the default queue name that this workflow should be tied to.\n   * Defaults to \"default\".\n   * Can be overridden when queuing jobs via Local API.\n   */\n  queue?: string\n  /**\n   * You can define `retries` on the workflow level, which will enforce that the workflow can only fail up to that number of retries. If a task does not have retries specified, it will inherit the retry count as specified on the workflow.\n   *\n   * You can specify `0` as `workflow` retries, which will disregard all `task` retry specifications and fail the entire workflow on any task failure.\n   * You can leave `workflow` retries as undefined, in which case, the workflow will respect what each task dictates as their own retry count.\n   *\n   * @default undefined. By default, workflows retries are defined by their tasks\n   */\n  retries?: number | RetryConfig | undefined\n  /**\n   * Allows automatically scheduling this workflow to run regularly at a specified interval.\n   */\n  schedule?: ScheduleConfig[]\n  /**\n   * Define a slug-based name for this job.\n   */\n  slug: TWorkflowSlugOrInput extends keyof TypedJobs['workflows'] ? TWorkflowSlugOrInput : string\n}\n"],"names":[],"mappings":"AAiKA,WA8DC"}