{"version":3,"sources":["../../src/utilities/sanitizePermissions.ts"],"sourcesContent":["import type { MarkOptional } from 'ts-essentials'\n\nimport type {\n  CollectionPermission,\n  FieldPermissions,\n  FieldsPermissions,\n  GlobalPermission,\n  Permissions,\n  SanitizedBlocksPermissions,\n  SanitizedFieldPermissions,\n  SanitizedFieldsPermissions,\n  SanitizedPermissions,\n} from '../auth/types.js'\n\nfunction checkAndSanitizeFieldsPermssions(data: FieldsPermissions): boolean {\n  let allFieldPermissionsTrue = true\n  for (const key in data) {\n    if (typeof data[key] === 'object') {\n      if (!checkAndSanitizePermissions(data[key])) {\n        allFieldPermissionsTrue = false\n      } else {\n        ;(data[key] as unknown as SanitizedFieldPermissions) = true\n      }\n    } else if (data[key] !== true) {\n      allFieldPermissionsTrue = false\n    }\n  }\n\n  // If all values are true or it's an empty object, return true\n  return allFieldPermissionsTrue\n}\n\n/**\n * Check if all permissions in a FieldPermissions, CollectionPermission or GlobalPermission object are true.\n * If nested fields or blocks are present, the function will recursively check those as well.\n */\nfunction checkAndSanitizePermissions(\n  _data: CollectionPermission | FieldPermissions | GlobalPermission,\n): boolean {\n  const data = _data as Record<string, any>\n  /**\n   * Check blocks permissions\n   */\n  let blocksPermissions = true\n  if ('blocks' in data && data.blocks) {\n    for (const blockSlug in data.blocks) {\n      if (typeof data.blocks[blockSlug] === 'object') {\n        for (const key in data.blocks[blockSlug]) {\n          /**\n           * Check fields in nested blocks\n           */\n          if (key === 'fields') {\n            if (data.blocks[blockSlug].fields) {\n              if (!checkAndSanitizeFieldsPermssions(data.blocks[blockSlug].fields)) {\n                blocksPermissions = false\n              } else {\n                ;(data.blocks[blockSlug].fields as unknown as SanitizedFieldsPermissions) = true\n              }\n            }\n          } else {\n            if (typeof data.blocks[blockSlug][key] === 'object') {\n              /**\n               * Check Permissions in nested blocks\n               */\n              if (isPermissionObject(data.blocks[blockSlug][key])) {\n                if (\n                  data.blocks[blockSlug][key]['permission'] === true &&\n                  !('where' in data.blocks[blockSlug][key])\n                ) {\n                  // If the permission is true and there is no where clause, set the key to true\n                  data.blocks[blockSlug][key] = true\n                  continue\n                } else if (\n                  data.blocks[blockSlug][key]['permission'] === true &&\n                  'where' in data.blocks[blockSlug][key]\n                ) {\n                  // otherwise do nothing so we can keep the where clause\n                  blocksPermissions = false\n                } else {\n                  blocksPermissions = false\n                  data.blocks[blockSlug][key] = false\n                  delete data.blocks[blockSlug][key]\n                  continue\n                }\n              } else {\n                throw new Error('Unexpected object in block permissions')\n              }\n            }\n          }\n        }\n      } else if (data.blocks[blockSlug] !== true) {\n        // If any value is not true, return false\n        blocksPermissions = false\n        delete data.blocks[blockSlug]\n      }\n    }\n    if (blocksPermissions) {\n      ;(data.blocks as unknown as SanitizedBlocksPermissions) = true\n    }\n  }\n\n  /**\n   * Check nested Fields permissions\n   */\n  let fieldsPermissions = true\n  if (data.fields) {\n    if (!checkAndSanitizeFieldsPermssions(data.fields)) {\n      fieldsPermissions = false\n    } else {\n      ;(data.fields as unknown as SanitizedFieldsPermissions) = true\n    }\n  }\n\n  /**\n   * Check other Permissions objects (e.g. read, write)\n   */\n  let otherPermissions = true\n  for (const key in data) {\n    if (key === 'fields' || key === 'blocks') {\n      continue\n    }\n    if (typeof data[key] === 'object') {\n      if (isPermissionObject(data[key])) {\n        if (data[key]['permission'] === true && !('where' in data[key])) {\n          // If the permission is true and there is no where clause, set the key to true\n          data[key] = true\n          continue\n        } else if (data[key]['permission'] === true && 'where' in data[key]) {\n          // otherwise do nothing so we can keep the where clause\n          otherPermissions = false\n        } else {\n          otherPermissions = false\n          data[key] = false\n          delete data[key]\n          continue\n        }\n      } else {\n        // eslint-disable-next-line no-console\n        console.error('Unexpected object in fields permissions', data, 'key:', key)\n        throw new Error('Unexpected object in fields permissions')\n      }\n    } else if (data[key] !== true) {\n      // If any value is not true, return false\n      otherPermissions = false\n    }\n  }\n\n  // If all values are true or it's an empty object, return true\n  return fieldsPermissions && blocksPermissions && otherPermissions\n}\n\n/**\n * Check if an object is a permission object.\n */\nfunction isPermissionObject(data: unknown): boolean {\n  return (\n    typeof data === 'object' && 'permission' in data! && typeof data['permission'] === 'boolean'\n  )\n}\n\n/**\n * Recursively remove empty objects from an object.\n */\nfunction cleanEmptyObjects(obj: any): void {\n  Object.keys(obj).forEach((key) => {\n    if (typeof obj[key] === 'object' && obj[key] !== null) {\n      // Recursive call\n      cleanEmptyObjects(obj[key])\n      if (Object.keys(obj[key]).length === 0) {\n        // Delete the key if the object is empty\n        delete obj[key]\n      }\n    } else if (obj[key] === null || obj[key] === undefined) {\n      delete obj[key]\n    }\n  })\n}\n\nexport function recursivelySanitizeCollections(obj: Permissions['collections']): void {\n  if (typeof obj !== 'object') {\n    return\n  }\n\n  const collectionPermissions = Object.values(obj)\n\n  for (const collectionPermission of collectionPermissions) {\n    checkAndSanitizePermissions(collectionPermission)\n  }\n}\n\nexport function recursivelySanitizeGlobals(obj: Permissions['globals']): void {\n  if (typeof obj !== 'object') {\n    return\n  }\n\n  const globalPermissions = Object.values(obj)\n\n  for (const globalPermission of globalPermissions) {\n    checkAndSanitizePermissions(globalPermission)\n  }\n}\n\n/**\n * Recursively remove empty objects and false values from an object.\n *\n * @internal\n */\nexport function sanitizePermissions(\n  data: MarkOptional<Permissions, 'canAccessAdmin'>,\n): SanitizedPermissions {\n  if (data.canAccessAdmin === false) {\n    delete data.canAccessAdmin\n  }\n\n  if (data.collections) {\n    recursivelySanitizeCollections(data.collections)\n  }\n\n  if (data.globals) {\n    recursivelySanitizeGlobals(data.globals)\n  }\n\n  // Run clean up of empty objects at the end\n  cleanEmptyObjects(data)\n\n  return data as unknown as SanitizedPermissions\n}\n"],"names":["checkAndSanitizeFieldsPermssions","data","allFieldPermissionsTrue","key","checkAndSanitizePermissions","_data","blocksPermissions","blocks","blockSlug","fields","isPermissionObject","Error","fieldsPermissions","otherPermissions","console","error","cleanEmptyObjects","obj","Object","keys","forEach","length","undefined","recursivelySanitizeCollections","collectionPermissions","values","collectionPermission","recursivelySanitizeGlobals","globalPermissions","globalPermission","sanitizePermissions","canAccessAdmin","collections","globals"],"mappings":"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"}