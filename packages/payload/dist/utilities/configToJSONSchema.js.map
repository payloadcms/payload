{"version":3,"sources":["../../src/utilities/configToJSONSchema.ts"],"sourcesContent":["import type { I18n } from '@payloadcms/translations'\nimport type { JSONSchema4, JSONSchema4TypeName } from 'json-schema'\n\nimport type { Auth } from '../auth/types.js'\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { FieldAffectingData, FlattenedField, Option } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { MissingEditorProp } from '../errors/MissingEditorProp.js'\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { generateJobsJSONSchemas } from '../queues/config/generateJobsJSONSchemas.js'\nimport { formatNames } from './formatLabels.js'\nimport { getCollectionIDFieldTypes } from './getCollectionIDFieldTypes.js'\nimport { optionsAreEqual } from './optionsAreEqual.js'\n\nconst fieldIsRequired = (field: FlattenedField): boolean => {\n  const isConditional = Boolean(field?.admin && field?.admin?.condition)\n  if (isConditional) {\n    return false\n  }\n\n  const isMarkedRequired = 'required' in field && field.required === true\n  if (fieldAffectsData(field) && isMarkedRequired) {\n    return true\n  }\n\n  // if any subfields are required, this field is required\n  if ('fields' in field && field.type !== 'array') {\n    return field.flattenedFields.some((subField) => fieldIsRequired(subField))\n  }\n\n  return false\n}\n\nfunction buildOptionEnums(options: Option[]): string[] {\n  return options.map((option) => {\n    if (typeof option === 'object' && 'value' in option) {\n      return option.value\n    }\n\n    return option\n  })\n}\n\nfunction generateEntitySchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce(\n    (acc, { slug }) => {\n      acc[slug] = {\n        $ref: `#/definitions/${slug}`,\n      }\n\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateEntitySelectSchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce(\n    (acc, { slug }) => {\n      acc[slug] = {\n        $ref: `#/definitions/${slug}_select`,\n      }\n\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateCollectionJoinsSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties = [...collections].reduce<Record<string, JSONSchema4>>(\n    (acc, { slug, joins, polymorphicJoins }) => {\n      const schema = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {},\n        required: [] as string[],\n      } satisfies JSONSchema4\n\n      for (const collectionSlug in joins) {\n        for (const join of joins[collectionSlug]!) {\n          ;(schema.properties as any)[join.joinPath] = {\n            type: 'string',\n            enum: [collectionSlug],\n          }\n          schema.required.push(join.joinPath)\n        }\n      }\n\n      for (const join of polymorphicJoins) {\n        ;(schema.properties as any)[join.joinPath] = {\n          type: 'string',\n          enum: join.field.collection,\n        }\n        schema.required.push(join.joinPath)\n      }\n\n      if (Object.keys(schema.properties).length > 0) {\n        acc[slug] = schema\n      }\n\n      return acc\n    },\n    {},\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateLocaleEntitySchemas(localization: SanitizedConfig['localization']): JSONSchema4 {\n  if (localization && 'locales' in localization && localization?.locales) {\n    const localesFromConfig = localization?.locales\n\n    const locales = [...localesFromConfig].map((locale) => {\n      return locale.code\n    }, [])\n\n    return {\n      type: 'string',\n      enum: locales,\n    }\n  }\n\n  return {\n    type: 'null',\n  }\n}\n\nfunction generateFallbackLocaleEntitySchemas(\n  localization: SanitizedConfig['localization'],\n): JSONSchema4 {\n  if (localization && 'localeCodes' in localization && localization?.localeCodes) {\n    const localeCodes = [...localization.localeCodes].map((localeCode) => {\n      return localeCode\n    }, [])\n\n    return {\n      oneOf: [\n        { type: 'string', enum: ['false', 'none', 'null'] },\n        { type: 'boolean', enum: [false] },\n        { type: 'null' },\n        { type: 'string', enum: localeCodes },\n        { type: 'array', items: { type: 'string', enum: localeCodes } },\n      ],\n    }\n  }\n\n  return {\n    type: 'null',\n  }\n}\n\nfunction generateAuthEntitySchemas(entities: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties: JSONSchema4[] = [...entities]\n    .filter(({ auth }) => Boolean(auth))\n    .map(({ slug }) => {\n      return {\n        allOf: [\n          { $ref: `#/definitions/${slug}` },\n          {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              collection: { type: 'string', enum: [slug] },\n            },\n            required: ['collection'],\n          },\n        ],\n      }\n    }, {})\n\n  return {\n    oneOf: properties,\n  }\n}\n\n/**\n * Generates the JSON Schema for database configuration\n *\n * @example { db: idType: string }\n */\nfunction generateDbEntitySchema(config: SanitizedConfig): JSONSchema4 {\n  const defaultIDType: JSONSchema4 =\n    config.db?.defaultIDType === 'number' ? { type: 'number' } : { type: 'string' }\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties: {\n      defaultIDType,\n    },\n    required: ['defaultIDType'],\n  }\n}\n\n/**\n * Returns a JSON Schema Type with 'null' added if the field is not required.\n */\nexport function withNullableJSONSchemaType(\n  fieldType: JSONSchema4TypeName,\n  isRequired: boolean,\n): JSONSchema4TypeName | JSONSchema4TypeName[] {\n  const fieldTypes = [fieldType]\n  if (isRequired) {\n    return fieldType\n  }\n  fieldTypes.push('null')\n  return fieldTypes\n}\n\nfunction entityOrFieldToJsDocs({\n  entity,\n  i18n,\n}: {\n  entity: FlattenedField | SanitizedCollectionConfig | SanitizedGlobalConfig\n  i18n?: I18n\n}): string | undefined {\n  let description: string | undefined = undefined\n  if (entity?.admin?.description) {\n    if (typeof entity?.admin?.description === 'string') {\n      description = entity?.admin?.description\n    } else if (typeof entity?.admin?.description === 'object') {\n      if (entity?.admin?.description?.en) {\n        description = entity?.admin?.description?.en\n      } else if (entity?.admin?.description?.[i18n!.language]) {\n        description = entity?.admin?.description?.[i18n!.language]\n      }\n    } else if (typeof entity?.admin?.description === 'function' && i18n) {\n      // do not evaluate description functions for generating JSDocs. The output of\n      // those can differ depending on where and when they are called, creating\n      // inconsistencies in the generated JSDocs.\n    }\n  }\n  return description\n}\nexport function fieldsToJSONSchema(\n  /**\n   * Used for relationship fields, to determine whether to use a string or number type for the ID.\n   * While there is a default ID field type set by the db adapter, they can differ on a collection-level\n   * if they have custom ID fields.\n   */\n  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },\n  fields: FlattenedField[],\n  /**\n   * Allows you to define new top-level interfaces that can be re-used in the output schema.\n   */\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  config?: SanitizedConfig,\n  i18n?: I18n,\n): {\n  properties: {\n    [k: string]: JSONSchema4\n  }\n  required: string[]\n} {\n  const requiredFieldNames = new Set<string>()\n\n  return {\n    properties: Object.fromEntries(\n      fields.reduce((fieldSchemas, field, index) => {\n        const isRequired = fieldAffectsData(field) && fieldIsRequired(field)\n\n        const fieldDescription = entityOrFieldToJsDocs({ entity: field, i18n })\n        const baseFieldSchema: JSONSchema4 = {}\n        if (fieldDescription) {\n          baseFieldSchema.description = fieldDescription\n        }\n\n        let fieldSchema: JSONSchema4\n\n        switch (field.type) {\n          case 'array': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: {\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.flattenedFields,\n                  interfaceNameDefinitions,\n                  config,\n                  i18n,\n                ),\n              },\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n            break\n          }\n          case 'blocks': {\n            // Check for a case where no blocks are provided.\n            // We need to generate an empty array for this case, note that JSON schema 4 doesn't support empty arrays\n            // so the best we can get is `unknown[]`\n            const hasBlocks = Boolean(\n              field.blockReferences ? field.blockReferences.length : field.blocks.length,\n            )\n\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: hasBlocks\n                ? {\n                    oneOf: (field.blockReferences ?? field.blocks).map((block) => {\n                      if (typeof block === 'string') {\n                        const resolvedBlock = config?.blocks?.find((b) => b.slug === block)\n                        return {\n                          $ref: `#/definitions/${resolvedBlock!.interfaceName ?? resolvedBlock!.slug}`,\n                        }\n                      }\n                      const blockFieldSchemas = fieldsToJSONSchema(\n                        collectionIDFieldTypes,\n                        block.flattenedFields,\n                        interfaceNameDefinitions,\n                        config,\n                        i18n,\n                      )\n\n                      const blockSchema: JSONSchema4 = {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          ...blockFieldSchemas.properties,\n                          blockType: {\n                            const: block.slug,\n                          },\n                        },\n                        required: ['blockType', ...blockFieldSchemas.required],\n                      }\n\n                      if (block.interfaceName) {\n                        interfaceNameDefinitions.set(block.interfaceName, blockSchema)\n\n                        return {\n                          $ref: `#/definitions/${block.interfaceName}`,\n                        }\n                      }\n\n                      return blockSchema\n                    }),\n                  }\n                : {},\n            }\n            break\n          }\n          case 'checkbox': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('boolean', isRequired),\n            }\n            break\n          }\n          case 'code':\n          case 'date':\n          case 'email':\n          case 'textarea': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('string', isRequired),\n            }\n            break\n          }\n\n          case 'group': {\n            if (fieldAffectsData(field)) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.flattenedFields,\n                  interfaceNameDefinitions,\n                  config,\n                  i18n,\n                ),\n              }\n\n              if (field.interfaceName) {\n                interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n                fieldSchema = { $ref: `#/definitions/${field.interfaceName}` }\n              }\n            }\n            break\n          }\n\n          case 'join': {\n            let items: JSONSchema4\n\n            if (Array.isArray(field.collection)) {\n              items = {\n                oneOf: field.collection.map((collection) => ({\n                  type: 'object',\n                  additionalProperties: false,\n                  properties: {\n                    relationTo: {\n                      const: collection,\n                    },\n                    value: {\n                      oneOf: [\n                        {\n                          type: collectionIDFieldTypes[collection],\n                        },\n                        {\n                          $ref: `#/definitions/${collection}`,\n                        },\n                      ],\n                    },\n                  },\n                  required: ['collectionSlug', 'value'],\n                })),\n              }\n            } else {\n              items = {\n                oneOf: [\n                  {\n                    type: collectionIDFieldTypes[field.collection],\n                  },\n                  {\n                    $ref: `#/definitions/${field.collection}`,\n                  },\n                ],\n              }\n            }\n\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                docs: {\n                  type: 'array',\n                  items,\n                },\n                hasNextPage: { type: 'boolean' },\n                totalDocs: { type: 'number' },\n              },\n            }\n            break\n          }\n\n          case 'json': {\n            fieldSchema = field.jsonSchema?.schema || {\n              ...baseFieldSchema,\n              type: ['object', 'array', 'string', 'number', 'boolean', 'null'],\n            }\n            break\n          }\n\n          case 'number': {\n            if (field.hasMany === true) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'number' },\n              }\n            } else {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('number', isRequired),\n              }\n            }\n            break\n          }\n\n          case 'point': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: [\n                {\n                  type: 'number',\n                },\n                {\n                  type: 'number',\n                },\n              ],\n              maxItems: 2,\n              minItems: 2,\n            }\n            break\n          }\n\n          case 'radio': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('string', isRequired),\n              enum: buildOptionEnums(field.options),\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n\n            break\n          }\n          case 'relationship':\n          case 'upload': {\n            if (Array.isArray(field.relationTo)) {\n              if (field.hasMany) {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    oneOf: field.relationTo.map((relation) => {\n                      return {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          relationTo: {\n                            const: relation,\n                          },\n                          value: {\n                            oneOf: [\n                              {\n                                type: collectionIDFieldTypes[relation],\n                              },\n                              {\n                                $ref: `#/definitions/${relation}`,\n                              },\n                            ],\n                          },\n                        },\n                        required: ['value', 'relationTo'],\n                      }\n                    }),\n                  },\n                }\n              } else {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  oneOf: field.relationTo.map((relation) => {\n                    return {\n                      type: withNullableJSONSchemaType('object', isRequired),\n                      additionalProperties: false,\n                      properties: {\n                        relationTo: {\n                          const: relation,\n                        },\n                        value: {\n                          oneOf: [\n                            {\n                              type: collectionIDFieldTypes[relation],\n                            },\n                            {\n                              $ref: `#/definitions/${relation}`,\n                            },\n                          ],\n                        },\n                      },\n                      required: ['value', 'relationTo'],\n                    }\n                  }),\n                }\n              }\n            } else if (field.hasMany) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  oneOf: [\n                    {\n                      type: collectionIDFieldTypes[field.relationTo],\n                    },\n                    {\n                      $ref: `#/definitions/${field.relationTo}`,\n                    },\n                  ],\n                },\n              }\n            } else {\n              fieldSchema = {\n                ...baseFieldSchema,\n                oneOf: [\n                  {\n                    type: withNullableJSONSchemaType(\n                      collectionIDFieldTypes[field.relationTo]!,\n                      isRequired,\n                    ),\n                  },\n                  { $ref: `#/definitions/${field.relationTo}` },\n                ],\n              }\n            }\n\n            break\n          }\n          case 'richText': {\n            if (!field?.editor) {\n              throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n            }\n            if (typeof field.editor === 'function') {\n              throw new Error('Attempted to access unsanitized rich text editor.')\n            }\n            if (field.editor.outputSchema) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                ...field.editor.outputSchema({\n                  collectionIDFieldTypes,\n                  config,\n                  field,\n                  i18n,\n                  interfaceNameDefinitions,\n                  isRequired,\n                }),\n              }\n            } else {\n              // Maintain backwards compatibility with existing rich text editors\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'object',\n                },\n              }\n            }\n\n            break\n          }\n\n          case 'select': {\n            const optionEnums = buildOptionEnums(field.options)\n            // We get the previous field to check for a date in the case of a timezone select\n            // This works because timezone selects are always inserted right after a date with 'timezone: true'\n            const previousField = fields?.[index - 1]\n            const isTimezoneField =\n              previousField?.type === 'date' && previousField.timezone && field.name.includes('_tz')\n\n            // Check if the timezone field's options match the global config's supported timezones\n            const hasMatchingGlobalTimezones =\n              isTimezoneField &&\n              config &&\n              optionsAreEqual(field.options, config.admin?.timezones?.supportedTimezones)\n\n            // Timezone selects should reference the supportedTimezones definition\n            // only if the field's options match the global config\n            if (isTimezoneField && hasMatchingGlobalTimezones) {\n              fieldSchema = {\n                $ref: `#/definitions/supportedTimezones`,\n              }\n            } else {\n              if (field.hasMany) {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    type: 'string',\n                  },\n                }\n                if (optionEnums?.length) {\n                  ;(fieldSchema.items as JSONSchema4).enum = optionEnums\n                }\n              } else {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  type: withNullableJSONSchemaType('string', isRequired),\n                }\n                if (optionEnums?.length) {\n                  fieldSchema.enum = optionEnums\n                }\n              }\n\n              if (field.interfaceName) {\n                interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n                fieldSchema = {\n                  $ref: `#/definitions/${field.interfaceName}`,\n                }\n              }\n              break\n            }\n\n            break\n          }\n          case 'tab': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: 'object',\n              additionalProperties: false,\n              ...fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                field.flattenedFields,\n                interfaceNameDefinitions,\n                config,\n                i18n,\n              ),\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = { $ref: `#/definitions/${field.interfaceName}` }\n            }\n            break\n          }\n\n          case 'text':\n            if (field.hasMany === true) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'string' },\n              }\n            } else {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('string', isRequired),\n              }\n            }\n            break\n\n          default: {\n            break\n          }\n        }\n\n        if ('typescriptSchema' in field && field?.typescriptSchema?.length) {\n          for (const schema of field.typescriptSchema) {\n            fieldSchema = schema({ jsonSchema: fieldSchema! })\n          }\n        }\n\n        if (fieldSchema! && fieldAffectsData(field)) {\n          if (isRequired && fieldSchema.required !== false) {\n            requiredFieldNames.add(field.name)\n          }\n          fieldSchemas.set(field.name, fieldSchema)\n        }\n\n        return fieldSchemas\n      }, new Map<string, JSONSchema4>()),\n    ),\n    required: Array.from(requiredFieldNames),\n  }\n}\n\n// This function is part of the public API and is exported through payload/utilities\nexport function entityToJSONSchema(\n  config: SanitizedConfig,\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig,\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  defaultIDType: 'number' | 'text',\n  collectionIDFieldTypes?: { [key: string]: 'number' | 'string' },\n  i18n?: I18n,\n): JSONSchema4 {\n  if (!collectionIDFieldTypes) {\n    collectionIDFieldTypes = getCollectionIDFieldTypes({ config, defaultIDType })\n  }\n\n  const title = entity.typescript?.interface\n    ? entity.typescript.interface\n    : formatNames(entity.slug).singular\n\n  let mutableFields = [...entity.flattenedFields]\n\n  const idField: FieldAffectingData = { name: 'id', type: defaultIDType as 'text', required: true }\n  const customIdField = mutableFields.find((field) => field.name === 'id') as FieldAffectingData\n\n  if (customIdField && customIdField.type !== 'group' && customIdField.type !== 'tab') {\n    mutableFields = mutableFields.map((field) => {\n      if (field === customIdField) {\n        return { ...field, required: true }\n      }\n\n      return field\n    })\n  } else {\n    mutableFields.unshift(idField)\n  }\n\n  // mark timestamp fields required\n  if ('timestamps' in entity && entity.timestamps !== false) {\n    mutableFields = mutableFields.map((field) => {\n      if (field.name === 'createdAt' || field.name === 'updatedAt') {\n        return {\n          ...field,\n          required: true,\n        }\n      }\n      return field\n    })\n  }\n\n  if (\n    'auth' in entity &&\n    entity.auth &&\n    (!entity.auth?.disableLocalStrategy ||\n      (typeof entity.auth?.disableLocalStrategy === 'object' &&\n        entity.auth.disableLocalStrategy.enableFields))\n  ) {\n    mutableFields.push({\n      name: 'password',\n      type: 'text',\n    })\n  }\n\n  const jsonSchema: JSONSchema4 = {\n    type: 'object',\n    additionalProperties: false,\n    title,\n    ...fieldsToJSONSchema(\n      collectionIDFieldTypes,\n      mutableFields,\n      interfaceNameDefinitions,\n      config,\n      i18n,\n    ),\n  }\n\n  const entityDescription = entityOrFieldToJsDocs({ entity, i18n })\n\n  if (entityDescription) {\n    jsonSchema.description = entityDescription\n  }\n\n  return jsonSchema\n}\n\nexport function fieldsToSelectJSONSchema({\n  config,\n  fields,\n  interfaceNameDefinitions,\n}: {\n  config: SanitizedConfig\n  fields: FlattenedField[]\n  interfaceNameDefinitions: Map<string, JSONSchema4>\n}): JSONSchema4 {\n  const schema: JSONSchema4 = {\n    type: 'object',\n    additionalProperties: false,\n    properties: {},\n  }\n\n  for (const field of fields) {\n    switch (field.type) {\n      case 'array':\n      case 'group':\n      case 'tab': {\n        let fieldSchema: JSONSchema4 = fieldsToSelectJSONSchema({\n          config,\n          fields: field.flattenedFields,\n          interfaceNameDefinitions,\n        })\n\n        if (field.interfaceName) {\n          const definition = `${field.interfaceName}_select`\n          interfaceNameDefinitions.set(definition, fieldSchema)\n\n          fieldSchema = {\n            $ref: `#/definitions/${definition}`,\n          }\n        }\n\n        schema.properties![field.name] = {\n          oneOf: [\n            {\n              type: 'boolean',\n            },\n            fieldSchema,\n          ],\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksSchema: JSONSchema4 = {\n          type: 'object',\n          additionalProperties: false,\n          properties: {},\n        }\n\n        for (const block of field.blockReferences ?? field.blocks) {\n          if (typeof block === 'string') {\n            continue // TODO\n          }\n\n          let blockSchema = fieldsToSelectJSONSchema({\n            config,\n            fields: block.flattenedFields,\n            interfaceNameDefinitions,\n          })\n\n          if (block.interfaceName) {\n            const definition = `${block.interfaceName}_select`\n            interfaceNameDefinitions.set(definition, blockSchema)\n            blockSchema = {\n              $ref: `#/definitions/${definition}`,\n            }\n          }\n\n          blocksSchema.properties![block.slug] = {\n            oneOf: [\n              {\n                type: 'boolean',\n              },\n              blockSchema,\n            ],\n          }\n        }\n\n        schema.properties![field.name] = {\n          oneOf: [\n            {\n              type: 'boolean',\n            },\n            blocksSchema,\n          ],\n        }\n\n        break\n      }\n\n      default:\n        schema.properties![field.name] = {\n          type: 'boolean',\n        }\n        break\n    }\n  }\n\n  return schema\n}\n\nconst fieldType: JSONSchema4 = {\n  type: 'string',\n  required: false,\n}\nconst generateAuthFieldTypes = ({\n  type,\n  loginWithUsername,\n}: {\n  loginWithUsername: Auth['loginWithUsername']\n  type: 'forgotOrUnlock' | 'login' | 'register'\n}): JSONSchema4 => {\n  if (loginWithUsername) {\n    switch (type) {\n      case 'forgotOrUnlock': {\n        if (loginWithUsername.allowEmailLogin) {\n          // allow email or username for unlock/forgot-password\n          return {\n            additionalProperties: false,\n            oneOf: [\n              {\n                additionalProperties: false,\n                properties: { email: fieldType },\n                required: ['email'],\n              },\n              {\n                additionalProperties: false,\n                properties: { username: fieldType },\n                required: ['username'],\n              },\n            ],\n          }\n        } else {\n          // allow only username for unlock/forgot-password\n          return {\n            additionalProperties: false,\n            properties: { username: fieldType },\n            required: ['username'],\n          }\n        }\n      }\n\n      case 'login': {\n        if (loginWithUsername.allowEmailLogin) {\n          // allow username or email and require password for login\n          return {\n            additionalProperties: false,\n            oneOf: [\n              {\n                additionalProperties: false,\n                properties: { email: fieldType, password: fieldType },\n                required: ['email', 'password'],\n              },\n              {\n                additionalProperties: false,\n                properties: { password: fieldType, username: fieldType },\n                required: ['username', 'password'],\n              },\n            ],\n          }\n        } else {\n          // allow only username and password for login\n          return {\n            additionalProperties: false,\n            properties: {\n              password: fieldType,\n              username: fieldType,\n            },\n            required: ['username', 'password'],\n          }\n        }\n      }\n\n      case 'register': {\n        const requiredFields: ('email' | 'password' | 'username')[] = ['password']\n        const properties: {\n          email?: JSONSchema4['properties']\n          password?: JSONSchema4['properties']\n          username?: JSONSchema4['properties']\n        } = {\n          password: fieldType,\n          username: fieldType,\n        }\n\n        if (loginWithUsername.requireEmail) {\n          requiredFields.push('email')\n        }\n        if (loginWithUsername.requireUsername) {\n          requiredFields.push('username')\n        }\n        if (loginWithUsername.requireEmail || loginWithUsername.allowEmailLogin) {\n          properties.email = fieldType\n        }\n\n        return {\n          additionalProperties: false,\n          properties,\n          required: requiredFields,\n        }\n      }\n    }\n  }\n\n  // default email (and password for login/register)\n  return {\n    additionalProperties: false,\n    properties: { email: fieldType, password: fieldType },\n    required: ['email', 'password'],\n  }\n}\n\nexport function authCollectionToOperationsJSONSchema(\n  config: SanitizedCollectionConfig,\n): JSONSchema4 {\n  const loginWithUsername = config.auth?.loginWithUsername\n  const loginUserFields: JSONSchema4 = generateAuthFieldTypes({ type: 'login', loginWithUsername })\n  const forgotOrUnlockUserFields: JSONSchema4 = generateAuthFieldTypes({\n    type: 'forgotOrUnlock',\n    loginWithUsername,\n  })\n  const registerUserFields: JSONSchema4 = generateAuthFieldTypes({\n    type: 'register',\n    loginWithUsername,\n  })\n\n  const properties: JSONSchema4['properties'] = {\n    forgotPassword: forgotOrUnlockUserFields,\n    login: loginUserFields,\n    registerFirstUser: registerUserFields,\n    unlock: forgotOrUnlockUserFields,\n  }\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n    title: `${formatNames(config.slug).singular}AuthOperations`,\n  }\n}\n\n// Generates the JSON Schema for supported timezones\nexport function timezonesToJSONSchema(\n  supportedTimezones: SanitizedConfig['admin']['timezones']['supportedTimezones'],\n): JSONSchema4 {\n  return {\n    description: 'Supported timezones in IANA format.',\n    enum: supportedTimezones.map((timezone) =>\n      typeof timezone === 'string' ? timezone : timezone.value,\n    ),\n  }\n}\n\nfunction generateAuthOperationSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties = collections.reduce(\n    (acc, collection) => {\n      if (collection.auth) {\n        acc[collection.slug] = {\n          $ref: `#/definitions/auth/${collection.slug}`,\n        }\n      }\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\n/**\n * This is used for generating the TypeScript types (payload-types.ts) with the payload generate:types command.\n */\nexport function configToJSONSchema(\n  config: SanitizedConfig,\n  defaultIDType?: 'number' | 'text',\n  i18n?: I18n,\n): JSONSchema4 {\n  // a mutable Map to store custom top-level `interfaceName` types. Fields with an `interfaceName` property will be moved to the top-level definitions here\n  const interfaceNameDefinitions: Map<string, JSONSchema4> = new Map()\n\n  //  Used for relationship fields, to determine whether to use a string or number type for the ID.\n  const collectionIDFieldTypes = getCollectionIDFieldTypes({\n    config,\n    defaultIDType: defaultIDType!,\n  })\n\n  // Collections and Globals have to be moved to the top-level definitions as well. Reason: The top-level type will be the `Config` type - we don't want all collection and global\n  // types to be inlined inside the `Config` type\n\n  const entities: {\n    entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n    type: 'collection' | 'global'\n  }[] = [\n    ...config.globals.map((global) => ({ type: 'global' as const, entity: global })),\n    ...config.collections.map((collection) => ({\n      type: 'collection' as const,\n      entity: collection,\n    })),\n  ]\n\n  const entityDefinitions: { [k: string]: JSONSchema4 } = entities.reduce(\n    (acc, { type, entity }) => {\n      acc[entity.slug] = entityToJSONSchema(\n        config,\n        entity,\n        interfaceNameDefinitions,\n        defaultIDType!,\n        collectionIDFieldTypes,\n        i18n,\n      )\n      const select = fieldsToSelectJSONSchema({\n        config,\n        fields: entity.flattenedFields,\n        interfaceNameDefinitions,\n      })\n\n      if (type === 'global') {\n        select.properties!.globalType = {\n          type: 'boolean',\n        }\n      }\n\n      acc[`${entity.slug}_select`] = {\n        type: 'object',\n        additionalProperties: false,\n        ...select,\n      }\n\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  const timezoneDefinitions = timezonesToJSONSchema(config.admin.timezones.supportedTimezones)\n\n  const authOperationDefinitions = [...config.collections]\n    .filter(({ auth }) => Boolean(auth))\n    .reduce(\n      (acc, authCollection) => {\n        acc.auth[authCollection.slug] = authCollectionToOperationsJSONSchema(authCollection)\n        return acc\n      },\n      { auth: {} as Record<string, JSONSchema4> },\n    )\n\n  const jobsSchemas = config.jobs\n    ? generateJobsJSONSchemas(\n        config,\n        config.jobs,\n        interfaceNameDefinitions,\n        collectionIDFieldTypes,\n        i18n,\n      )\n    : {}\n\n  const blocksDefinition: JSONSchema4 | undefined = {\n    type: 'object',\n    additionalProperties: false,\n    properties: {},\n    required: [],\n  }\n  if (config?.blocks?.length) {\n    for (const block of config.blocks) {\n      const blockFieldSchemas = fieldsToJSONSchema(\n        collectionIDFieldTypes,\n        block.flattenedFields,\n        interfaceNameDefinitions,\n        config,\n        i18n,\n      )\n\n      const blockSchema: JSONSchema4 = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n          ...blockFieldSchemas.properties,\n          blockType: {\n            const: block.slug,\n          },\n        },\n        required: ['blockType', ...blockFieldSchemas.required],\n      }\n\n      const interfaceName = block.interfaceName ?? block.slug\n      interfaceNameDefinitions.set(interfaceName, blockSchema)\n\n      blocksDefinition.properties![block.slug] = {\n        $ref: `#/definitions/${interfaceName}`,\n      }\n      ;(blocksDefinition.required as string[]).push(block.slug)\n    }\n  }\n\n  let jsonSchema: JSONSchema4 = {\n    additionalProperties: false,\n    definitions: {\n      supportedTimezones: timezoneDefinitions,\n      ...entityDefinitions,\n      ...Object.fromEntries(interfaceNameDefinitions),\n      ...authOperationDefinitions,\n    },\n    // These properties here will be very simple, as all the complexity is in the definitions. These are just the properties for the top-level `Config` type\n    type: 'object',\n    properties: {\n      auth: generateAuthOperationSchemas(config.collections),\n      blocks: blocksDefinition,\n      collections: generateEntitySchemas(config.collections || []),\n      collectionsJoins: generateCollectionJoinsSchemas(config.collections || []),\n      collectionsSelect: generateEntitySelectSchemas(config.collections || []),\n      db: generateDbEntitySchema(config),\n      fallbackLocale: generateFallbackLocaleEntitySchemas(config.localization),\n      globals: generateEntitySchemas(config.globals || []),\n      globalsSelect: generateEntitySelectSchemas(config.globals || []),\n      locale: generateLocaleEntitySchemas(config.localization),\n      ...(config.typescript?.strictDraftTypes\n        ? {\n            strictDraftTypes: {\n              type: 'boolean',\n              const: true,\n            },\n          }\n        : {}),\n      user: generateAuthEntitySchemas(config.collections),\n    },\n    required: [\n      'user',\n      'locale',\n      'fallbackLocale',\n      'collections',\n      'collectionsSelect',\n      'collectionsJoins',\n      'globalsSelect',\n      ...(config.typescript?.strictDraftTypes ? ['strictDraftTypes'] : []),\n      'globals',\n      'auth',\n      'db',\n      'jobs',\n      'blocks',\n    ],\n    title: 'Config',\n  }\n\n  if (jobsSchemas.definitions?.size) {\n    for (const [key, value] of jobsSchemas.definitions) {\n      jsonSchema.definitions![key] = value\n    }\n  }\n  if (jobsSchemas.properties) {\n    jsonSchema.properties!.jobs = {\n      type: 'object',\n      additionalProperties: false,\n      properties: jobsSchemas.properties,\n      required: ['tasks', 'workflows'],\n    }\n  }\n\n  if (config?.typescript?.schema?.length) {\n    for (const schema of config.typescript.schema) {\n      jsonSchema = schema({ collectionIDFieldTypes, config, i18n: i18n!, jsonSchema })\n    }\n  }\n\n  return jsonSchema\n}\n"],"names":["MissingEditorProp","fieldAffectsData","generateJobsJSONSchemas","formatNames","getCollectionIDFieldTypes","optionsAreEqual","fieldIsRequired","field","isConditional","Boolean","admin","condition","isMarkedRequired","required","type","flattenedFields","some","subField","buildOptionEnums","options","map","option","value","generateEntitySchemas","entities","properties","reduce","acc","slug","$ref","additionalProperties","Object","keys","generateEntitySelectSchemas","generateCollectionJoinsSchemas","collections","joins","polymorphicJoins","schema","collectionSlug","join","joinPath","enum","push","collection","length","generateLocaleEntitySchemas","localization","locales","localesFromConfig","locale","code","generateFallbackLocaleEntitySchemas","localeCodes","localeCode","oneOf","items","generateAuthEntitySchemas","filter","auth","allOf","generateDbEntitySchema","config","defaultIDType","db","withNullableJSONSchemaType","fieldType","isRequired","fieldTypes","entityOrFieldToJsDocs","entity","i18n","description","undefined","en","language","fieldsToJSONSchema","collectionIDFieldTypes","fields","interfaceNameDefinitions","requiredFieldNames","Set","fromEntries","fieldSchemas","index","fieldDescription","baseFieldSchema","fieldSchema","interfaceName","set","hasBlocks","blockReferences","blocks","block","resolvedBlock","find","b","blockFieldSchemas","blockSchema","blockType","const","Array","isArray","relationTo","docs","hasNextPage","totalDocs","jsonSchema","hasMany","maxItems","minItems","relation","editor","Error","outputSchema","optionEnums","previousField","isTimezoneField","timezone","name","includes","hasMatchingGlobalTimezones","timezones","supportedTimezones","typescriptSchema","add","Map","from","entityToJSONSchema","title","typescript","interface","singular","mutableFields","idField","customIdField","unshift","timestamps","disableLocalStrategy","enableFields","entityDescription","fieldsToSelectJSONSchema","definition","blocksSchema","generateAuthFieldTypes","loginWithUsername","allowEmailLogin","email","username","password","requiredFields","requireEmail","requireUsername","authCollectionToOperationsJSONSchema","loginUserFields","forgotOrUnlockUserFields","registerUserFields","forgotPassword","login","registerFirstUser","unlock","timezonesToJSONSchema","generateAuthOperationSchemas","configToJSONSchema","globals","global","entityDefinitions","select","globalType","timezoneDefinitions","authOperationDefinitions","authCollection","jobsSchemas","jobs","blocksDefinition","definitions","collectionsJoins","collectionsSelect","fallbackLocale","globalsSelect","strictDraftTypes","user","size","key"],"mappings":"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"}