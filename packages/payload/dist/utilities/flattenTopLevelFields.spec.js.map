{"version":3,"sources":["../../src/utilities/flattenTopLevelFields.spec.ts"],"sourcesContent":["import { I18nClient } from '@payloadcms/translations'\nimport { describe, it, expect } from 'vitest'\nimport { ClientField } from '../fields/config/client.js'\nimport { flattenTopLevelFields } from './flattenTopLevelFields.js'\n\ndescribe('flattenFields', () => {\n  const i18n: I18nClient = {\n    t: (value: string) => value,\n    language: 'en',\n    dateFNS: {} as any,\n    dateFNSKey: 'en-US',\n    fallbackLanguage: 'en',\n    translations: {},\n  }\n\n  const baseField: ClientField = {\n    type: 'text',\n    name: 'title',\n    label: 'Title',\n  }\n\n  describe('basic flattening', () => {\n    it('should return flat list for top-level fields', () => {\n      const fields = [baseField]\n      const result = flattenTopLevelFields(fields)\n      expect(result).toHaveLength(1)\n      expect(result[0].name).toBe('title')\n    })\n  })\n\n  describe('group flattening', () => {\n    it('should flatten fields inside group with accessor and labelWithPrefix with moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          name: 'meta',\n          label: 'Meta Info',\n          fields: [\n            {\n              type: 'text',\n              name: 'slug',\n              label: 'Slug',\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(2)\n      expect(result[1].name).toBe('slug')\n      expect(result[1].accessor).toBe('meta.slug')\n      expect(result[1].labelWithPrefix).toBe('Meta Info > Slug')\n    })\n\n    it('should NOT flatten fields inside group without moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          name: 'meta',\n          label: 'Meta Info',\n          fields: [\n            {\n              type: 'text',\n              name: 'slug',\n              label: 'Slug',\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields)\n\n      // Should return the group as a top-level item, not the inner field\n      expect(result).toHaveLength(1)\n      expect(result[0].name).toBe('meta')\n      expect('fields' in result[0]).toBe(true)\n      expect('accessor' in result[0]).toBe(false)\n      expect('labelWithPrefix' in result[0]).toBe(false)\n    })\n\n    it('should correctly handle deeply nested group fields with and without moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          name: 'outer',\n          label: 'Outer',\n          fields: [\n            {\n              type: 'group',\n              name: 'inner',\n              label: 'Inner',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'deep',\n                  label: 'Deep Field',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const hoisted = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(hoisted).toHaveLength(3)\n      expect(hoisted[2].name).toBe('deep')\n      expect(hoisted[2].accessor).toBe('outer.inner.deep')\n      expect(hoisted[2].labelWithPrefix).toBe('Outer > Inner > Deep Field')\n\n      const nonHoisted = flattenTopLevelFields(fields)\n\n      expect(nonHoisted).toHaveLength(1)\n      expect(nonHoisted[0].name).toBe('outer')\n      expect('fields' in nonHoisted[0]).toBe(true)\n      expect('accessor' in nonHoisted[0]).toBe(false)\n      expect('labelWithPrefix' in nonHoisted[0]).toBe(false)\n    })\n\n    it('should hoist fields from unnamed group if moveSubFieldsToTop is true', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          label: 'Unnamed group',\n          fields: [\n            {\n              type: 'text',\n              name: 'insideUnnamedGroup',\n            },\n          ],\n        },\n      ]\n\n      const withExtract = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      // Should include top level group and its nested field as a top-level field\n      expect(withExtract).toHaveLength(2)\n      expect(withExtract[1].type).toBe('text')\n      expect(withExtract[1].accessor).toBeUndefined()\n      expect(withExtract[1].labelWithPrefix).toBeUndefined()\n\n      const withoutExtract = flattenTopLevelFields(fields)\n\n      // Should return the group as a top-level item, not the inner field\n      expect(withoutExtract).toHaveLength(1)\n      expect(withoutExtract[0].type).toBe('text')\n      expect(withoutExtract[0].accessor).toBeUndefined()\n      expect(withoutExtract[0].labelWithPrefix).toBeUndefined()\n    })\n\n    it('should hoist using deepest named group only if parents are unnamed', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'group',\n          label: 'Outer',\n          fields: [\n            {\n              type: 'group',\n              label: 'Middle',\n              fields: [\n                {\n                  type: 'group',\n                  name: 'namedGroup',\n                  label: 'Named Group',\n                  fields: [\n                    {\n                      type: 'group',\n                      label: 'Inner',\n                      fields: [\n                        {\n                          type: 'text',\n                          name: 'nestedField',\n                          label: 'Nested Field',\n                        },\n                      ],\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const hoistedResult = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(hoistedResult).toHaveLength(5)\n      expect(hoistedResult[4].name).toBe('nestedField')\n      expect(hoistedResult[4].accessor).toBe('namedGroup.nestedField')\n      expect(hoistedResult[4].labelWithPrefix).toBe('Named Group > Nested Field')\n\n      const nonHoistedResult = flattenTopLevelFields(fields)\n\n      expect(nonHoistedResult).toHaveLength(1)\n      expect(nonHoistedResult[0].type).toBe('group')\n      expect('fields' in nonHoistedResult[0]).toBe(true)\n      expect('accessor' in nonHoistedResult[0]).toBe(false)\n      expect('labelWithPrefix' in nonHoistedResult[0]).toBe(false)\n    })\n  })\n\n  describe('array and block edge cases', () => {\n    it('should NOT flatten fields in arrays or blocks with moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'array',\n          name: 'items',\n          label: 'Items',\n          fields: [\n            {\n              type: 'text',\n              name: 'label',\n              label: 'Label',\n            },\n          ],\n        },\n        {\n          type: 'blocks',\n          name: 'layout',\n          blocks: [\n            {\n              slug: 'block',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'content',\n                  label: 'Content',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n      expect(result).toHaveLength(2)\n      expect(result[0].name).toBe('items')\n      expect(result[1].name).toBe('layout')\n    })\n\n    it('should NOT flatten fields in arrays or blocks without moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'array',\n          name: 'things',\n          label: 'Things',\n          fields: [\n            {\n              type: 'text',\n              name: 'thingLabel',\n              label: 'Thing Label',\n            },\n          ],\n        },\n        {\n          type: 'blocks',\n          name: 'contentBlocks',\n          blocks: [\n            {\n              slug: 'content',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'body',\n                  label: 'Body',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields)\n      expect(result).toHaveLength(2)\n      expect(result[0].name).toBe('things')\n      expect(result[1].name).toBe('contentBlocks')\n    })\n\n    it('should not hoist group fields nested inside arrays', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'array',\n          name: 'arrayField',\n          label: 'Array Field',\n          fields: [\n            {\n              type: 'group',\n              name: 'groupInArray',\n              label: 'Group In Array',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'nestedInArrayGroup',\n                  label: 'Nested In Array Group',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n      expect(result).toHaveLength(1)\n      expect(result[0].name).toBe('arrayField')\n    })\n\n    it('should not hoist group fields nested inside blocks', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'blocks',\n          name: 'blockField',\n          blocks: [\n            {\n              slug: 'exampleBlock',\n              fields: [\n                {\n                  type: 'group',\n                  name: 'groupInBlock',\n                  label: 'Group In Block',\n                  fields: [\n                    {\n                      type: 'text',\n                      name: 'nestedInBlockGroup',\n                      label: 'Nested In Block Group',\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n      expect(result).toHaveLength(1)\n      expect(result[0].name).toBe('blockField')\n    })\n  })\n\n  describe('row and collapsible behavior', () => {\n    it('should recursively flatten collapsible fields regardless of moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'collapsible',\n          label: 'Collapsible',\n          fields: [\n            {\n              type: 'text',\n              name: 'nickname',\n              label: 'Nickname',\n            },\n          ],\n        },\n      ]\n\n      const defaultResult = flattenTopLevelFields(fields)\n      const hoistedResult = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n\n      for (const result of [defaultResult, hoistedResult]) {\n        expect(result).toHaveLength(1)\n        expect(result[0].name).toBe('nickname')\n        expect('accessor' in result[0]).toBe(false)\n        expect('labelWithPrefix' in result[0]).toBe(false)\n      }\n    })\n\n    it('should recursively flatten row fields regardless of moveSubFieldsToTop', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'row',\n          fields: [\n            {\n              type: 'text',\n              name: 'firstName',\n              label: 'First Name',\n            },\n            {\n              type: 'text',\n              name: 'lastName',\n              label: 'Last Name',\n            },\n          ],\n        },\n      ]\n\n      const defaultResult = flattenTopLevelFields(fields)\n      const hoistedResult = flattenTopLevelFields(fields, { moveSubFieldsToTop: true })\n\n      for (const result of [defaultResult, hoistedResult]) {\n        expect(result).toHaveLength(2)\n        expect(result[0].name).toBe('firstName')\n        expect(result[1].name).toBe('lastName')\n        expect('accessor' in result[0]).toBe(false)\n        expect('labelWithPrefix' in result[0]).toBe(false)\n      }\n    })\n\n    it('should hoist named group fields inside rows', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'row',\n          fields: [\n            {\n              type: 'group',\n              name: 'groupInRow',\n              label: 'Group In Row',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'nestedInRowGroup',\n                  label: 'Nested In Row Group',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(2)\n      expect(result[1].accessor).toBe('groupInRow.nestedInRowGroup')\n      expect(result[1].labelWithPrefix).toBe('Group In Row > Nested In Row Group')\n    })\n\n    it('should hoist named group fields inside collapsibles', () => {\n      const fields: ClientField[] = [\n        {\n          type: 'collapsible',\n          label: 'Collapsible',\n          fields: [\n            {\n              type: 'group',\n              name: 'groupInCollapsible',\n              label: 'Group In Collapsible',\n              fields: [\n                {\n                  type: 'text',\n                  name: 'nestedInCollapsibleGroup',\n                  label: 'Nested In Collapsible Group',\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(fields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(2)\n      expect(result[1].accessor).toBe('groupInCollapsible.nestedInCollapsibleGroup')\n      expect(result[1].labelWithPrefix).toBe('Group In Collapsible > Nested In Collapsible Group')\n    })\n  })\n\n  describe('tab integration', () => {\n    const namedTabFields: ClientField[] = [\n      {\n        type: 'tabs',\n        tabs: [\n          {\n            label: 'Tab One',\n            name: 'tabOne',\n            fields: [\n              {\n                type: 'array',\n                name: 'array',\n                fields: [\n                  {\n                    type: 'text',\n                    name: 'text',\n                  },\n                ],\n              },\n              {\n                type: 'row',\n                fields: [\n                  {\n                    name: 'arrayInRow',\n                    type: 'array',\n                    fields: [\n                      {\n                        name: 'textInArrayInRow',\n                        type: 'text',\n                      },\n                    ],\n                  },\n                ],\n              },\n              {\n                type: 'text',\n                name: 'textInTab',\n                label: 'Text In Tab',\n              },\n              {\n                type: 'group',\n                name: 'groupInTab',\n                label: 'Group In Tab',\n                fields: [\n                  {\n                    type: 'text',\n                    name: 'nestedTextInTabGroup',\n                    label: 'Nested Text In Tab Group',\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      },\n    ]\n\n    const unnamedTabFields: ClientField[] = [\n      {\n        type: 'tabs',\n        tabs: [\n          {\n            label: 'Tab One',\n            fields: [\n              {\n                type: 'array',\n                name: 'array',\n                fields: [\n                  {\n                    type: 'text',\n                    name: 'text',\n                  },\n                ],\n              },\n              {\n                type: 'row',\n                fields: [\n                  {\n                    name: 'arrayInRow',\n                    type: 'array',\n                    fields: [\n                      {\n                        name: 'textInArrayInRow',\n                        type: 'text',\n                      },\n                    ],\n                  },\n                ],\n              },\n              {\n                type: 'text',\n                name: 'textInTab',\n                label: 'Text In Tab',\n              },\n            ],\n          },\n        ],\n      },\n    ]\n\n    it('should hoist named group fields inside unamed tabs when moveSubFieldsToTop is true', () => {\n      const unnamedTabWithNamedGroup: ClientField[] = [\n        {\n          type: 'tabs',\n          tabs: [\n            {\n              label: 'Tab One',\n              fields: [\n                {\n                  type: 'group',\n                  name: 'groupInTab',\n                  label: 'Group In Tab',\n                  fields: [\n                    {\n                      type: 'text',\n                      name: 'nestedInTabGroup',\n                      label: 'Nested In Tab Group',\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const result = flattenTopLevelFields(unnamedTabWithNamedGroup, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(2)\n      expect(result[1].accessor).toBe('groupInTab.nestedInTabGroup')\n      expect(result[1].labelWithPrefix).toBe('Group In Tab > Nested In Tab Group')\n    })\n\n    it('should hoist fields inside unnamed groups inside unnamed tabs when moveSubFieldsToTop is true', () => {\n      const unnamedTabWithUnnamedGroup: ClientField[] = [\n        {\n          type: 'tabs',\n          tabs: [\n            {\n              label: 'Tab One',\n              fields: [\n                {\n                  type: 'group',\n                  label: 'Unnamed Group In Tab',\n                  fields: [\n                    {\n                      type: 'text',\n                      name: 'nestedInUnnamedGroup',\n                      label: 'Nested In Unnamed Group',\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n      ]\n\n      const defaultResult = flattenTopLevelFields(unnamedTabWithUnnamedGroup)\n\n      expect(defaultResult).toHaveLength(1)\n      expect(defaultResult[0].type).toBe('text')\n      expect(defaultResult[0].label).toBe('Nested In Unnamed Group')\n      expect('accessor' in defaultResult[0]).toBe(false)\n      expect('labelWithPrefix' in defaultResult[0]).toBe(false)\n\n      const hoistedResult = flattenTopLevelFields(unnamedTabWithUnnamedGroup, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(hoistedResult).toHaveLength(2)\n      const hoistedField = hoistedResult[1]\n      expect(hoistedField.name).toBe('nestedInUnnamedGroup')\n      expect(hoistedField.accessor).toBeUndefined()\n      expect(hoistedField.labelWithPrefix).toBeUndefined()\n    })\n\n    it('should properly hoist fields inside named tabs when moveSubFieldsToTop is true', () => {\n      const result = flattenTopLevelFields(namedTabFields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(result).toHaveLength(5)\n      expect(result[0].accessor).toBe('tabOne.array')\n      expect(result[0].labelWithPrefix).toBe('Tab One > array')\n      expect(result[1].accessor).toBe('tabOne.arrayInRow')\n      expect(result[1].labelWithPrefix).toBe('Tab One > arrayInRow')\n      expect(result[2].accessor).toBe('tabOne.textInTab')\n      expect(result[2].labelWithPrefix).toBe('Tab One > Text In Tab')\n      expect(result[4].accessor).toBe('tabOne.groupInTab.nestedTextInTabGroup')\n      expect(result[4].labelWithPrefix).toBe('Tab One > Group In Tab > Nested Text In Tab Group')\n    })\n\n    it('should NOT hoist fields inside named tabs when moveSubFieldsToTop is false', () => {\n      const result = flattenTopLevelFields(namedTabFields)\n\n      // We expect one top-level field: the tabs container itself is *not* hoisted\n      expect(result).toHaveLength(1)\n\n      const tabField = result[0]\n      expect(tabField.type).toBe('tab')\n\n      // Confirm nested fields are NOT hoisted: no accessors or labelWithPrefix at the top level\n      expect('accessor' in tabField).toBe(false)\n      expect('labelWithPrefix' in tabField).toBe(false)\n    })\n\n    it('should hoist fields inside unnamed tabs regardless of moveSubFieldsToTop', () => {\n      const resultDefault = flattenTopLevelFields(unnamedTabFields)\n      const resultHoisted = flattenTopLevelFields(unnamedTabFields, {\n        moveSubFieldsToTop: true,\n        i18n,\n      })\n\n      expect(resultDefault).toHaveLength(3)\n      expect(resultHoisted).toHaveLength(3)\n      expect(resultDefault).toEqual(resultHoisted)\n\n      for (const field of resultDefault) {\n        expect(field.accessor).toBeUndefined()\n        expect(field.labelWithPrefix).toBeUndefined()\n      }\n    })\n  })\n})\n"],"names":["describe","it","expect","flattenTopLevelFields","i18n","t","value","language","dateFNS","dateFNSKey","fallbackLanguage","translations","baseField","type","name","label","fields","result","toHaveLength","toBe","moveSubFieldsToTop","accessor","labelWithPrefix","hoisted","nonHoisted","withExtract","toBeUndefined","withoutExtract","hoistedResult","nonHoistedResult","blocks","slug","defaultResult","namedTabFields","tabs","unnamedTabFields","unnamedTabWithNamedGroup","unnamedTabWithUnnamedGroup","hoistedField","tabField","resultDefault","resultHoisted","toEqual","field"],"mappings":"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,CAAC,EAAE,CAACK,eAAe,EAAEH,IAAI,CAAC;QACzC;IACF;IAEAnB,SAAS,mBAAmB;QAC1B,MAAMiC,iBAAgC;YACpC;gBACEpB,MAAM;gBACNqB,MAAM;oBACJ;wBACEnB,OAAO;wBACPD,MAAM;wBACNE,QAAQ;4BACN;gCACEH,MAAM;gCACNC,MAAM;gCACNE,QAAQ;oCACN;wCACEH,MAAM;wCACNC,MAAM;oCACR;iCACD;4BACH;4BACA;gCACED,MAAM;gCACNG,QAAQ;oCACN;wCACEF,MAAM;wCACND,MAAM;wCACNG,QAAQ;4CACN;gDACEF,MAAM;gDACND,MAAM;4CACR;yCACD;oCACH;iCACD;4BACH;4BACA;gCACEA,MAAM;gCACNC,MAAM;gCACNC,OAAO;4BACT;4BACA;gCACEF,MAAM;gCACNC,MAAM;gCACNC,OAAO;gCACPC,QAAQ;oCACN;wCACEH,MAAM;wCACNC,MAAM;wCACNC,OAAO;oCACT;iCACD;4BACH;yBACD;oBACH;iBACD;YACH;SACD;QAED,MAAMoB,mBAAkC;YACtC;gBACEtB,MAAM;gBACNqB,MAAM;oBACJ;wBACEnB,OAAO;wBACPC,QAAQ;4BACN;gCACEH,MAAM;gCACNC,MAAM;gCACNE,QAAQ;oCACN;wCACEH,MAAM;wCACNC,MAAM;oCACR;iCACD;4BACH;4BACA;gCACED,MAAM;gCACNG,QAAQ;oCACN;wCACEF,MAAM;wCACND,MAAM;wCACNG,QAAQ;4CACN;gDACEF,MAAM;gDACND,MAAM;4CACR;yCACD;oCACH;iCACD;4BACH;4BACA;gCACEA,MAAM;gCACNC,MAAM;gCACNC,OAAO;4BACT;yBACD;oBACH;iBACD;YACH;SACD;QAEDd,GAAG,sFAAsF;YACvF,MAAMmC,2BAA0C;gBAC9C;oBACEvB,MAAM;oBACNqB,MAAM;wBACJ;4BACEnB,OAAO;4BACPC,QAAQ;gCACN;oCACEH,MAAM;oCACNC,MAAM;oCACNC,OAAO;oCACPC,QAAQ;wCACN;4CACEH,MAAM;4CACNC,MAAM;4CACNC,OAAO;wCACT;qCACD;gCACH;6BACD;wBACH;qBACD;gBACH;aACD;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"}