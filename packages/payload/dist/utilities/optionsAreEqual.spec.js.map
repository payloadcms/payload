{"version":3,"sources":["../../src/utilities/optionsAreEqual.spec.ts"],"sourcesContent":["import { describe, expect, it } from 'vitest'\n\nimport { optionsAreEqual } from './optionsAreEqual.js'\n\ndescribe('optionsAreEqual', () => {\n  describe('with string options', () => {\n    it('should return true for identical string arrays', () => {\n      expect(optionsAreEqual(['a', 'b', 'c'], ['a', 'b', 'c'])).toBe(true)\n    })\n\n    it('should return true for same values in different order', () => {\n      expect(optionsAreEqual(['a', 'b', 'c'], ['c', 'a', 'b'])).toBe(true)\n    })\n\n    it('should return false for different values', () => {\n      expect(optionsAreEqual(['a', 'b'], ['a', 'c'])).toBe(false)\n    })\n\n    it('should return false for different lengths', () => {\n      expect(optionsAreEqual(['a', 'b'], ['a', 'b', 'c'])).toBe(false)\n    })\n  })\n\n  describe('with object options', () => {\n    it('should return true for identical object arrays', () => {\n      const options1 = [\n        { label: 'Option A', value: 'a' },\n        { label: 'Option B', value: 'b' },\n      ]\n      const options2 = [\n        { label: 'Option A', value: 'a' },\n        { label: 'Option B', value: 'b' },\n      ]\n      expect(optionsAreEqual(options1, options2)).toBe(true)\n    })\n\n    it('should return true for same values with different labels', () => {\n      const options1 = [\n        { label: 'First Label', value: 'a' },\n        { label: 'Second Label', value: 'b' },\n      ]\n      const options2 = [\n        { label: 'Different Label A', value: 'a' },\n        { label: 'Different Label B', value: 'b' },\n      ]\n      expect(optionsAreEqual(options1, options2)).toBe(true)\n    })\n\n    it('should return true for same values in different order', () => {\n      const options1 = [\n        { label: 'A', value: 'a' },\n        { label: 'B', value: 'b' },\n      ]\n      const options2 = [\n        { label: 'B', value: 'b' },\n        { label: 'A', value: 'a' },\n      ]\n      expect(optionsAreEqual(options1, options2)).toBe(true)\n    })\n\n    it('should return false for different values', () => {\n      const options1 = [\n        { label: 'A', value: 'a' },\n        { label: 'B', value: 'b' },\n      ]\n      const options2 = [\n        { label: 'A', value: 'a' },\n        { label: 'C', value: 'c' },\n      ]\n      expect(optionsAreEqual(options1, options2)).toBe(false)\n    })\n  })\n\n  describe('with mixed string and object options', () => {\n    it('should return true when string and object have same value', () => {\n      const options1 = ['a', 'b']\n      const options2 = [\n        { label: 'A', value: 'a' },\n        { label: 'B', value: 'b' },\n      ]\n      expect(optionsAreEqual(options1, options2)).toBe(true)\n    })\n\n    it('should return false when values differ', () => {\n      const options1 = ['a', 'b']\n      const options2 = [\n        { label: 'A', value: 'a' },\n        { label: 'C', value: 'c' },\n      ]\n      expect(optionsAreEqual(options1, options2)).toBe(false)\n    })\n  })\n\n  describe('with timezone-like options', () => {\n    it('should return true for identical timezone options', () => {\n      const globalTimezones = [\n        { label: 'New York', value: 'America/New_York' },\n        { label: 'Los Angeles', value: 'America/Los_Angeles' },\n        { label: 'London', value: 'Europe/London' },\n      ]\n      const fieldTimezones = [\n        { label: 'New York', value: 'America/New_York' },\n        { label: 'Los Angeles', value: 'America/Los_Angeles' },\n        { label: 'London', value: 'Europe/London' },\n      ]\n      expect(optionsAreEqual(globalTimezones, fieldTimezones)).toBe(true)\n    })\n\n    it('should return false for custom offset timezones vs IANA timezones', () => {\n      const globalTimezones = [\n        { label: 'New York', value: 'America/New_York' },\n        { label: 'Los Angeles', value: 'America/Los_Angeles' },\n      ]\n      const fieldTimezones = [\n        { label: 'UTC+5:30', value: '+05:30' },\n        { label: 'UTC-8', value: '-08:00' },\n      ]\n      expect(optionsAreEqual(globalTimezones, fieldTimezones)).toBe(false)\n    })\n\n    it('should return false for mixed IANA and offset vs pure IANA', () => {\n      const globalTimezones = [\n        { label: 'New York', value: 'America/New_York' },\n        { label: 'London', value: 'Europe/London' },\n      ]\n      const fieldTimezones = [\n        { label: 'New York', value: 'America/New_York' },\n        { label: 'UTC+5:30', value: '+05:30' },\n      ]\n      expect(optionsAreEqual(globalTimezones, fieldTimezones)).toBe(false)\n    })\n\n    it('should return false for subset of global timezones', () => {\n      const globalTimezones = [\n        { label: 'New York', value: 'America/New_York' },\n        { label: 'Los Angeles', value: 'America/Los_Angeles' },\n        { label: 'London', value: 'Europe/London' },\n      ]\n      const fieldTimezones = [{ label: 'New York', value: 'America/New_York' }]\n      expect(optionsAreEqual(globalTimezones, fieldTimezones)).toBe(false)\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should return true for both undefined', () => {\n      expect(optionsAreEqual(undefined, undefined)).toBe(true)\n    })\n\n    it('should return false for one undefined', () => {\n      expect(optionsAreEqual(['a'], undefined)).toBe(false)\n      expect(optionsAreEqual(undefined, ['a'])).toBe(false)\n    })\n\n    it('should return true for both empty arrays', () => {\n      expect(optionsAreEqual([], [])).toBe(true)\n    })\n\n    it('should return false for empty vs non-empty', () => {\n      expect(optionsAreEqual([], ['a'])).toBe(false)\n      expect(optionsAreEqual(['a'], [])).toBe(false)\n    })\n\n    it('should handle duplicate values in source (uses Set)', () => {\n      // If there are duplicates, the Set will dedupe them\n      // So ['a', 'a', 'b'] becomes Set{'a', 'b'} with size 2\n      // and ['a', 'b'] becomes Set{'a', 'b'} with size 2\n      // But the arrays have different lengths, so they're not equal\n      expect(optionsAreEqual(['a', 'a', 'b'], ['a', 'b'])).toBe(false)\n    })\n  })\n})\n"],"names":["describe","expect","it","optionsAreEqual","toBe","options1","label","value","options2","globalTimezones","fieldTimezones","undefined"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,MAAM,EAAEC,EAAE,QAAQ,SAAQ;AAE7C,SAASC,eAAe,QAAQ,uBAAsB;AAEtDH,SAAS,mBAAmB;IAC1BA,SAAS,uBAAuB;QAC9BE,GAAG,kDAAkD;YACnDD,OAAOE,gBAAgB;gBAAC;gBAAK;gBAAK;aAAI,EAAE;gBAAC;gBAAK;gBAAK;aAAI,GAAGC,IAAI,CAAC;QACjE;QAEAF,GAAG,yDAAyD;YAC1DD,OAAOE,gBAAgB;gBAAC;gBAAK;gBAAK;aAAI,EAAE;gBAAC;gBAAK;gBAAK;aAAI,GAAGC,IAAI,CAAC;QACjE;QAEAF,GAAG,4CAA4C;YAC7CD,OAAOE,gBAAgB;gBAAC;gBAAK;aAAI,EAAE;gBAAC;gBAAK;aAAI,GAAGC,IAAI,CAAC;QACvD;QAEAF,GAAG,6CAA6C;YAC9CD,OAAOE,gBAAgB;gBAAC;gBAAK;aAAI,EAAE;gBAAC;gBAAK;gBAAK;aAAI,GAAGC,IAAI,CAAC;QAC5D;IACF;IAEAJ,SAAS,uBAAuB;QAC9BE,GAAG,kDAAkD;YACnD,MAAMG,WAAW;gBACf;oBAAEC,OAAO;oBAAYC,OAAO;gBAAI;gBAChC;oBAAED,OAAO;oBAAYC,OAAO;gBAAI;aACjC;YACD,MAAMC,WAAW;gBACf;oBAAEF,OAAO;oBAAYC,OAAO;gBAAI;gBAChC;oBAAED,OAAO;oBAAYC,OAAO;gBAAI;aACjC;YACDN,OAAOE,gBAAgBE,UAAUG,WAAWJ,IAAI,CAAC;QACnD;QAEAF,GAAG,4DAA4D;YAC7D,MAAMG,WAAW;gBACf;oBAAEC,OAAO;oBAAeC,OAAO;gBAAI;gBACnC;oBAAED,OAAO;oBAAgBC,OAAO;gBAAI;aACrC;YACD,MAAMC,WAAW;gBACf;oBAAEF,OAAO;oBAAqBC,OAAO;gBAAI;gBACzC;oBAAED,OAAO;oBAAqBC,OAAO;gBAAI;aAC1C;YACDN,OAAOE,gBAAgBE,UAAUG,WAAWJ,IAAI,CAAC;QACnD;QAEAF,GAAG,yDAAyD;YAC1D,MAAMG,WAAW;gBACf;oBAAEC,OAAO;oBAAKC,OAAO;gBAAI;gBACzB;oBAAED,OAAO;oBAAKC,OAAO;gBAAI;aAC1B;YACD,MAAMC,WAAW;gBACf;oBAAEF,OAAO;oBAAKC,OAAO;gBAAI;gBACzB;oBAAED,OAAO;oBAAKC,OAAO;gBAAI;aAC1B;YACDN,OAAOE,gBAAgBE,UAAUG,WAAWJ,IAAI,CAAC;QACnD;QAEAF,GAAG,4CAA4C;YAC7C,MAAMG,WAAW;gBACf;oBAAEC,OAAO;oBAAKC,OAAO;gBAAI;gBACzB;oBAAED,OAAO;oBAAKC,OAAO;gBAAI;aAC1B;YACD,MAAMC,WAAW;gBACf;oBAAEF,OAAO;oBAAKC,OAAO;gBAAI;gBACzB;oBAAED,OAAO;oBAAKC,OAAO;gBAAI;aAC1B;YACDN,OAAOE,gBAAgBE,UAAUG,WAAWJ,IAAI,CAAC;QACnD;IACF;IAEAJ,SAAS,wCAAwC;QAC/CE,GAAG,6DAA6D;YAC9D,MAAMG,WAAW;gBAAC;gBAAK;aAAI;YAC3B,MAAMG,WAAW;gBACf;oBAAEF,OAAO;oBAAKC,OAAO;gBAAI;gBACzB;oBAAED,OAAO;oBAAKC,OAAO;gBAAI;aAC1B;YACDN,OAAOE,gBAAgBE,UAAUG,WAAWJ,IAAI,CAAC;QACnD;QAEAF,GAAG,0CAA0C;YAC3C,MAAMG,WAAW;gBAAC;gBAAK;aAAI;YAC3B,MAAMG,WAAW;gBACf;oBAAEF,OAAO;oBAAKC,OAAO;gBAAI;gBACzB;oBAAED,OAAO;oBAAKC,OAAO;gBAAI;aAC1B;YACDN,OAAOE,gBAAgBE,UAAUG,WAAWJ,IAAI,CAAC;QACnD;IACF;IAEAJ,SAAS,8BAA8B;QACrCE,GAAG,qDAAqD;YACtD,MAAMO,kBAAkB;gBACtB;oBAAEH,OAAO;oBAAYC,OAAO;gBAAmB;gBAC/C;oBAAED,OAAO;oBAAeC,OAAO;gBAAsB;gBACrD;oBAAED,OAAO;oBAAUC,OAAO;gBAAgB;aAC3C;YACD,MAAMG,iBAAiB;gBACrB;oBAAEJ,OAAO;oBAAYC,OAAO;gBAAmB;gBAC/C;oBAAED,OAAO;oBAAeC,OAAO;gBAAsB;gBACrD;oBAAED,OAAO;oBAAUC,OAAO;gBAAgB;aAC3C;YACDN,OAAOE,gBAAgBM,iBAAiBC,iBAAiBN,IAAI,CAAC;QAChE;QAEAF,GAAG,qEAAqE;YACtE,MAAMO,kBAAkB;gBACtB;oBAAEH,OAAO;oBAAYC,OAAO;gBAAmB;gBAC/C;oBAAED,OAAO;oBAAeC,OAAO;gBAAsB;aACtD;YACD,MAAMG,iBAAiB;gBACrB;oBAAEJ,OAAO;oBAAYC,OAAO;gBAAS;gBACrC;oBAAED,OAAO;oBAASC,OAAO;gBAAS;aACnC;YACDN,OAAOE,gBAAgBM,iBAAiBC,iBAAiBN,IAAI,CAAC;QAChE;QAEAF,GAAG,8DAA8D;YAC/D,MAAMO,kBAAkB;gBACtB;oBAAEH,OAAO;oBAAYC,OAAO;gBAAmB;gBAC/C;oBAAED,OAAO;oBAAUC,OAAO;gBAAgB;aAC3C;YACD,MAAMG,iBAAiB;gBACrB;oBAAEJ,OAAO;oBAAYC,OAAO;gBAAmB;gBAC/C;oBAAED,OAAO;oBAAYC,OAAO;gBAAS;aACtC;YACDN,OAAOE,gBAAgBM,iBAAiBC,iBAAiBN,IAAI,CAAC;QAChE;QAEAF,GAAG,sDAAsD;YACvD,MAAMO,kBAAkB;gBACtB;oBAAEH,OAAO;oBAAYC,OAAO;gBAAmB;gBAC/C;oBAAED,OAAO;oBAAeC,OAAO;gBAAsB;gBACrD;oBAAED,OAAO;oBAAUC,OAAO;gBAAgB;aAC3C;YACD,MAAMG,iBAAiB;gBAAC;oBAAEJ,OAAO;oBAAYC,OAAO;gBAAmB;aAAE;YACzEN,OAAOE,gBAAgBM,iBAAiBC,iBAAiBN,IAAI,CAAC;QAChE;IACF;IAEAJ,SAAS,cAAc;QACrBE,GAAG,yCAAyC;YAC1CD,OAAOE,gBAAgBQ,WAAWA,YAAYP,IAAI,CAAC;QACrD;QAEAF,GAAG,yCAAyC;YAC1CD,OAAOE,gBAAgB;gBAAC;aAAI,EAAEQ,YAAYP,IAAI,CAAC;YAC/CH,OAAOE,gBAAgBQ,WAAW;gBAAC;aAAI,GAAGP,IAAI,CAAC;QACjD;QAEAF,GAAG,4CAA4C;YAC7CD,OAAOE,gBAAgB,EAAE,EAAE,EAAE,GAAGC,IAAI,CAAC;QACvC;QAEAF,GAAG,8CAA8C;YAC/CD,OAAOE,gBAAgB,EAAE,EAAE;gBAAC;aAAI,GAAGC,IAAI,CAAC;YACxCH,OAAOE,gBAAgB;gBAAC;aAAI,EAAE,EAAE,GAAGC,IAAI,CAAC;QAC1C;QAEAF,GAAG,uDAAuD;YACxD,oDAAoD;YACpD,uDAAuD;YACvD,mDAAmD;YACnD,8DAA8D;YAC9DD,OAAOE,gBAAgB;gBAAC;gBAAK;gBAAK;aAAI,EAAE;gBAAC;gBAAK;aAAI,GAAGC,IAAI,CAAC;QAC5D;IACF;AACF"}