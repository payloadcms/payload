{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import type {\n  CollectionAfterChangeHook,\n  CollectionBeforeDeleteHook,\n  CollectionConfig,\n  Field,\n  Locale,\n  Payload,\n  PayloadRequest,\n  StaticLabel,\n} from 'payload'\n\nexport type DocToSync = {\n  [key: string]: any\n  doc: {\n    relationTo: string\n    value: string\n  }\n  title: string\n}\n\nexport type BeforeSync = (args: {\n  originalDoc: {\n    [key: string]: any\n  }\n  payload: Payload\n  req: PayloadRequest\n  searchDoc: DocToSync\n}) => DocToSync | Promise<DocToSync>\n\nexport type FieldsOverride = (args: { defaultFields: Field[] }) => Field[]\n\nexport type SkipSyncFunction<ConfigTypes = unknown> = (args: {\n  collectionSlug: string\n  doc: any\n  locale: ConfigTypes extends { locale: unknown } ? ConfigTypes['locale'] : string | undefined\n  req: PayloadRequest\n}) => boolean | Promise<boolean>\n\nexport type SearchPluginConfig<ConfigTypes = unknown> = {\n  /**\n   * @deprecated\n   * This plugin gets the api route from the config directly and does not need to be passed in.\n   * As long as you have `routes.api` set in your Payload config, the plugin will use that.\n   * This property will be removed in the next major version.\n   */\n  apiBasePath?: string\n  beforeSync?: BeforeSync\n  collections?: string[]\n  defaultPriorities?: {\n    [collection: string]: ((doc: any) => number | Promise<number>) | number\n  }\n  /**\n   * Controls whether drafts are deleted from the search index\n   *\n   * @default true\n   */\n  deleteDrafts?: boolean\n  localize?: boolean\n  /**\n   * We use batching when re-indexing large collections. You can control the amount of items per batch, lower numbers should help with memory.\n   *\n   * @default 50\n   */\n  reindexBatchSize?: number\n  searchOverrides?: { fields?: FieldsOverride } & Partial<Omit<CollectionConfig, 'fields'>>\n  /**\n   * Determine whether to skip syncing a document for a specific locale.\n   * Useful for multi-tenant applications, conditional indexing, or any scenario where\n   * sync behavior should vary by locale, document, or other factors.\n   *\n   * @default undefined - All configured locales will be synced\n   *\n   * @example\n   * // Skip syncing based on document's tenant settings\n   * skipSync: async ({ locale, req, doc, collectionSlug }) => {\n   *   // For non-localized collections, locale will be undefined\n   *   if (!locale) return false\n   *\n   *   const tenant = await req.payload.findByID({\n   *     collection: 'tenants',\n   *     id: doc.tenant.id\n   *   })\n   *   return !tenant.allowedLocales.includes(locale)\n   * }\n   */\n  skipSync?: SkipSyncFunction<ConfigTypes>\n  /**\n   * Controls whether drafts are synced to the search index\n   *\n   * @default false\n   */\n  syncDrafts?: boolean\n}\n\nexport type CollectionLabels = {\n  [collection: string]: CollectionConfig['labels']\n}\n\nexport type ResolvedCollectionLabels = {\n  [collection: string]: StaticLabel\n}\n\nexport type SearchPluginConfigWithLocales<ConfigTypes = unknown> = {\n  labels?: CollectionLabels\n} & SearchPluginConfig<ConfigTypes>\n\nexport type SanitizedSearchPluginConfig<ConfigTypes = unknown> = {\n  reindexBatchSize: number\n  syncDrafts: boolean\n} & SearchPluginConfigWithLocales<ConfigTypes>\n\nexport type SyncWithSearchArgs = {\n  collection: string\n  pluginConfig: SanitizedSearchPluginConfig\n} & Omit<Parameters<CollectionAfterChangeHook>[0], 'collection'>\n\nexport type SyncDocArgs = {\n  locale?: Locale['code']\n  onSyncError?: () => void\n} & Omit<SyncWithSearchArgs, 'context' | 'previousDoc'>\n\n// Extend the `CollectionAfterChangeHook` with more function args\n// Convert the `collection` arg from `SanitizedCollectionConfig` to a string\nexport type SyncWithSearch = (Args: SyncWithSearchArgs) => ReturnType<CollectionAfterChangeHook>\n\nexport type DeleteFromSearch = (args: SearchPluginConfig) => CollectionBeforeDeleteHook\n"],"names":[],"mappings":"AA6HA,WAAuF"}