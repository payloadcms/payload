{"version":3,"sources":["../../src/utilities/syncDocAsSearchIndex.ts"],"sourcesContent":["import type { DocToSync, SyncDocArgs } from '../types.js'\n\nexport const syncDocAsSearchIndex = async ({\n  collection,\n  doc,\n  locale,\n  onSyncError,\n  operation,\n  pluginConfig,\n  req: { payload },\n  req,\n}: SyncDocArgs) => {\n  const { id, _status: status, title } = doc || {}\n\n  const { beforeSync, defaultPriorities, deleteDrafts, searchOverrides, syncDrafts } = pluginConfig\n\n  const searchSlug = searchOverrides?.slug || 'search'\n\n  // Determine sync locale\n  const syncLocale = locale || req.locale || undefined\n\n  if (typeof pluginConfig.skipSync === 'function') {\n    try {\n      const skipSync = await pluginConfig.skipSync({\n        collectionSlug: collection,\n        doc,\n        locale: syncLocale,\n        req,\n      })\n\n      if (skipSync) {\n        return doc\n      }\n    } catch (err) {\n      req.payload.logger.error({\n        err,\n        msg: 'Search plugin: Error executing skipSync. Proceeding with sync.',\n      })\n    }\n  }\n\n  let dataToSave: DocToSync = {\n    doc: {\n      relationTo: collection,\n      value: id,\n    },\n    title,\n  }\n  const docKeyPrefix = `${collection}:${id}`\n  const docKey = req.payload.config.localization ? `${docKeyPrefix}:${syncLocale}` : docKeyPrefix\n  const syncedDocsSet = (req.context?.syncedDocsSet as Set<string>) || new Set<string>()\n\n  if (syncedDocsSet.has(docKey)) {\n    /*\n     * prevents duplicate syncing of documents in the same request\n     * this can happen when hooks call `payload.update` within the create lifecycle\n     * like the nested-docs plugin does\n     */\n    return doc\n  } else {\n    syncedDocsSet.add(docKey)\n  }\n\n  req.context.syncedDocsSet = syncedDocsSet\n\n  if (typeof beforeSync === 'function') {\n    let docToSyncWith = doc\n    if (payload.config?.localization) {\n      // Check if document is trashed (has deletedAt field)\n      const isTrashDocument = doc && 'deletedAt' in doc && doc.deletedAt\n\n      docToSyncWith = await payload.findByID({\n        id,\n        collection,\n        locale: syncLocale,\n        req,\n        // Include trashed documents when the document being synced is trashed\n        trash: isTrashDocument,\n      })\n    }\n    dataToSave = await beforeSync({\n      originalDoc: docToSyncWith,\n      payload,\n      req,\n      searchDoc: dataToSave,\n    })\n  }\n\n  let defaultPriority = 0\n  if (defaultPriorities) {\n    const { [collection]: priority } = defaultPriorities\n\n    if (typeof priority === 'function') {\n      try {\n        defaultPriority = await priority(doc)\n      } catch (err: unknown) {\n        payload.logger.error(err)\n        payload.logger.error(\n          `Error gathering default priority for ${searchSlug} documents related to ${collection}`,\n        )\n      }\n    } else if (priority !== undefined) {\n      defaultPriority = priority\n    }\n  }\n\n  const doSync = syncDrafts || (!syncDrafts && status !== 'draft')\n\n  try {\n    if (operation === 'create' && doSync) {\n      await payload.create({\n        collection: searchSlug,\n        data: {\n          ...dataToSave,\n          priority: defaultPriority,\n        },\n        depth: 0,\n        locale: syncLocale,\n        req,\n      })\n    }\n\n    if (operation === 'update') {\n      try {\n        // find the correct doc to sync with\n        const searchDocQuery = await payload.find({\n          collection: searchSlug,\n          depth: 0,\n          locale: syncLocale,\n          req,\n          where: {\n            'doc.relationTo': {\n              equals: collection,\n            },\n            'doc.value': {\n              equals: id,\n            },\n          },\n        })\n\n        const docs: Array<{\n          id: number | string\n          priority?: number\n        }> = searchDocQuery?.docs || []\n\n        const [foundDoc, ...duplicativeDocs] = docs\n\n        // delete all duplicative search docs (docs that reference the same page)\n        // to ensure the same, out-of-date result does not appear twice (where only syncing the first found doc)\n        if (duplicativeDocs.length > 0) {\n          try {\n            const duplicativeDocIDs = duplicativeDocs.map(({ id }) => id)\n            await payload.delete({\n              collection: searchSlug,\n              depth: 0,\n              req,\n              where: { id: { in: duplicativeDocIDs } },\n            })\n          } catch (err: unknown) {\n            payload.logger.error({\n              err,\n              msg: `Error deleting duplicative ${searchSlug} documents.`,\n            })\n          }\n        }\n\n        if (foundDoc) {\n          const { id: searchDocID } = foundDoc\n\n          // Check if document is trashed and delete from search\n          const isTrashDocument = doc && 'deletedAt' in doc && doc.deletedAt\n\n          if (isTrashDocument) {\n            try {\n              await payload.delete({\n                id: searchDocID,\n                collection: searchSlug,\n                depth: 0,\n                req,\n              })\n            } catch (err: unknown) {\n              payload.logger.error({\n                err,\n                msg: `Error deleting ${searchSlug} document for trashed doc.`,\n              })\n            }\n          } else {\n            if (doSync) {\n              // update the doc normally\n              try {\n                await payload.update({\n                  id: searchDocID,\n                  collection: searchSlug,\n                  data: {\n                    ...dataToSave,\n                    priority: foundDoc.priority || defaultPriority,\n                  },\n                  depth: 0,\n                  locale: syncLocale,\n                  req,\n                })\n              } catch (err: unknown) {\n                payload.logger.error({ err, msg: `Error updating ${searchSlug} document.` })\n              }\n            }\n\n            if (deleteDrafts && status === 'draft') {\n              // Check to see if there's a published version of the doc\n              // We don't want to remove the search doc if there is a published version but a new draft has been created\n              const {\n                docs: [docWithPublish],\n              } = await payload.find({\n                collection,\n                depth: 0,\n                draft: false,\n                limit: 1,\n                locale: syncLocale,\n                pagination: false,\n                req,\n                where: {\n                  and: [\n                    {\n                      _status: {\n                        equals: 'published',\n                      },\n                    },\n                    {\n                      id: {\n                        equals: id,\n                      },\n                    },\n                  ],\n                },\n              })\n\n              if (!docWithPublish) {\n                // do not include draft docs in search results, so delete the record\n                try {\n                  await payload.delete({\n                    id: searchDocID,\n                    collection: searchSlug,\n                    depth: 0,\n                    req,\n                  })\n                } catch (err: unknown) {\n                  payload.logger.error({ err, msg: `Error deleting ${searchSlug} document.` })\n                }\n              }\n            }\n          }\n        } else if (doSync) {\n          try {\n            await payload.create({\n              collection: searchSlug,\n              data: {\n                ...dataToSave,\n                priority: defaultPriority,\n              },\n              depth: 0,\n              locale: syncLocale,\n              req,\n            })\n          } catch (err: unknown) {\n            payload.logger.error({ err, msg: `Error creating ${searchSlug} document.` })\n          }\n        }\n      } catch (err: unknown) {\n        payload.logger.error({ err, msg: `Error finding ${searchSlug} document.` })\n      }\n    }\n  } catch (err: unknown) {\n    payload.logger.error({\n      err,\n      msg: `Error syncing ${searchSlug} document related to ${collection} with id: '${id}'.`,\n    })\n\n    if (onSyncError) {\n      onSyncError()\n    }\n  }\n\n  return doc\n}\n"],"names":["syncDocAsSearchIndex","collection","doc","locale","onSyncError","operation","pluginConfig","req","payload","id","_status","status","title","beforeSync","defaultPriorities","deleteDrafts","searchOverrides","syncDrafts","searchSlug","slug","syncLocale","undefined","skipSync","collectionSlug","err","logger","error","msg","dataToSave","relationTo","value","docKeyPrefix","docKey","config","localization","syncedDocsSet","context","Set","has","add","docToSyncWith","isTrashDocument","deletedAt","findByID","trash","originalDoc","searchDoc","defaultPriority","priority","doSync","create","data","depth","searchDocQuery","find","where","equals","docs","foundDoc","duplicativeDocs","length","duplicativeDocIDs","map","delete","in","searchDocID","update","docWithPublish","draft","limit","pagination","and"],"mappings":"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"}