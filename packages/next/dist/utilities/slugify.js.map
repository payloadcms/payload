{"version":3,"file":"slugify.js","names":["flattenAllFields","getFieldByPath","UnauthorizedError","slugify","defaultSlugify","slugifyHandler","args","collectionSlug","data","globalSlug","path","req","valueToSlugify","user","docConfig","payload","collections","config","globals","find","g","slug","Error","field","fields","customSlugify","custom","undefined","result"],"sources":["../../src/utilities/slugify.ts"],"sourcesContent":["import type { Slugify } from 'payload/shared'\n\nimport {\n  flattenAllFields,\n  getFieldByPath,\n  type ServerFunction,\n  type SlugifyServerFunctionArgs,\n  UnauthorizedError,\n} from 'payload'\nimport { slugify as defaultSlugify } from 'payload/shared'\n\n/**\n * This server function is directly related to the {@link https://payloadcms.com/docs/fields/text#slug-field | Slug Field}.\n * This is a server function that is used to invoke the user's custom slugify function from the client.\n * This pattern is required, as there is no other way for us to pass their function across the client-server boundary.\n *   - Not through props\n *   - Not from a server function defined within a server component (see below)\n * When a server function contains non-serializable data within its closure, it gets passed through the boundary (and breaks).\n * The only way to pass server functions to the client (that contain non-serializable data) is if it is globally defined.\n * But we also cannot define this function alongside the server component, as we will not have access to their custom slugify function.\n * See `ServerFunctionsProvider` for more details.\n */\nexport const slugifyHandler: ServerFunction<\n  SlugifyServerFunctionArgs,\n  Promise<ReturnType<Slugify>>\n> = async (args) => {\n  const { collectionSlug, data, globalSlug, path, req, valueToSlugify } = args\n\n  if (!req.user) {\n    throw new UnauthorizedError()\n  }\n\n  const docConfig = collectionSlug\n    ? req.payload.collections[collectionSlug]?.config\n    : globalSlug\n      ? req.payload.config.globals.find((g) => g.slug === globalSlug)\n      : null\n\n  if (!docConfig) {\n    throw new Error()\n  }\n\n  const { field } = getFieldByPath({\n    config: req.payload.config,\n    fields: flattenAllFields({ fields: docConfig.fields }),\n    path,\n  })\n\n  const customSlugify = (\n    typeof field?.custom?.slugify === 'function' ? field.custom.slugify : undefined\n  ) as Slugify\n\n  const result = customSlugify\n    ? await customSlugify({ data, req, valueToSlugify })\n    : defaultSlugify(valueToSlugify)\n\n  return result\n}\n"],"mappings":"AAEA,SACEA,gBAAgB,EAChBC,cAAc,EAGdC,iBAAiB,QACZ;AACP,SAASC,OAAA,IAAWC,cAAc,QAAQ;AAE1C;;;;;;;;;;;AAWA,OAAO,MAAMC,cAAA,GAGT,MAAOC,IAAA;EACT,MAAM;IAAEC,cAAc;IAAEC,IAAI;IAAEC,UAAU;IAAEC,IAAI;IAAEC,GAAG;IAAEC;EAAc,CAAE,GAAGN,IAAA;EAExE,IAAI,CAACK,GAAA,CAAIE,IAAI,EAAE;IACb,MAAM,IAAIX,iBAAA;EACZ;EAEA,MAAMY,SAAA,GAAYP,cAAA,GACdI,GAAA,CAAII,OAAO,CAACC,WAAW,CAACT,cAAA,CAAe,EAAEU,MAAA,GACzCR,UAAA,GACEE,GAAA,CAAII,OAAO,CAACE,MAAM,CAACC,OAAO,CAACC,IAAI,CAAEC,CAAA,IAAMA,CAAA,CAAEC,IAAI,KAAKZ,UAAA,IAClD;EAEN,IAAI,CAACK,SAAA,EAAW;IACd,MAAM,IAAIQ,KAAA;EACZ;EAEA,MAAM;IAAEC;EAAK,CAAE,GAAGtB,cAAA,CAAe;IAC/BgB,MAAA,EAAQN,GAAA,CAAII,OAAO,CAACE,MAAM;IAC1BO,MAAA,EAAQxB,gBAAA,CAAiB;MAAEwB,MAAA,EAAQV,SAAA,CAAUU;IAAO;IACpDd;EACF;EAEA,MAAMe,aAAA,GACJ,OAAOF,KAAA,EAAOG,MAAA,EAAQvB,OAAA,KAAY,aAAaoB,KAAA,CAAMG,MAAM,CAACvB,OAAO,GAAGwB,SAAA;EAGxE,MAAMC,MAAA,GAASH,aAAA,GACX,MAAMA,aAAA,CAAc;IAAEjB,IAAA;IAAMG,GAAA;IAAKC;EAAe,KAChDR,cAAA,CAAeQ,cAAA;EAEnB,OAAOgB,MAAA;AACT","ignoreList":[]}