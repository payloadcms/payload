{"version":3,"file":"MarkdownImport.js","names":["$isListItemNode","$isListNode","$isQuoteNode","$findMatchingParent","$createLineBreakNode","$createParagraphNode","$createTextNode","$getRoot","$getSelection","$isParagraphNode","importTextTransformers","isEmptyParagraph","transformersByType","createMarkdownImport","transformers","shouldPreserveNewLines","byType","textFormatTransformersIndex","createTextFormatTransformersIndex","textFormat","markdownString","node","lines","split","linesLength","length","root","clear","i","lineText","imported","shiftedIndex","$importMultiline","multilineElement","$importBlocks","element","textMatch","children","getChildren","child","getChildrenSize","remove","selectStart","startLineIndex","multilineElementTransformers","rootNode","transformer","handleImportAfterStartMatch","regExpEnd","regExpStart","replace","startMatch","match","result","regexpEndRegex","regExp","isEndOptional","optional","endLineIndex","endMatch","index","linesInBetween","push","slice","line","text","elementTransformers","textMatchTransformers","textNode","elementNode","append","setTextContent","isAttached","previousNode","getPreviousSibling","targetNode","lastDescendant","getLastDescendant","getTextContentSize","splice","textTransformers","transformersByTag","fullMatchRegExpByTag","openTagsRegExp","escapeRegExp","tag","tagRegExp","RegExp","join"],"sources":["../../../../src/packages/@lexical/markdown/MarkdownImport.ts"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type { ListItemNode } from '@lexical/list'\nimport type { ElementNode } from 'lexical'\n\nimport { $isListItemNode, $isListNode } from '@lexical/list'\nimport { $isQuoteNode } from '@lexical/rich-text'\nimport { $findMatchingParent } from '@lexical/utils'\nimport {\n  $createLineBreakNode,\n  $createParagraphNode,\n  $createTextNode,\n  $getRoot,\n  $getSelection,\n  $isParagraphNode,\n} from 'lexical'\n\nimport type {\n  ElementTransformer,\n  MultilineElementTransformer,\n  TextFormatTransformer,\n  TextMatchTransformer,\n  Transformer,\n} from './MarkdownTransformers.js'\n\nimport { importTextTransformers } from './importTextTransformers.js'\nimport { isEmptyParagraph, transformersByType } from './utils.js'\n\nexport type TextFormatTransformersIndex = Readonly<{\n  fullMatchRegExpByTag: Readonly<Record<string, RegExp>>\n  openTagsRegExp: RegExp\n  transformersByTag: Readonly<Record<string, TextFormatTransformer>>\n}>\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nexport function createMarkdownImport(\n  transformers: Array<Transformer>,\n  shouldPreserveNewLines = false,\n): (markdownString: string, node?: ElementNode) => void {\n  const byType = transformersByType(transformers)\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat)\n\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n')\n    const linesLength = lines.length\n    const root = node || $getRoot()\n    root.clear()\n\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i]!\n\n      const [imported, shiftedIndex] = $importMultiline(lines, i, byType.multilineElement, root)\n\n      if (imported) {\n        // If a multiline markdown element was imported, we don't want to process the lines that were part of it anymore.\n        // There could be other sub-markdown elements (both multiline and normal ones) matching within this matched multiline element's children.\n        // However, it would be the responsibility of the matched multiline transformer to decide how it wants to handle them.\n        // We cannot handle those, as there is no way for us to know how to maintain the correct order of generated lexical nodes for possible children.\n        i = shiftedIndex // Next loop will start from the line after the last line of the multiline element\n        continue\n      }\n\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch)\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren()\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove()\n      }\n    }\n\n    if ($getSelection() !== null) {\n      root.selectStart()\n    }\n  }\n}\n\n/**\n *\n * @returns first element of the returned tuple is a boolean indicating if a multiline element was imported. The second element is the index of the last line that was processed.\n */\nfunction $importMultiline(\n  lines: Array<string>,\n  startLineIndex: number,\n  multilineElementTransformers: Array<MultilineElementTransformer>,\n  rootNode: ElementNode,\n): [boolean, number] {\n  for (const transformer of multilineElementTransformers) {\n    const { handleImportAfterStartMatch, regExpEnd, regExpStart, replace } = transformer\n\n    const startMatch = lines[startLineIndex]?.match(regExpStart)\n    if (!startMatch) {\n      continue // Try next transformer\n    }\n\n    if (handleImportAfterStartMatch) {\n      const result = handleImportAfterStartMatch({\n        lines,\n        rootNode,\n        startLineIndex,\n        startMatch,\n        transformer,\n      })\n      if (result === null) {\n        continue\n      } else if (result) {\n        return result\n      }\n    }\n\n    const regexpEndRegex: RegExp | undefined =\n      typeof regExpEnd === 'object' && 'regExp' in regExpEnd ? regExpEnd.regExp : regExpEnd\n\n    const isEndOptional =\n      regExpEnd && typeof regExpEnd === 'object' && 'optional' in regExpEnd\n        ? regExpEnd.optional\n        : !regExpEnd\n\n    let endLineIndex = startLineIndex\n    const linesLength = lines.length\n\n    // check every single line for the closing match. It could also be on the same line as the opening match.\n    while (endLineIndex < linesLength) {\n      const endMatch = regexpEndRegex ? lines[endLineIndex]?.match(regexpEndRegex) : null\n      if (!endMatch) {\n        if (\n          !isEndOptional ||\n          (isEndOptional && endLineIndex < linesLength - 1) // Optional end, but didn't reach the end of the document yet => continue searching for potential closing match\n        ) {\n          endLineIndex++\n          continue // Search next line for closing match\n        }\n      }\n\n      // Now, check if the closing match matched is the same as the opening match.\n      // If it is, we need to continue searching for the actual closing match.\n      if (endMatch && startLineIndex === endLineIndex && endMatch.index === startMatch.index) {\n        endLineIndex++\n        continue // Search next line for closing match\n      }\n\n      // At this point, we have found the closing match. Next: calculate the lines in between open and closing match\n      // This should not include the matches themselves, and be split up by lines\n      const linesInBetween: string[] = []\n\n      if (endMatch && startLineIndex === endLineIndex) {\n        linesInBetween.push(lines[startLineIndex]!.slice(startMatch[0].length, -endMatch[0].length))\n      } else {\n        for (let i = startLineIndex; i <= endLineIndex; i++) {\n          const line = lines[i]!\n          if (i === startLineIndex) {\n            const text = line.slice(startMatch[0].length)\n            linesInBetween.push(text) // Also include empty text\n          } else if (i === endLineIndex && endMatch) {\n            const text = line.slice(0, -endMatch[0].length)\n            linesInBetween.push(text) // Also include empty text\n          } else {\n            linesInBetween.push(line)\n          }\n        }\n      }\n\n      if (replace(rootNode, null, startMatch, endMatch!, linesInBetween, true) !== false) {\n        // Return here. This $importMultiline function is run line by line and should only process a single multiline element at a time.\n        return [true, endLineIndex]\n      }\n\n      // The replace function returned false, despite finding the matching open and close tags => this transformer does not want to handle it.\n      // Thus, we continue letting the remaining transformers handle the passed lines of text from the beginning\n      break\n    }\n  }\n\n  // No multiline transformer handled this line successfully\n  return [false, startLineIndex]\n}\n\nfunction $importBlocks(\n  lineText: string,\n  rootNode: ElementNode,\n  elementTransformers: Array<ElementTransformer>,\n  textFormatTransformersIndex: TextFormatTransformersIndex,\n  textMatchTransformers: Array<TextMatchTransformer>,\n) {\n  const textNode = $createTextNode(lineText)\n  const elementNode = $createParagraphNode()\n  elementNode.append(textNode)\n  rootNode.append(elementNode)\n\n  for (const { regExp, replace } of elementTransformers) {\n    const match = lineText.match(regExp)\n\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length))\n      if (replace(elementNode, [textNode], match, true) !== false) {\n        break\n      }\n    }\n  }\n\n  importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers)\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineText.length > 0) {\n    const previousNode = elementNode.getPreviousSibling()\n    if ($isParagraphNode(previousNode) || $isQuoteNode(previousNode) || $isListNode(previousNode)) {\n      let targetNode: ListItemNode | null | typeof previousNode = previousNode\n\n      if ($isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant()\n        if (lastDescendant == null) {\n          targetNode = null\n        } else {\n          targetNode = $findMatchingParent(lastDescendant, $isListItemNode)\n        }\n      }\n\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [\n          $createLineBreakNode(),\n          ...elementNode.getChildren(),\n        ])\n        elementNode.remove()\n      }\n    }\n  }\n}\n\nfunction createTextFormatTransformersIndex(\n  textTransformers: Array<TextFormatTransformer>,\n): TextFormatTransformersIndex {\n  const transformersByTag: Record<string, TextFormatTransformer> = {}\n  const fullMatchRegExpByTag: Record<string, RegExp> = {}\n  const openTagsRegExp: string[] = []\n  const escapeRegExp = `(?<![\\\\\\\\])`\n\n  for (const transformer of textTransformers) {\n    const { tag } = transformer\n    transformersByTag[tag] = transformer\n    const tagRegExp = tag.replace(/([*^+])/g, '\\\\$1')\n    openTagsRegExp.push(tagRegExp)\n\n    // Single-char tag (e.g. \"*\"),\n    if (tag.length === 1) {\n      fullMatchRegExpByTag[tag] = new RegExp(\n        `(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`,\n      )\n    } else {\n      // Multiâ€char tags (e.g. \"**\")\n      fullMatchRegExpByTag[tag] = new RegExp(\n        `(?<!\\\\\\\\)(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?!\\\\\\\\)`,\n      )\n    }\n  }\n\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n\n    // Regexp to locate *any* potential opening tag (longest first).\n    // eslint-disable-next-line regexp/no-useless-character-class, regexp/no-empty-capturing-group, regexp/no-empty-group\n    openTagsRegExp: new RegExp(`${escapeRegExp}(${openTagsRegExp.join('|')})`, 'g'),\n    transformersByTag,\n  }\n}\n"],"mappings":"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","ignoreList":[]}