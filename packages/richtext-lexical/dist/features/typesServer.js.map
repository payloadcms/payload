{"version":3,"file":"typesServer.js","names":[],"sources":["../../src/features/typesServer.ts"],"sourcesContent":["import type { GenericLanguages, I18n, I18nClient } from '@payloadcms/translations'\nimport type { JSONSchema4 } from 'json-schema'\nimport type {\n  Klass,\n  LexicalNode,\n  LexicalNodeReplacement,\n  SerializedEditorState,\n  SerializedLexicalNode,\n} from 'lexical'\nimport type {\n  Field,\n  FieldSchemaMap,\n  ImportMapGenerators,\n  JsonObject,\n  PayloadComponent,\n  PayloadRequest,\n  PopulateType,\n  ReplaceAny,\n  RequestContext,\n  RichTextField,\n  RichTextHooks,\n  SanitizedConfig,\n  TypedFallbackLocale,\n  ValidateOptions,\n  ValidationFieldError,\n} from 'payload'\n\nimport type { ServerEditorConfig } from '../lexical/config/types.js'\nimport type { Transformer } from '../packages/@lexical/markdown/index.js'\nimport type { LexicalRichTextField } from '../types.js'\nimport type { HTMLConverter } from './converters/lexicalToHtml_deprecated/converter/types.js'\nimport type { BaseClientFeatureProps } from './typesClient.js'\n\nexport type PopulationPromise<T extends SerializedLexicalNode = SerializedLexicalNode> = (args: {\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  draft: boolean\n  /**\n   * This maps all population promises to the node type\n   */\n  editorPopulationPromises: Map<string, Array<PopulationPromise>>\n  field: LexicalRichTextField\n  /**\n   * fieldPromises are used for things like field hooks. They will be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  findMany: boolean\n  flattenLocales: boolean\n  node: T\n  overrideAccess: boolean\n  parentIsLocalized: boolean\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n}) => void\n\nexport type NodeValidation<T extends SerializedLexicalNode = SerializedLexicalNode> = ({\n  node,\n  nodeValidations,\n  validation,\n}: {\n  node: T\n  nodeValidations: Map<string, Array<NodeValidation>>\n  validation: {\n    options: ValidateOptions<unknown, unknown, RichTextField, SerializedEditorState>\n    value: SerializedEditorState\n  }\n}) => Promise<string | true> | string | true\n\nexport type FeatureProviderProviderServer<\n  UnSanitizedServerFeatureProps = undefined,\n  ServerFeatureProps = UnSanitizedServerFeatureProps,\n  ClientFeatureProps = undefined,\n> = (\n  props?: UnSanitizedServerFeatureProps,\n) => FeatureProviderServer<UnSanitizedServerFeatureProps, ServerFeatureProps, ClientFeatureProps>\n\nexport type FeatureProviderServer<\n  UnSanitizedServerFeatureProps = undefined,\n  ServerFeatureProps = UnSanitizedServerFeatureProps,\n  ClientFeatureProps = undefined,\n> = {\n  /** Keys of dependencies needed for this feature. These dependencies do not have to be loaded first, but they have to exist, otherwise an error will be thrown. */\n  dependencies?: string[]\n  /**  Keys of priority dependencies needed for this feature. These dependencies have to be loaded first AND have to exist, otherwise an error will be thrown. They will be available in the `feature` property. */\n  dependenciesPriority?: string[]\n  /** Keys of soft-dependencies needed for this feature. These are optional. Payload will attempt to load them before this feature, but doesn't throw an error if that's not possible. */\n  dependenciesSoft?: string[]\n\n  /**\n   * This is being called during the payload sanitization process\n   */\n  feature:\n    | ((props: {\n        config: SanitizedConfig\n        /** unSanitizedEditorConfig.features, but mapped */\n        featureProviderMap: ServerFeatureProviderMap\n        isRoot?: boolean\n        parentIsLocalized: boolean\n        // other resolved features, which have been loaded before this one. All features declared in 'dependencies' should be available here\n        resolvedFeatures: ResolvedServerFeatureMap\n        // unSanitized EditorConfig,\n        unSanitizedEditorConfig: ServerEditorConfig\n      }) =>\n        | Promise<ServerFeature<ServerFeatureProps, ClientFeatureProps>>\n        | ServerFeature<ServerFeatureProps, ClientFeatureProps>)\n    | ServerFeature<ServerFeatureProps, ClientFeatureProps>\n  key: string\n  /** Props which were passed into your feature will have to be passed here. This will allow them to be used / read in other places of the code, e.g. wherever you can use useEditorConfigContext */\n  serverFeatureProps: UnSanitizedServerFeatureProps\n}\n\nexport type AfterReadNodeHookArgs<T extends SerializedLexicalNode> = {\n  /**\n   * Only available in `afterRead` hooks.\n   */\n  currentDepth: number\n  /**\n   * Only available in `afterRead` hooks.\n   */\n  depth: number\n  draft: boolean\n  fallbackLocale: TypedFallbackLocale\n  /**\n   *  Only available in `afterRead` field hooks.\n   */\n  fieldPromises: Promise<void>[]\n  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */\n  findMany: boolean\n  flattenLocales: boolean\n  /**\n   * The requested locale.\n   */\n  locale: string\n  overrideAccess: boolean\n  /**\n   * Only available in `afterRead` hooks.\n   */\n  populateArg?: PopulateType\n  /**\n   *  Only available in `afterRead` field hooks.\n   */\n  populationPromises: Promise<void>[]\n  /**\n   * Only available in `afterRead` hooks.\n   */\n  showHiddenFields: boolean\n  /**\n   * Only available in `afterRead` hooks.\n   */\n  triggerAccessControl: boolean\n  /**\n   * Only available in `afterRead` hooks.\n   */\n  triggerHooks: boolean\n}\n\nexport type AfterChangeNodeHookArgs<T extends SerializedLexicalNode> = {\n  /** A string relating to which operation the field type is currently executing within. Useful within beforeValidate, beforeChange, and afterChange hooks to differentiate between create and update operations. */\n  operation: 'create' | 'delete' | 'read' | 'update'\n  /** The value of the node before any changes. Not available in afterRead hooks */\n  originalNode: T\n  previousNode: T\n}\nexport type BeforeValidateNodeHookArgs<T extends SerializedLexicalNode> = {\n  /** A string relating to which operation the field type is currently executing within. Useful within beforeValidate, beforeChange, and afterChange hooks to differentiate between create and update operations. */\n  operation: 'create' | 'delete' | 'read' | 'update'\n  /** The value of the node before any changes. Not available in afterRead hooks */\n  originalNode: T\n  overrideAccess: boolean\n}\n\nexport type BeforeChangeNodeHookArgs<T extends SerializedLexicalNode> = {\n  /**\n   * Only available in `beforeChange` hooks.\n   */\n  errors: ValidationFieldError[]\n  mergeLocaleActions: (() => Promise<void> | void)[]\n  /** A string relating to which operation the field type is currently executing within. Useful within beforeValidate, beforeChange, and afterChange hooks to differentiate between create and update operations. */\n  operation: 'create' | 'delete' | 'read' | 'update'\n  /** The value of the node before any changes. Not available in afterRead hooks */\n  originalNode: T\n  /**\n   * The original node with locales (not modified by any hooks).\n   */\n  originalNodeWithLocales?: T\n  previousNode: T\n\n  skipValidation: boolean\n}\n\nexport type BaseNodeHookArgs<T extends SerializedLexicalNode> = {\n  context: RequestContext\n  /** The value of the node. */\n  node: T\n  parentRichTextFieldPath: (number | string)[]\n  parentRichTextFieldSchemaPath: string[]\n  /** The payload request object. It is mocked for Local API operations. */\n  req: PayloadRequest\n}\n\nexport type AfterReadNodeHook<T extends SerializedLexicalNode> = (\n  args: AfterReadNodeHookArgs<T> & BaseNodeHookArgs<T>,\n) => Promise<T> | T\n\nexport type AfterChangeNodeHook<T extends SerializedLexicalNode> = (\n  args: AfterChangeNodeHookArgs<T> & BaseNodeHookArgs<T>,\n) => Promise<T> | T\n\nexport type BeforeChangeNodeHook<T extends SerializedLexicalNode> = (\n  args: BaseNodeHookArgs<T> & BeforeChangeNodeHookArgs<T>,\n) => Promise<T> | T\n\nexport type BeforeValidateNodeHook<T extends SerializedLexicalNode> = (\n  args: BaseNodeHookArgs<T> & BeforeValidateNodeHookArgs<T>,\n) => Promise<T> | T\n\n// Define the node with hooks that use the node's exportJSON return type\nexport type NodeWithHooks<T extends LexicalNode = any> = {\n  /**\n   * Allows you to define how a node can be serialized into different formats. Currently, only supports html.\n   * Markdown converters are defined in `markdownTransformers` and not here.\n   *\n   * @deprecated - will be removed in 4.0\n   */\n  converters?: {\n    /**\n     * @deprecated - will be removed in 4.0\n     */\n    html?: HTMLConverter<ReturnType<ReplaceAny<T, LexicalNode>['exportJSON']>>\n  }\n  /**\n   * If a node includes sub-fields (e.g. block and link nodes), passing those subFields here will make payload\n   * automatically populate, run hooks, and generate component import maps for them\n   */\n  getSubFields?: (args: {\n    /**\n     * Optional. If not provided, all possible sub-fields should be returned.\n     */\n    node?: ReturnType<ReplaceAny<T, LexicalNode>['exportJSON']>\n    req?: PayloadRequest\n  }) => Field[] | null\n  /**\n   * If a node includes sub-fields, the sub-fields data needs to be returned here, alongside `getSubFields` which returns their schema.\n   */\n  getSubFieldsData?: (args: {\n    node: ReturnType<ReplaceAny<T, LexicalNode>['exportJSON']>\n    req: PayloadRequest\n  }) => JsonObject\n  /**\n   * Allows you to run population logic when a node's data was requested from graphQL.\n   * While `getSubFields` and `getSubFieldsData` automatically handle populating sub-fields (since they run hooks on them), those are only populated in the Rest API.\n   * This is because the Rest API hooks do not have access to the 'depth' property provided by graphQL.\n   * In order for them to be populated correctly in graphQL, the population logic needs to be provided here.\n   */\n  graphQLPopulationPromises?: Array<\n    PopulationPromise<ReturnType<ReplaceAny<T, LexicalNode>['exportJSON']>>\n  >\n  /**\n   * Just like payload fields, you can provide hooks which are run for this specific node. These are called Node Hooks.\n   */\n  hooks?: {\n    afterChange?: Array<AfterChangeNodeHook<ReturnType<ReplaceAny<T, LexicalNode>['exportJSON']>>>\n    afterRead?: Array<AfterReadNodeHook<ReturnType<ReplaceAny<T, LexicalNode>['exportJSON']>>>\n    beforeChange?: Array<BeforeChangeNodeHook<ReturnType<ReplaceAny<T, LexicalNode>['exportJSON']>>>\n    beforeValidate?: Array<\n      BeforeValidateNodeHook<ReturnType<ReplaceAny<T, LexicalNode>['exportJSON']>>\n    >\n  }\n  /**\n   * The actual lexical node needs to be provided here. This also supports [lexical node replacements](https://lexical.dev/docs/concepts/node-replacement).\n   */\n  node: Klass<T> | LexicalNodeReplacement\n  /**\n   * This allows you to provide node validations, which are run when your document is being validated, alongside other payload fields.\n   * You can use it to throw a validation error for a specific node in case its data is incorrect.\n   */\n  validations?: Array<NodeValidation<ReturnType<ReplaceAny<T, LexicalNode>['exportJSON']>>>\n}\n\nexport type ServerFeature<ServerProps, ClientFeatureProps> = {\n  ClientFeature?: PayloadComponent<never, BaseClientFeatureProps<ClientFeatureProps>>\n  /**\n   * This determines what props will be available on the Client.\n   */\n  clientFeatureProps?: ClientFeatureProps\n  /**\n   * Adds payload components to the importMap.\n   *\n   * If an object is provided, the imported components will automatically be made available to the client feature, keyed by the object's keys.\n   */\n  componentImports?:\n    | {\n        [key: string]: PayloadComponent\n      }\n    | ImportMapGenerators[0]\n    | PayloadComponent[]\n  generatedTypes?: {\n    modifyOutputSchema: (args: {\n      collectionIDFieldTypes: { [key: string]: 'number' | 'string' }\n      config?: SanitizedConfig\n      /**\n       * Current schema which will be modified by this function.\n       */\n      currentSchema: JSONSchema4\n      field: LexicalRichTextField\n      i18n?: I18n\n      /**\n       * Allows you to define new top-level interfaces that can be re-used in the output schema.\n       */\n      interfaceNameDefinitions: Map<string, JSONSchema4>\n      isRequired: boolean\n    }) => JSONSchema4\n  }\n  generateSchemaMap?: (args: {\n    config: SanitizedConfig\n    field: RichTextField\n    i18n: I18nClient\n    props: ServerProps\n    schemaMap: FieldSchemaMap\n    schemaPath: string\n  }) => FieldSchemaMap | null\n  hooks?: RichTextHooks\n  /**\n   * Here you can provide i18n translations for your feature. These will only be available on the server and client.\n   *\n   * Translations here are automatically scoped to `lexical.featureKey.yourKey`\n   *\n   * @Example\n   * ```ts\n   * i18n: {\n   *   en: {\n   *     label: 'Horizontal Rule',\n   *   },\n   *   de: {\n   *     label: 'Trennlinie',\n   *   },\n   * }\n   * ```\n   * In order to access these translations, you would use `i18n.t('lexical:horizontalRule:label')`.\n   */\n  i18n?: Partial<GenericLanguages>\n  markdownTransformers?: (\n    | ((props: { allNodes: Array<NodeWithHooks>; allTransformers: Transformer[] }) => Transformer)\n    | Transformer\n  )[]\n  nodes?: Array<NodeWithHooks>\n\n  /** Props which were passed into your feature will have to be passed here. This will allow them to be used / read in other places of the code, e.g. wherever you can use useEditorConfigContext */\n  sanitizedServerFeatureProps?: ServerProps\n}\n\nexport type ResolvedServerFeature<ServerProps, ClientFeatureProps> = {\n  order: number\n} & Required<\n  Pick<\n    FeatureProviderServer<ServerProps, ClientFeatureProps>,\n    'dependencies' | 'dependenciesPriority' | 'dependenciesSoft' | 'key'\n  >\n> &\n  ServerFeature<ServerProps, ClientFeatureProps>\n\nexport type ResolvedServerFeatureMap = Map<string, ResolvedServerFeature<any, any>>\n\nexport type ServerFeatureProviderMap = Map<string, FeatureProviderServer<any, any, any>>\n\nexport type SanitizedServerFeatures = {\n  /**  The node types mapped to their converters */\n  converters: {\n    html: HTMLConverter[]\n  }\n  /** The keys of all enabled features */\n  enabledFeatures: string[]\n  generatedTypes: {\n    modifyOutputSchemas: Array<\n      (args: {\n        collectionIDFieldTypes: { [key: string]: 'number' | 'string' }\n        config?: SanitizedConfig\n        /**\n         * Current schema which will be modified by this function.\n         */\n        currentSchema: JSONSchema4\n        field: LexicalRichTextField\n        i18n?: I18n\n        /**\n         * Allows you to define new top-level interfaces that can be re-used in the output schema.\n         */\n        interfaceNameDefinitions: Map<string, JSONSchema4>\n        isRequired: boolean\n      }) => JSONSchema4\n    >\n  }\n  /**  The node types mapped to their hooks */\n\n  getSubFields?: Map<\n    string,\n    (args: { node: SerializedLexicalNode; req: PayloadRequest }) => Field[] | null\n  >\n  getSubFieldsData?: Map<\n    string,\n    (args: { node: SerializedLexicalNode; req: PayloadRequest }) => JsonObject\n  >\n  graphQLPopulationPromises: Map<string, Array<PopulationPromise>>\n  hooks: RichTextHooks\n  markdownTransformers: Transformer[]\n  nodeHooks?: {\n    afterChange?: Map<string, Array<AfterChangeNodeHook<SerializedLexicalNode>>>\n    afterRead?: Map<string, Array<AfterReadNodeHook<SerializedLexicalNode>>>\n    beforeChange?: Map<string, Array<BeforeChangeNodeHook<SerializedLexicalNode>>>\n    beforeValidate?: Map<string, Array<BeforeValidateNodeHook<SerializedLexicalNode>>>\n  } /**  The node types mapped to their populationPromises */\n  /**  The node types mapped to their validations */\n  validations: Map<string, Array<NodeValidation>>\n} & Required<Pick<ResolvedServerFeature<any, any>, 'i18n' | 'nodes'>>\n"],"mappings":"AAgXA","ignoreList":[]}