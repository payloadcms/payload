{"version":3,"file":"getLexicalToMarkdown.js","names":["createHeadlessEditor","$convertToMarkdownString","getLexicalToMarkdown","allNodes","allTransformers","lexicalToMarkdown","editorState","headlessEditor","nodes","setEditorState","parseEditorState","e","console","error","markdown","getEditorState","read"],"sources":["../../../../../src/features/blocks/client/markdown/getLexicalToMarkdown.ts"],"sourcesContent":["import type { Klass, LexicalNode, LexicalNodeReplacement } from 'lexical'\n\nimport { createHeadlessEditor } from '@lexical/headless'\n\nimport {\n  $convertToMarkdownString,\n  type Transformer,\n} from '../../../../packages/@lexical/markdown/index.js'\n\nexport function getLexicalToMarkdown(\n  allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>,\n  allTransformers: Transformer[],\n): (args: { editorState: Record<string, any> }) => string {\n  const lexicalToMarkdown = ({ editorState }: { editorState: Record<string, any> }): string => {\n    const headlessEditor = createHeadlessEditor({\n      nodes: allNodes,\n    })\n\n    try {\n      headlessEditor.setEditorState(headlessEditor.parseEditorState(editorState as any)) // This should commit the editor state immediately\n    } catch (e) {\n      console.error('getLexicalToMarkdown: ERROR parsing editor state', e)\n    }\n\n    let markdown: string = ''\n    headlessEditor.getEditorState().read(() => {\n      markdown = $convertToMarkdownString(allTransformers)\n    })\n\n    return markdown\n  }\n  return lexicalToMarkdown\n}\n"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ;AAErC,SACEC,wBAAwB,QAEnB;AAEP,OAAO,SAASC,qBACdC,QAA4D,EAC5DC,eAA8B;EAE9B,MAAMC,iBAAA,GAAoBA,CAAC;IAAEC;EAAW,CAAwC;IAC9E,MAAMC,cAAA,GAAiBP,oBAAA,CAAqB;MAC1CQ,KAAA,EAAOL;IACT;IAEA,IAAI;MACFI,cAAA,CAAeE,cAAc,CAACF,cAAA,CAAeG,gBAAgB,CAACJ,WAAA,IAAqB;IACrF,EAAE,OAAOK,CAAA,EAAG;MACVC,OAAA,CAAQC,KAAK,CAAC,oDAAoDF,CAAA;IACpE;IAEA,IAAIG,QAAA,GAAmB;IACvBP,cAAA,CAAeQ,cAAc,GAAGC,IAAI,CAAC;MACnCF,QAAA,GAAWb,wBAAA,CAAyBG,eAAA;IACtC;IAEA,OAAOU,QAAA;EACT;EACA,OAAOT,iBAAA;AACT","ignoreList":[]}