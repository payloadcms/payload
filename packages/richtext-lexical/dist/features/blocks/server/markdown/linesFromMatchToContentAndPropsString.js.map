{"version":3,"file":"linesFromMatchToContentAndPropsString.js","names":["linesFromStartToContentAndPropsString","isEndOptional","lines","regexpEndRegex","startLineIndex","startMatch","trimChildren","propsString","content","linesCopy","slice","isWithinContent","contentSubTagStartAmount","bracketCount","quoteChar","isSelfClosing","isWithinCodeBlockAmount","beforeStartLine","index","endlineLastCharIndex","endLineIndex","mainLoop","lineIndex","lineCopy","entries","line","trim","amountOfBeginningSpacesRemoved","i","length","charIndex","char","nextChar","match","undefined","Error","join","JSON","stringify","afterEndLine"],"sources":["../../../../../src/features/blocks/server/markdown/linesFromMatchToContentAndPropsString.ts"],"sourcesContent":["export function linesFromStartToContentAndPropsString({\n  isEndOptional,\n  lines,\n  regexpEndRegex,\n  startLineIndex,\n  startMatch,\n  trimChildren,\n}: {\n  isEndOptional?: boolean\n  lines: string[]\n  regexpEndRegex?: RegExp\n  startLineIndex: number\n  startMatch: RegExpMatchArray\n  trimChildren?: boolean\n}): {\n  /**\n   * The matched string after the end match, in the same line as the end match. Useful for inline matches.\n   */\n  afterEndLine: string\n  /**\n   * The matched string before the start match, in the same line as the start match. Useful for inline matches.\n   */\n  beforeStartLine: string\n  content: string\n  endLineIndex: number\n  endlineLastCharIndex: number\n  propsString: string\n} {\n  let propsString = ''\n  let content = ''\n  const linesCopy = lines.slice(startLineIndex)\n\n  let isWithinContent = false // If false => is within prop\n  let contentSubTagStartAmount = 0\n\n  let bracketCount = 0\n  let quoteChar: null | string = null\n  let isSelfClosing = false\n  let isWithinCodeBlockAmount = 0\n\n  const beforeStartLine = linesCopy[0]!.slice(0, startMatch.index)\n  let endlineLastCharIndex = 0\n\n  let endLineIndex = startLineIndex\n\n  mainLoop: for (const [lineIndex, lineCopy] of linesCopy.entries()) {\n    const line = trimChildren ? lineCopy.trim() : lineCopy\n    let amountOfBeginningSpacesRemoved = 0\n    if (trimChildren) {\n      for (let i = 0; i < lineCopy.length; i++) {\n        if (lineCopy[i] === ' ') {\n          amountOfBeginningSpacesRemoved++\n        } else {\n          break\n        }\n      }\n    }\n\n    let charIndex = 0\n\n    if (lineIndex === 0) {\n      charIndex = (startMatch.index ?? 0) + startMatch[0].length - amountOfBeginningSpacesRemoved // We need to also loop over the \">\" in something like \"<InlineCode>\" in order to later set isWithinContent to true\n    }\n\n    while (charIndex < line.length) {\n      const char = line[charIndex]\n      const nextChar = line[charIndex + 1]\n\n      if (!isWithinContent) {\n        if (char === '{' && !quoteChar) {\n          bracketCount++\n        } else if (char === '}' && !quoteChar) {\n          bracketCount--\n        } else if ((char === '\"' || char === \"'\") && !quoteChar) {\n          quoteChar = char\n        } else if (char === quoteChar) {\n          quoteChar = null\n        }\n\n        if (char === '/' && nextChar === '>' && bracketCount === 0 && !quoteChar) {\n          isSelfClosing = true\n          endLineIndex = lineIndex\n          endlineLastCharIndex = charIndex + 2\n\n          break mainLoop\n        } else if (char === '>' && bracketCount === 0 && !quoteChar) {\n          isWithinContent = true\n          charIndex++\n          continue\n        }\n\n        propsString += char\n      } else {\n        if (char === '`') {\n          isWithinCodeBlockAmount++\n        }\n\n        if (isWithinCodeBlockAmount % 2 === 0) {\n          if (char === '<' && nextChar === '/') {\n            contentSubTagStartAmount--\n\n            if (contentSubTagStartAmount < 0) {\n              if (content[content.length - 1] === '\\n') {\n                content = content.slice(0, -1) // Remove the last newline\n              }\n              endLineIndex = lineIndex\n              // Calculate endlineLastCharIndex by finding \">\" in line\n              for (let i = charIndex; i < line.length; i++) {\n                if (line[i] === '>') {\n                  endlineLastCharIndex = i + 1\n\n                  break\n                }\n              }\n              break mainLoop\n            }\n          } else if (char === '/' && nextChar === '>') {\n            contentSubTagStartAmount--\n\n            if (contentSubTagStartAmount < 0) {\n              if (content[content.length - 1] === '\\n') {\n                content = content.slice(0, -1) // Remove the last newline\n              }\n              endLineIndex = lineIndex\n              endlineLastCharIndex = charIndex + 2\n              break mainLoop\n            }\n          } else if (char === '<' && nextChar !== '/') {\n            contentSubTagStartAmount++\n          }\n        }\n\n        content += char\n      }\n\n      charIndex++\n    }\n\n    if (isWithinContent) {\n      if (content?.length > 0 && lineIndex > 0) {\n        content += '\\n'\n      }\n    } else {\n      propsString += '\\n'\n    }\n\n    if (regexpEndRegex && contentSubTagStartAmount < 0) {\n      // If 0 and in same line where it got lowered to 0 then this is not the match we are looking for\n      const match = line.match(regexpEndRegex)\n      if (match?.index !== undefined) {\n        endLineIndex = lineIndex\n        endlineLastCharIndex = match.index + match[0].length - 1\n        break\n      }\n    }\n\n    if (lineIndex === linesCopy.length - 1 && !isEndOptional && !isSelfClosing) {\n      throw new Error(\n        'End match not found for lines ' +\n          lines.join('\\n') +\n          '\\n\\n. Start match: ' +\n          JSON.stringify(startMatch),\n      )\n    }\n  }\n\n  const afterEndLine = linesCopy[endLineIndex]!.trim().slice(endlineLastCharIndex)\n\n  return {\n    afterEndLine,\n    beforeStartLine,\n    content,\n    endLineIndex: startLineIndex + endLineIndex,\n    endlineLastCharIndex,\n    propsString,\n  }\n}\n"],"mappings":"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","ignoreList":[]}