{"version":3,"file":"editorConfigFactory.js","names":["defaultEditorConfig","defaultEditorFeatures","loadFeatures","sanitizeServerFeatures","getDefaultSanitizedEditorConfig","editorConfigFactory","default","args","config","parentIsLocalized","fromEditor","lexicalAdapter","editor","isRoot","sanitizedServerEditorConfig","editorConfig","fromFeatures","featuresInputToEditorConfig","sanitizedConfig","fromField","field","fromUnsanitizedField","lexicalAdapterProvider","features","rootEditor","rootEditorFeatures","defaultFeatures","rootFeatures","lexical","resolvedFeatureMap","unSanitizedEditorConfig"],"sources":["../../src/utilities/editorConfigFactory.ts"],"sourcesContent":["import type { EditorConfig as LexicalEditorConfig } from 'lexical'\nimport type { RichTextAdapterProvider, RichTextField, SanitizedConfig } from 'payload'\n\nimport type { FeatureProviderServer, ResolvedServerFeatureMap } from '../features/typesServer.js'\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\nimport type {\n  FeaturesInput,\n  LexicalRichTextAdapter,\n  LexicalRichTextAdapterProvider,\n} from '../types.js'\n\nimport { defaultEditorConfig, defaultEditorFeatures } from '../lexical/config/server/default.js'\nimport { loadFeatures } from '../lexical/config/server/loader.js'\nimport { sanitizeServerFeatures } from '../lexical/config/server/sanitize.js'\nimport { getDefaultSanitizedEditorConfig } from './getDefaultSanitizedEditorConfig.js'\n\nexport const editorConfigFactory = {\n  default: async (args: {\n    config: SanitizedConfig\n    parentIsLocalized?: boolean\n  }): Promise<SanitizedServerEditorConfig> => {\n    return getDefaultSanitizedEditorConfig({\n      config: args.config,\n      parentIsLocalized: args.parentIsLocalized ?? false,\n    })\n  },\n  /**\n   * If you have instantiated a lexical editor and are accessing it outside a field (=> this is the unsanitized editor),\n   * you can extract the editor config from it.\n   * This is common if you define the editor in a re-usable module scope variable and pass it to the richText field.\n   *\n   * This is the least efficient way to get the editor config, and not recommended. It is recommended to extract the `features` arg\n   * into a separate variable and use `fromFeatures` instead.\n   */\n  fromEditor: async (args: {\n    config: SanitizedConfig\n    editor: LexicalRichTextAdapterProvider\n    isRoot?: boolean\n    lexical?: LexicalEditorConfig\n    parentIsLocalized?: boolean\n  }): Promise<SanitizedServerEditorConfig> => {\n    const lexicalAdapter: LexicalRichTextAdapter = await args.editor({\n      config: args.config,\n      isRoot: args.isRoot ?? false,\n      parentIsLocalized: args.parentIsLocalized ?? false,\n    })\n\n    const sanitizedServerEditorConfig: SanitizedServerEditorConfig = lexicalAdapter.editorConfig\n    return sanitizedServerEditorConfig\n  },\n  /**\n   * Create a new editor config - behaves just like instantiating a new `lexicalEditor`\n   */\n  fromFeatures: async (args: {\n    config: SanitizedConfig\n    features?: FeaturesInput\n    isRoot?: boolean\n    lexical?: LexicalEditorConfig\n    parentIsLocalized?: boolean\n  }): Promise<SanitizedServerEditorConfig> => {\n    return (await featuresInputToEditorConfig(args)).sanitizedConfig\n  },\n  fromField: (args: { field: RichTextField }): SanitizedServerEditorConfig => {\n    const lexicalAdapter: LexicalRichTextAdapter = args.field.editor as LexicalRichTextAdapter\n\n    const sanitizedServerEditorConfig: SanitizedServerEditorConfig = lexicalAdapter.editorConfig\n    return sanitizedServerEditorConfig\n  },\n  fromUnsanitizedField: async (args: {\n    config: SanitizedConfig\n    field: RichTextField\n    isRoot?: boolean\n    parentIsLocalized?: boolean\n  }): Promise<SanitizedServerEditorConfig> => {\n    const lexicalAdapterProvider: RichTextAdapterProvider = args.field\n      .editor as RichTextAdapterProvider\n\n    const lexicalAdapter: LexicalRichTextAdapter = (await lexicalAdapterProvider({\n      config: args.config,\n      isRoot: args.isRoot ?? false,\n      parentIsLocalized: args.parentIsLocalized ?? false,\n    })) as LexicalRichTextAdapter\n\n    const sanitizedServerEditorConfig: SanitizedServerEditorConfig = lexicalAdapter.editorConfig\n    return sanitizedServerEditorConfig\n  },\n}\n\nexport const featuresInputToEditorConfig = async (args: {\n  config: SanitizedConfig\n  features?: FeaturesInput\n  isRoot?: boolean\n  lexical?: LexicalEditorConfig\n  parentIsLocalized?: boolean\n}): Promise<{\n  features: FeatureProviderServer<unknown, unknown, unknown>[]\n  resolvedFeatureMap: ResolvedServerFeatureMap\n  sanitizedConfig: SanitizedServerEditorConfig\n}> => {\n  let features: FeatureProviderServer<unknown, unknown, unknown>[] = []\n  if (args.features && typeof args.features === 'function') {\n    const rootEditor = args.config.editor\n    let rootEditorFeatures: FeatureProviderServer<unknown, unknown, unknown>[] = []\n    if (typeof rootEditor === 'object' && 'features' in rootEditor) {\n      rootEditorFeatures = (rootEditor as LexicalRichTextAdapter).features\n    }\n    features = args.features({\n      defaultFeatures: defaultEditorFeatures,\n      rootFeatures: rootEditorFeatures,\n    })\n  } else {\n    features = args.features as FeatureProviderServer<unknown, unknown, unknown>[]\n  }\n\n  if (!features) {\n    features = defaultEditorFeatures\n  }\n\n  const lexical = args.lexical ?? defaultEditorConfig.lexical\n\n  const resolvedFeatureMap = await loadFeatures({\n    config: args.config,\n    isRoot: args.isRoot ?? false,\n    parentIsLocalized: args.parentIsLocalized ?? false,\n    unSanitizedEditorConfig: {\n      features,\n      lexical,\n    },\n  })\n\n  return {\n    features,\n    resolvedFeatureMap,\n    sanitizedConfig: {\n      features: sanitizeServerFeatures(resolvedFeatureMap),\n      lexical: args.lexical,\n      resolvedFeatureMap,\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]}