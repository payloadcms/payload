{"version":3,"file":"applyBaseFilterToFields.js","names":["combineWhereConstraints","applyBaseFilterToFields","fields","config","map","field","type","relationshipField","originalFilterOptions","filterOptions","args","relationTo","req","user","originalResult","admin","collections","find","slug","hidden","baseFilter","baseListFilter","baseFilterResult","limit","page","sort","tabs","tab","blocks","blockReferences","block"],"sources":["../../src/utilities/applyBaseFilterToFields.ts"],"sourcesContent":["import type { Block, Field, SanitizedConfig, TypedUser } from 'payload'\n\nimport { combineWhereConstraints } from 'payload/shared'\n\n/**\n * Recursively applies baseFilter from collection config to relationship fields\n * within blocks. This ensures that relationship drawers in blocks respect\n * collection-level filters like multi-tenant filtering.\n *\n * Based on the fix from PR #13229 for LinkFeature\n */\nexport function applyBaseFilterToFields(fields: Field[], config: SanitizedConfig): Field[] {\n  return fields.map((field) => {\n    // Handle relationship fields\n    if (field.type === 'relationship') {\n      const relationshipField = field\n\n      // Store the original filterOptions\n      const originalFilterOptions = relationshipField.filterOptions\n\n      // Create new filterOptions that includes baseFilter\n      relationshipField.filterOptions = async (args) => {\n        const { relationTo, req, user } = args\n\n        // Call original filterOptions if it exists\n        const originalResult =\n          typeof originalFilterOptions === 'function'\n            ? await originalFilterOptions(args)\n            : (originalFilterOptions ?? true)\n\n        // If original filter returns false, respect that\n        if (originalResult === false) {\n          return false\n        }\n\n        // Get the collection's admin config\n        const admin = config.collections.find(({ slug }) => slug === relationTo)?.admin\n\n        // Check if collection is hidden\n        const hidden = admin?.hidden\n        if (typeof hidden === 'function' && hidden({ user } as { user: TypedUser })) {\n          return false\n        }\n\n        // Apply baseFilter (with backwards compatibility for baseListFilter)\n        const baseFilter = admin?.baseFilter ?? admin?.baseListFilter\n        const baseFilterResult = await baseFilter?.({\n          limit: 0,\n          page: 1,\n          req,\n          sort: 'id',\n        })\n\n        // If no baseFilter, return original result\n        if (!baseFilterResult) {\n          return originalResult\n        }\n\n        // If original result is true, just return the baseFilter\n        if (originalResult === true) {\n          return baseFilterResult\n        }\n\n        // Combine original and baseFilter results\n        return combineWhereConstraints([originalResult, baseFilterResult], 'and')\n      }\n\n      return relationshipField\n    }\n\n    // Recursively process nested fields\n    if ('fields' in field && field.fields) {\n      return {\n        ...field,\n        fields: applyBaseFilterToFields(field.fields, config),\n      }\n    }\n\n    // Handle tabs\n    if (field.type === 'tabs' && 'tabs' in field) {\n      return {\n        ...field,\n        tabs: field.tabs.map((tab) => ({\n          ...tab,\n          fields: applyBaseFilterToFields(tab.fields, config),\n        })),\n      }\n    }\n\n    // Handle blocks\n    if (field.type === 'blocks') {\n      const blocks = (field.blockReferences ?? field.blocks ?? []) as Block[]\n      return {\n        ...field,\n        blocks: blocks.map((block) => {\n          if (typeof block === 'string') {\n            return block\n          }\n          return {\n            ...block,\n            fields: applyBaseFilterToFields(block.fields, config),\n          }\n        }),\n      }\n    }\n\n    return field\n  })\n}\n"],"mappings":"AAEA,SAASA,uBAAuB,QAAQ;AAExC;;;;;;;AAOA,OAAO,SAASC,wBAAwBC,MAAe,EAAEC,MAAuB;EAC9E,OAAOD,MAAA,CAAOE,GAAG,CAAEC,KAAA;IACjB;IACA,IAAIA,KAAA,CAAMC,IAAI,KAAK,gBAAgB;MACjC,MAAMC,iBAAA,GAAoBF,KAAA;MAE1B;MACA,MAAMG,qBAAA,GAAwBD,iBAAA,CAAkBE,aAAa;MAE7D;MACAF,iBAAA,CAAkBE,aAAa,GAAG,MAAOC,IAAA;QACvC,MAAM;UAAEC,UAAU;UAAEC,GAAG;UAAEC;QAAI,CAAE,GAAGH,IAAA;QAElC;QACA,MAAMI,cAAA,GACJ,OAAON,qBAAA,KAA0B,aAC7B,MAAMA,qBAAA,CAAsBE,IAAA,IAC3BF,qBAAA,IAAyB;QAEhC;QACA,IAAIM,cAAA,KAAmB,OAAO;UAC5B,OAAO;QACT;QAEA;QACA,MAAMC,KAAA,GAAQZ,MAAA,CAAOa,WAAW,CAACC,IAAI,CAAC,CAAC;UAAEC;QAAI,CAAE,KAAKA,IAAA,KAASP,UAAA,GAAaI,KAAA;QAE1E;QACA,MAAMI,MAAA,GAASJ,KAAA,EAAOI,MAAA;QACtB,IAAI,OAAOA,MAAA,KAAW,cAAcA,MAAA,CAAO;UAAEN;QAAK,IAA2B;UAC3E,OAAO;QACT;QAEA;QACA,MAAMO,UAAA,GAAaL,KAAA,EAAOK,UAAA,IAAcL,KAAA,EAAOM,cAAA;QAC/C,MAAMC,gBAAA,GAAmB,MAAMF,UAAA,GAAa;UAC1CG,KAAA,EAAO;UACPC,IAAA,EAAM;UACNZ,GAAA;UACAa,IAAA,EAAM;QACR;QAEA;QACA,IAAI,CAACH,gBAAA,EAAkB;UACrB,OAAOR,cAAA;QACT;QAEA;QACA,IAAIA,cAAA,KAAmB,MAAM;UAC3B,OAAOQ,gBAAA;QACT;QAEA;QACA,OAAOtB,uBAAA,CAAwB,CAACc,cAAA,EAAgBQ,gBAAA,CAAiB,EAAE;MACrE;MAEA,OAAOf,iBAAA;IACT;IAEA;IACA,IAAI,YAAYF,KAAA,IAASA,KAAA,CAAMH,MAAM,EAAE;MACrC,OAAO;QACL,GAAGG,KAAK;QACRH,MAAA,EAAQD,uBAAA,CAAwBI,KAAA,CAAMH,MAAM,EAAEC,MAAA;MAChD;IACF;IAEA;IACA,IAAIE,KAAA,CAAMC,IAAI,KAAK,UAAU,UAAUD,KAAA,EAAO;MAC5C,OAAO;QACL,GAAGA,KAAK;QACRqB,IAAA,EAAMrB,KAAA,CAAMqB,IAAI,CAACtB,GAAG,CAAEuB,GAAA,KAAS;UAC7B,GAAGA,GAAG;UACNzB,MAAA,EAAQD,uBAAA,CAAwB0B,GAAA,CAAIzB,MAAM,EAAEC,MAAA;QAC9C;MACF;IACF;IAEA;IACA,IAAIE,KAAA,CAAMC,IAAI,KAAK,UAAU;MAC3B,MAAMsB,MAAA,GAAUvB,KAAA,CAAMwB,eAAe,IAAIxB,KAAA,CAAMuB,MAAM,IAAI,EAAE;MAC3D,OAAO;QACL,GAAGvB,KAAK;QACRuB,MAAA,EAAQA,MAAA,CAAOxB,GAAG,CAAE0B,KAAA;UAClB,IAAI,OAAOA,KAAA,KAAU,UAAU;YAC7B,OAAOA,KAAA;UACT;UACA,OAAO;YACL,GAAGA,KAAK;YACR5B,MAAA,EAAQD,uBAAA,CAAwB6B,KAAA,CAAM5B,MAAM,EAAEC,MAAA;UAChD;QACF;MACF;IACF;IAEA,OAAOE,KAAA;EACT;AACF","ignoreList":[]}