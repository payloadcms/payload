{"version":3,"file":"useRunDeprioritized.js","names":["c","_c","useCallback","useRef","useRunDeprioritized","t0","$","timeout","undefined","idleHandleRef","t1","fn","Promise","resolve","exec","window","current","cancelIdleCallback","requestIdleCallback","interactionResponse","then","runDeprioritized","setTimeout","requestAnimationFrame"],"sources":["../../src/utilities/useRunDeprioritized.ts"],"sourcesContent":["'use client'\nimport { useCallback, useRef } from 'react'\n\n/**\n * Simple hook that lets you run any callback once the main thread is idle\n * (via `requestIdleCallback`) or when that API is missing (Safari) - after the\n * next animation frame (`interactionResponse`).\n *\n * This will help you to avoid blocking the main thread with heavy work.\n *\n * The latest invocation wins: if a new run is queued before the previous one\n * executes, the previous task is cancelled.\n *\n * Usage:\n * ```ts\n * const runDeprioritized = useRunDeprioritized();\n *\n * const onEditorChange = (state: EditorState) => {\n *   runDeprioritized(() => {\n *     // heavy work here â€¦\n *   });\n * };\n * ```\n *\n * @param timeout  Optional timeout (ms) for `requestIdleCallback`; defaults to 500 ms.\n * @returns        A `runDeprioritized(fn)` helper.\n */\n\nexport function useRunDeprioritized(timeout = 500) {\n  const idleHandleRef = useRef<number>(undefined)\n\n  /**\n   * Schedule `fn` and resolve when it has executed.\n   */\n  const runDeprioritized = useCallback(\n    (fn: () => void): Promise<void> => {\n      return new Promise<void>((resolve) => {\n        const exec = () => {\n          fn()\n          resolve()\n        }\n\n        if ('requestIdleCallback' in window) {\n          // Cancel any previously queued task so only the latest runs.\n          if ('cancelIdleCallback' in window && idleHandleRef.current !== undefined) {\n            // Cancel earlier scheduled value updates,\n            // so that a CPU-limited event loop isn't flooded with n callbacks for n keystrokes into the rich text field,\n            // but that there's only ever the latest one state update\n            // dispatch task, to be executed with the next idle time,\n            // or the deadline of 500ms.\n            cancelIdleCallback(idleHandleRef.current)\n          }\n          // Schedule the state update to happen the next time the browser has sufficient resources,\n          // or the latest after 500ms.\n          idleHandleRef.current = requestIdleCallback(exec, { timeout })\n        } else {\n          // Safari fallback: rAF + setTimeout shim.\n          void interactionResponse().then(exec)\n        }\n      })\n    },\n    [timeout],\n  )\n\n  return runDeprioritized\n}\n\nfunction interactionResponse(): Promise<unknown> {\n  // Taken from https://github.com/vercel-labs/await-interaction-response/tree/main/packages/await-interaction-response/src\n\n  return new Promise((resolve) => {\n    setTimeout(resolve, 100) // Fallback for the case where the animation frame never fires.\n    requestAnimationFrame(() => {\n      setTimeout(resolve, 0)\n    })\n  })\n}\n"],"mappings":"AAAA;;AAAA,SAAAA,CAAA,IAAAC,EAAA;AACA,SAASC,WAAW,EAAEC,MAAM,QAAQ;AAEpC;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAO,SAAAC,oBAAAC,EAAA;EAAA,MAAAC,CAAA,GAAAL,EAAA;EAA6B,MAAAM,OAAA,GAAAF,EAAa,KAAAG,SAAA,SAAbH,EAAa;EAC/C,MAAAI,aAAA,GAAsBN,MAAA,CAAAK,SAAe;EAAA,IAAAE,EAAA;EAAA,IAAAJ,CAAA,QAAAC,OAAA;IAMnCG,EAAA,GAAAC,EAAA,QAAAC,OAAA,CAAAC,OAAA;MAEI,MAAAC,IAAA,GAAAA,CAAA;QACEH,EAAA;QACAE,OAAA;MAAA;MACF,IAEI,yBAAAE,MAAyB;QAAA,IAEvB,wBAAAA,MAAwB,IAAUN,aAAA,CAAAO,OAAA,KAAAR,SAA0B;UAM9DS,kBAAA,CAAmBR,aAAA,CAAAO,OAAqB;QAAA;QAI1CP,aAAA,CAAAO,OAAA,GAAwBE,mBAAA,CAAoBJ,IAAA;UAAAP;QAAA,CAAgB;MAAA;QAGvDY,mBAAA,GAAAC,IAAA,CAA2BN,IAAA;MAAA;IAAA;IAGtCR,CAAA,MAAAC,OAAA;IAAAD,CAAA,MAAAI,EAAA;EAAA;IAAAA,EAAA,GAAAJ,CAAA;EAAA;EA1BF,MAAAe,gBAAA,GAAyBX,EA2Bd;EAAA,OAGJW,gBAAA;AAAA;AAGT,SAASF,oBAAA;EACP;EAEA,OAAO,IAAIP,OAAA,CAASC,OAAA;IAClBS,UAAA,CAAWT,OAAA,EAAS,MAAK;IACzBU,qBAAA,CAAsB;MACpBD,UAAA,CAAWT,OAAA,EAAS;IACtB;EACF;AACF","ignoreList":[]}