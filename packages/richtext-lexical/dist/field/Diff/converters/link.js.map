{"version":3,"file":"link.js","names":["createHash","LinkDiffHTMLConverterAsync","internalDocToHref","autolink","node","nodesToHTML","providedStyleTag","children","nodes","join","nodeFieldsHash","update","JSON","stringify","fields","digest","url","newTab","link","populate","href","linkType","linkNode","console","error"],"sources":["../../../../src/field/Diff/converters/link.ts"],"sourcesContent":["import { createHash } from 'crypto'\n\nimport type {\n  HTMLConvertersAsync,\n  HTMLPopulateFn,\n} from '../../../features/converters/lexicalToHtml/async/types.js'\nimport type { SerializedAutoLinkNode, SerializedLinkNode } from '../../../nodeTypes.js'\n\nexport const LinkDiffHTMLConverterAsync: (args: {\n  internalDocToHref?: (args: {\n    linkNode: SerializedLinkNode\n    populate?: HTMLPopulateFn\n  }) => Promise<string> | string\n}) => HTMLConvertersAsync<SerializedAutoLinkNode | SerializedLinkNode> = ({\n  internalDocToHref,\n}) => ({\n  autolink: async ({ node, nodesToHTML, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    // hash fields to ensure they are diffed if they change\n    const nodeFieldsHash = createHash('sha256').update(JSON.stringify(node.fields)).digest('hex')\n\n    return `<a${providedStyleTag} data-fields-hash=\"${nodeFieldsHash}\" data-enable-match=\"true\" href=\"${node.fields.url}\"${node.fields.newTab ? ' rel=\"noopener noreferrer\" target=\"_blank\"' : ''}>\n        ${children}\n      </a>`\n  },\n  link: async ({ node, nodesToHTML, populate, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    let href: string = node.fields.url ?? ''\n    if (node.fields.linkType === 'internal') {\n      if (internalDocToHref) {\n        href = await internalDocToHref({ linkNode: node, populate })\n      } else {\n        console.error(\n          'Lexical => HTML converter: Link converter: found internal link, but internalDocToHref is not provided',\n        )\n        href = '#' // fallback\n      }\n    }\n\n    // hash fields to ensure they are diffed if they change\n    const nodeFieldsHash = createHash('sha256')\n      .update(JSON.stringify(node.fields ?? {}))\n      .digest('hex')\n\n    return `<a${providedStyleTag} data-fields-hash=\"${nodeFieldsHash}\" data-enable-match=\"true\" href=\"${href}\"${node.fields.newTab ? ' rel=\"noopener noreferrer\" target=\"_blank\"' : ''}>\n        ${children}\n      </a>`\n  },\n})\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ;AAQ3B,OAAO,MAAMC,0BAAA,GAK4DA,CAAC;EACxEC;AAAiB,CAClB,MAAM;EACLC,QAAA,EAAU,MAAAA,CAAO;IAAEC,IAAI;IAAEC,WAAW;IAAEC;EAAgB,CAAE;IACtD,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;MAChBG,KAAA,EAAOJ,IAAA,CAAKG;IACd,EAAC,EACDE,IAAI,CAAC;IAEP;IACA,MAAMC,cAAA,GAAiBV,UAAA,CAAW,UAAUW,MAAM,CAACC,IAAA,CAAKC,SAAS,CAACT,IAAA,CAAKU,MAAM,GAAGC,MAAM,CAAC;IAEvF,OAAO,KAAKT,gBAAA,sBAAsCI,cAAA,oCAAkDN,IAAA,CAAKU,MAAM,CAACE,GAAG,IAAIZ,IAAA,CAAKU,MAAM,CAACG,MAAM,GAAG,+CAA+C;UACrLV,QAAA;WACC;EACT;EACAW,IAAA,EAAM,MAAAA,CAAO;IAAEd,IAAI;IAAEC,WAAW;IAAEc,QAAQ;IAAEb;EAAgB,CAAE;IAC5D,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;MAChBG,KAAA,EAAOJ,IAAA,CAAKG;IACd,EAAC,EACDE,IAAI,CAAC;IAEP,IAAIW,IAAA,GAAehB,IAAA,CAAKU,MAAM,CAACE,GAAG,IAAI;IACtC,IAAIZ,IAAA,CAAKU,MAAM,CAACO,QAAQ,KAAK,YAAY;MACvC,IAAInB,iBAAA,EAAmB;QACrBkB,IAAA,GAAO,MAAMlB,iBAAA,CAAkB;UAAEoB,QAAA,EAAUlB,IAAA;UAAMe;QAAS;MAC5D,OAAO;QACLI,OAAA,CAAQC,KAAK,CACX;QAEFJ,IAAA,GAAO,KAAI;MACb;IACF;IAEA;IACA,MAAMV,cAAA,GAAiBV,UAAA,CAAW,UAC/BW,MAAM,CAACC,IAAA,CAAKC,SAAS,CAACT,IAAA,CAAKU,MAAM,IAAI,CAAC,IACtCC,MAAM,CAAC;IAEV,OAAO,KAAKT,gBAAA,sBAAsCI,cAAA,oCAAkDU,IAAA,IAAQhB,IAAA,CAAKU,MAAM,CAACG,MAAM,GAAG,+CAA+C;UAC1KV,QAAA;WACC;EACT;AACF","ignoreList":[]}