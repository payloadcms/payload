{"version":3,"file":"rscEntry.js","names":["getTranslation","renderField","React","RichTextField","buildInitialState","initLexicalFeatures","RscEntryLexicalField","args","field","path","clientField","name","schemaPath","disabled","readOnly","admin","Error","clientFeatures","featureClientImportMap","featureClientSchemaMap","clientFieldSchemaMap","fieldSchemaMap","i18n","payload","sanitizedEditorConfig","initialLexicalFormState","siblingData","root","children","length","context","id","collectionSlug","documentData","data","lexicalFieldSchemaPath","operation","permissions","preferences","renderFieldFn","req","nodeData","placeholderFromArgs","placeholder","undefined","hideGutter","hideInsertParagraphAtEnd","hideAddBlockButton","hideDraggableBlockElement","props","forceRender","lexicalEditorConfig","lexical","renderedBlocks","Object","keys","key","_jsx"],"sources":["../../src/field/rscEntry.tsx"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\nimport type {\n  ClientComponentProps,\n  FieldPaths,\n  RichTextFieldClient,\n  RichTextField as RichTextFieldType,\n  ServerComponentProps,\n} from 'payload'\n\nimport { getTranslation } from '@payloadcms/translations'\nimport { renderField } from '@payloadcms/ui/forms/renderField'\nimport React from 'react'\n\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\nimport type {\n  LexicalEditorProps,\n  LexicalFieldAdminClientProps,\n  LexicalRichTextFieldProps,\n} from '../types.js'\n\n// eslint-disable-next-line payload/no-imports-from-exports-dir\nimport { RichTextField } from '../exports/client/index.js'\nimport { buildInitialState } from '../utilities/buildInitialState.js'\nimport { initLexicalFeatures } from '../utilities/initLexicalFeatures.js'\n\nexport const RscEntryLexicalField: React.FC<\n  {\n    sanitizedEditorConfig: SanitizedServerEditorConfig\n  } & ClientComponentProps &\n    Pick<FieldPaths, 'path'> &\n    Pick<LexicalEditorProps, 'admin'> &\n    ServerComponentProps\n> = async (args) => {\n  const field: RichTextFieldType = args.field as RichTextFieldType\n  const path = args.path ?? (args.clientField as RichTextFieldClient).name\n  const schemaPath = args.schemaPath ?? path\n\n  const disabled = args?.readOnly || field?.admin?.readOnly\n\n  if (!(args?.clientField as RichTextFieldClient)?.name) {\n    throw new Error('Initialized lexical RSC field without a field name')\n  }\n\n  const { clientFeatures, featureClientImportMap, featureClientSchemaMap } = initLexicalFeatures({\n    clientFieldSchemaMap: args.clientFieldSchemaMap,\n    fieldSchemaMap: args.fieldSchemaMap,\n    i18n: args.i18n,\n    path,\n    payload: args.payload,\n    sanitizedEditorConfig: args.sanitizedEditorConfig,\n    schemaPath,\n  })\n\n  let initialLexicalFormState = {}\n  if (args.siblingData?.[field.name]?.root?.children?.length) {\n    initialLexicalFormState = await buildInitialState({\n      context: {\n        id: args.id,\n        clientFieldSchemaMap: args.clientFieldSchemaMap,\n        collectionSlug: args.collectionSlug,\n        disabled,\n        documentData: args.data,\n        field,\n        fieldSchemaMap: args.fieldSchemaMap,\n        lexicalFieldSchemaPath: schemaPath,\n        operation: args.operation,\n        permissions: args.permissions,\n        preferences: args.preferences,\n        renderFieldFn: renderField,\n        req: args.req,\n      },\n      nodeData: args.siblingData?.[field.name]?.root?.children as SerializedLexicalNode[],\n    })\n  }\n\n  const placeholderFromArgs = args.admin?.placeholder\n  const placeholder = placeholderFromArgs\n    ? getTranslation(placeholderFromArgs, args.i18n)\n    : undefined\n\n  const admin: LexicalFieldAdminClientProps = {}\n  if (placeholder) {\n    admin.placeholder = placeholder\n  }\n  if (args.admin?.hideGutter) {\n    admin.hideGutter = true\n  }\n  if (args.admin?.hideInsertParagraphAtEnd) {\n    admin.hideInsertParagraphAtEnd = true\n  }\n  if (args.admin?.hideAddBlockButton) {\n    admin.hideAddBlockButton = true\n  }\n  if (args.admin?.hideDraggableBlockElement) {\n    admin.hideDraggableBlockElement = true\n  }\n\n  const props: LexicalRichTextFieldProps = {\n    clientFeatures,\n    featureClientSchemaMap, // TODO: Does client need this? Why cant this just live in the server\n    field: args.clientField as RichTextFieldClient,\n    forceRender: args.forceRender,\n    initialLexicalFormState,\n    lexicalEditorConfig: args.sanitizedEditorConfig.lexical,\n    path,\n    permissions: args.permissions,\n    readOnly: args.readOnly,\n    renderedBlocks: args.renderedBlocks,\n    schemaPath,\n  }\n  if (Object.keys(admin).length) {\n    props.admin = admin\n  }\n  if (Object.keys(featureClientImportMap).length) {\n    props.featureClientImportMap = featureClientImportMap\n  }\n\n  for (const key in props) {\n    if (props[key as keyof LexicalRichTextFieldProps] === undefined) {\n      delete props[key as keyof LexicalRichTextFieldProps]\n    }\n  }\n\n  return <RichTextField {...props} />\n}\n"],"mappings":"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","ignoreList":[]}