{"version":3,"sources":["../../src/utilities/addFilterOptionsToFields.ts"],"sourcesContent":["import type { Block, Config, Field, RelationshipField, SanitizedConfig } from 'payload'\n\nimport type { MultiTenantPluginConfig } from '../types.js'\n\nimport { defaults } from '../defaults.js'\nimport { filterDocumentsByTenants } from '../filters/filterDocumentsByTenants.js'\n\ntype AddFilterOptionsToFieldsArgs<ConfigType = unknown> = {\n  blockReferencesWithFilters: string[]\n  config: Config | SanitizedConfig\n  fields: Field[]\n  tenantEnabledCollectionSlugs: string[]\n  tenantEnabledGlobalSlugs: string[]\n  tenantFieldName: string\n  tenantsArrayFieldName: string\n  tenantsArrayTenantFieldName: string\n  tenantsCollectionSlug: string\n  userHasAccessToAllTenants: Required<\n    MultiTenantPluginConfig<ConfigType>\n  >['userHasAccessToAllTenants']\n}\n\nexport function addFilterOptionsToFields<ConfigType = unknown>({\n  blockReferencesWithFilters,\n  config,\n  fields,\n  tenantEnabledCollectionSlugs,\n  tenantEnabledGlobalSlugs,\n  tenantFieldName,\n  tenantsArrayFieldName = defaults.tenantsArrayFieldName,\n  tenantsArrayTenantFieldName = defaults.tenantsArrayTenantFieldName,\n  tenantsCollectionSlug,\n  userHasAccessToAllTenants,\n}: AddFilterOptionsToFieldsArgs<ConfigType>): Field[] {\n  const newFields = []\n  for (const field of fields) {\n    let newField: Field = { ...field }\n    if (newField.type === 'relationship') {\n      let hasTenantRelationsips = false\n      /**\n       * Adjusts relationship fields to filter by tenant\n       * and ensures relationTo cannot be a tenant global collection\n       */\n      if (typeof newField.relationTo === 'string') {\n        if (tenantEnabledGlobalSlugs.includes(newField.relationTo)) {\n          throw new Error(\n            `The collection ${newField.relationTo} is a global collection and cannot be related to a tenant enabled collection.`,\n          )\n        }\n        if (tenantEnabledCollectionSlugs.includes(newField.relationTo)) {\n          hasTenantRelationsips = true\n        }\n      } else {\n        for (const relationTo of newField.relationTo) {\n          if (tenantEnabledGlobalSlugs.includes(relationTo)) {\n            throw new Error(\n              `The collection ${relationTo} is a global collection and cannot be related to a tenant enabled collection.`,\n            )\n          }\n          if (tenantEnabledCollectionSlugs.includes(relationTo)) {\n            hasTenantRelationsips = true\n          }\n        }\n      }\n\n      if (hasTenantRelationsips) {\n        newField = addRelationshipFilter({\n          field: newField as RelationshipField,\n          tenantEnabledCollectionSlugs,\n          tenantFieldName,\n          tenantsArrayFieldName,\n          tenantsArrayTenantFieldName,\n          tenantsCollectionSlug,\n          userHasAccessToAllTenants,\n        })\n      }\n    }\n\n    if (\n      newField.type === 'row' ||\n      newField.type === 'array' ||\n      newField.type === 'collapsible' ||\n      newField.type === 'group'\n    ) {\n      newField.fields = addFilterOptionsToFields({\n        blockReferencesWithFilters,\n        config,\n        fields: newField.fields,\n        tenantEnabledCollectionSlugs,\n        tenantEnabledGlobalSlugs,\n        tenantFieldName,\n        tenantsArrayFieldName,\n        tenantsArrayTenantFieldName,\n        tenantsCollectionSlug,\n        userHasAccessToAllTenants,\n      })\n    }\n\n    if (newField.type === 'blocks') {\n      const newBlocks: Block[] = []\n      ;(newField.blockReferences ?? newField.blocks).forEach((_block) => {\n        let block: Block | undefined\n        let isReference = false\n\n        if (typeof _block === 'string') {\n          if (blockReferencesWithFilters.includes(_block)) {\n            return\n          }\n          isReference = true\n          block = config?.blocks?.find((b) => b.slug === _block)\n          blockReferencesWithFilters.push(_block)\n        } else {\n          // Create a shallow copy to avoid mutating the original block reference\n          block = { ..._block }\n        }\n\n        if (block?.fields) {\n          block.fields = addFilterOptionsToFields({\n            blockReferencesWithFilters,\n            config,\n            fields: block.fields,\n            tenantEnabledCollectionSlugs,\n            tenantEnabledGlobalSlugs,\n            tenantFieldName,\n            tenantsArrayFieldName,\n            tenantsArrayTenantFieldName,\n            tenantsCollectionSlug,\n            userHasAccessToAllTenants,\n          })\n        }\n\n        if (block && !isReference) {\n          newBlocks.push(block)\n        }\n      })\n      newField.blocks = newBlocks\n    }\n\n    if (newField.type === 'tabs') {\n      newField.tabs = newField.tabs.map((tab) => {\n        const newTab = { ...tab }\n        newTab.fields = addFilterOptionsToFields({\n          blockReferencesWithFilters,\n          config,\n          fields: tab.fields,\n          tenantEnabledCollectionSlugs,\n          tenantEnabledGlobalSlugs,\n          tenantFieldName,\n          tenantsArrayFieldName,\n          tenantsArrayTenantFieldName,\n          tenantsCollectionSlug,\n          userHasAccessToAllTenants,\n        })\n        return newTab\n      })\n    }\n\n    newFields.push(newField)\n  }\n\n  return newFields\n}\n\ntype AddFilterArgs<ConfigType = unknown> = {\n  field: RelationshipField\n  tenantEnabledCollectionSlugs: string[]\n  tenantFieldName: string\n  tenantsArrayFieldName: string\n  tenantsArrayTenantFieldName: string\n  tenantsCollectionSlug: string\n  userHasAccessToAllTenants: Required<\n    MultiTenantPluginConfig<ConfigType>\n  >['userHasAccessToAllTenants']\n}\nfunction addRelationshipFilter<ConfigType = unknown>({\n  field,\n  tenantEnabledCollectionSlugs,\n  tenantFieldName,\n  tenantsArrayFieldName = defaults.tenantsArrayFieldName,\n  tenantsArrayTenantFieldName = defaults.tenantsArrayTenantFieldName,\n  tenantsCollectionSlug,\n  userHasAccessToAllTenants,\n}: AddFilterArgs<ConfigType>): Field {\n  // User specified filter\n  const originalFilter = field.filterOptions\n  field.filterOptions = async (args) => {\n    const originalFilterResult =\n      typeof originalFilter === 'function' ? await originalFilter(args) : (originalFilter ?? true)\n\n    // If the relationTo is not a tenant enabled collection, return early\n    if (args.relationTo && !tenantEnabledCollectionSlugs.includes(args.relationTo)) {\n      return originalFilterResult\n    }\n\n    // If the original filtr returns false, return early\n    if (originalFilterResult === false) {\n      return false\n    }\n\n    // Custom tenant filter\n    const tenantFilterResults = filterDocumentsByTenants({\n      docTenantID: args.data?.[tenantFieldName],\n      filterFieldName: tenantFieldName,\n      req: args.req,\n      tenantsArrayFieldName,\n      tenantsArrayTenantFieldName,\n      tenantsCollectionSlug,\n      userHasAccessToAllTenants,\n    })\n\n    // If the tenant filter returns null, meaning no tenant filter, just use the original filter\n    if (tenantFilterResults === null) {\n      return originalFilterResult\n    }\n\n    // If the original filter returns true, just use the tenant filter\n    if (originalFilterResult === true) {\n      return tenantFilterResults\n    }\n\n    return {\n      and: [originalFilterResult, tenantFilterResults],\n    }\n  }\n\n  return field\n}\n"],"names":["defaults","filterDocumentsByTenants","addFilterOptionsToFields","blockReferencesWithFilters","config","fields","tenantEnabledCollectionSlugs","tenantEnabledGlobalSlugs","tenantFieldName","tenantsArrayFieldName","tenantsArrayTenantFieldName","tenantsCollectionSlug","userHasAccessToAllTenants","newFields","field","newField","type","hasTenantRelationsips","relationTo","includes","Error","addRelationshipFilter","newBlocks","blockReferences","blocks","forEach","_block","block","isReference","find","b","slug","push","tabs","map","tab","newTab","originalFilter","filterOptions","args","originalFilterResult","tenantFilterResults","docTenantID","data","filterFieldName","req","and"],"mappings":"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"}