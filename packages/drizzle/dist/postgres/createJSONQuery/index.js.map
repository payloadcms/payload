{"version":3,"sources":["../../../src/postgres/createJSONQuery/index.ts"],"sourcesContent":["import type { CreateJSONQueryArgs } from '../../types.js'\n\nconst operatorMap: Record<string, string> = {\n  contains: '~',\n  equals: '==',\n  in: 'in',\n  like: 'like_regex',\n  not_equals: '!=',\n  not_in: 'in',\n  not_like: '!like_regex',\n}\n\nconst sanitizeValue = (value: unknown, operator?: string) => {\n  if (typeof value === 'string') {\n    // ignore casing with like or not_like\n    return `\"${['like', 'not_like'].includes(operator) ? '(?i)' : ''}${value}\"`\n  }\n\n  return value as string\n}\n\nexport const createJSONQuery = ({ column, operator, pathSegments, value }: CreateJSONQueryArgs) => {\n  const columnName = typeof column === 'object' ? column.name : column\n  const jsonPaths = pathSegments\n    .slice(1)\n    .map((key) => {\n      return `${key}[*]`\n    })\n    .join('.')\n\n  const fullPath = pathSegments.length === 1 ? '$[*]' : `$.${jsonPaths}`\n\n  let sql = ''\n\n  if (['in', 'not_in'].includes(operator) && Array.isArray(value)) {\n    sql = '('\n    value.forEach((item, i) => {\n      sql = `${sql}${createJSONQuery({ column, operator: operator === 'in' ? 'equals' : 'not_equals', pathSegments, value: item })}${i === value.length - 1 ? '' : ` ${operator === 'in' ? 'OR' : 'AND'} `}`\n    })\n    sql = `${sql})`\n  } else if (operator === 'exists') {\n    sql = `${value === false ? 'NOT ' : ''}jsonb_path_exists(${columnName}, '${fullPath}')`\n  } else if (['not_like'].includes(operator)) {\n    const mappedOperator = operatorMap[operator]\n\n    sql = `NOT jsonb_path_exists(${columnName}, '${fullPath} ? (@ ${mappedOperator.substring(1)} ${sanitizeValue(value, operator)})')`\n  } else {\n    sql = `jsonb_path_exists(${columnName}, '${fullPath} ? (@ ${operatorMap[operator]} ${sanitizeValue(value, operator)})')`\n  }\n\n  return sql\n}\n"],"names":["operatorMap","contains","equals","in","like","not_equals","not_in","not_like","sanitizeValue","value","operator","includes","createJSONQuery","column","pathSegments","columnName","name","jsonPaths","slice","map","key","join","fullPath","length","sql","Array","isArray","forEach","item","i","mappedOperator","substring"],"mappings":"AAEA,MAAMA,cAAsC;IAC1CC,UAAU;IACVC,QAAQ;IACRC,IAAI;IACJC,MAAM;IACNC,YAAY;IACZC,QAAQ;IACRC,UAAU;AACZ;AAEA,MAAMC,gBAAgB,CAACC,OAAgBC;IACrC,IAAI,OAAOD,UAAU,UAAU;QAC7B,sCAAsC;QACtC,OAAO,CAAC,CAAC,EAAE;YAAC;YAAQ;SAAW,CAACE,QAAQ,CAACD,YAAY,SAAS,KAAKD,MAAM,CAAC,CAAC;IAC7E;IAEA,OAAOA;AACT;AAEA,OAAO,MAAMG,kBAAkB,CAAC,EAAEC,MAAM,EAAEH,QAAQ,EAAEI,YAAY,EAAEL,KAAK,EAAuB;IAC5F,MAAMM,aAAa,OAAOF,WAAW,WAAWA,OAAOG,IAAI,GAAGH;IAC9D,MAAMI,YAAYH,aACfI,KAAK,CAAC,GACNC,GAAG,CAAC,CAACC;QACJ,OAAO,GAAGA,IAAI,GAAG,CAAC;IACpB,GACCC,IAAI,CAAC;IAER,MAAMC,WAAWR,aAAaS,MAAM,KAAK,IAAI,SAAS,CAAC,EAAE,EAAEN,WAAW;IAEtE,IAAIO,MAAM;IAEV,IAAI;QAAC;QAAM;KAAS,CAACb,QAAQ,CAACD,aAAae,MAAMC,OAAO,CAACjB,QAAQ;QAC/De,MAAM;QACNf,MAAMkB,OAAO,CAAC,CAACC,MAAMC;YACnBL,MAAM,GAAGA,MAAMZ,gBAAgB;gBAAEC;gBAAQH,UAAUA,aAAa,OAAO,WAAW;gBAAcI;gBAAcL,OAAOmB;YAAK,KAAKC,MAAMpB,MAAMc,MAAM,GAAG,IAAI,KAAK,CAAC,CAAC,EAAEb,aAAa,OAAO,OAAO,MAAM,CAAC,CAAC,EAAE;QACxM;QACAc,MAAM,GAAGA,IAAI,CAAC,CAAC;IACjB,OAAO,IAAId,aAAa,UAAU;QAChCc,MAAM,GAAGf,UAAU,QAAQ,SAAS,GAAG,kBAAkB,EAAEM,WAAW,GAAG,EAAEO,SAAS,EAAE,CAAC;IACzF,OAAO,IAAI;QAAC;KAAW,CAACX,QAAQ,CAACD,WAAW;QAC1C,MAAMoB,iBAAiB9B,WAAW,CAACU,SAAS;QAE5Cc,MAAM,CAAC,sBAAsB,EAAET,WAAW,GAAG,EAAEO,SAAS,MAAM,EAAEQ,eAAeC,SAAS,CAAC,GAAG,CAAC,EAAEvB,cAAcC,OAAOC,UAAU,GAAG,CAAC;IACpI,OAAO;QACLc,MAAM,CAAC,kBAAkB,EAAET,WAAW,GAAG,EAAEO,SAAS,MAAM,EAAEtB,WAAW,CAACU,SAAS,CAAC,CAAC,EAAEF,cAAcC,OAAOC,UAAU,GAAG,CAAC;IAC1H;IAEA,OAAOc;AACT,EAAC"}