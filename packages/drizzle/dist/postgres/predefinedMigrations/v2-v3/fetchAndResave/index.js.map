{"version":3,"sources":["../../../../../src/postgres/predefinedMigrations/v2-v3/fetchAndResave/index.ts"],"sourcesContent":["import type { FlattenedField, Payload, PayloadRequest } from 'payload'\n\nimport type { BasePostgresAdapter, PostgresDB } from '../../../types.js'\nimport type { DocsToResave } from '../types.js'\n\nimport { upsertRow } from '../../../../upsertRow/index.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: BasePostgresAdapter\n  collectionSlug?: string\n  db: PostgresDB\n  debug: boolean\n  docsToResave: DocsToResave\n  fields: FlattenedField[]\n  globalSlug?: string\n  isVersions: boolean\n  payload: Payload\n  req?: Partial<PayloadRequest>\n  tableName: string\n}\n\nexport const fetchAndResave = async ({\n  adapter,\n  collectionSlug,\n  db,\n  debug,\n  docsToResave,\n  fields,\n  globalSlug,\n  isVersions,\n  payload,\n  req,\n  tableName,\n}: Args) => {\n  for (const [id, rows] of Object.entries(docsToResave)) {\n    if (collectionSlug) {\n      const collectionConfig = payload.collections[collectionSlug].config\n\n      if (collectionConfig) {\n        if (isVersions) {\n          const doc = await payload.findVersionByID({\n            id,\n            collection: collectionSlug,\n            depth: 0,\n            fallbackLocale: null,\n            locale: 'all',\n            req,\n            showHiddenFields: true,\n          })\n\n          if (debug) {\n            payload.logger.info(\n              `The collection \"${collectionConfig.slug}\" version with ID ${id} will be migrated`,\n            )\n          }\n\n          traverseFields({\n            doc,\n            fields,\n            path: '',\n            rows,\n          })\n\n          try {\n            await upsertRow({\n              id: doc.id,\n              adapter,\n              collectionSlug,\n              data: doc,\n              db,\n              fields,\n              ignoreResult: true,\n              operation: 'update',\n              req,\n              tableName,\n            })\n          } catch (err) {\n            payload.logger.error(\n              `\"${collectionConfig.slug}\" version with ID ${doc.id} FAILED TO MIGRATE`,\n            )\n\n            throw err\n          }\n\n          if (debug) {\n            payload.logger.info(\n              `\"${collectionConfig.slug}\" version with ID ${doc.id} migrated successfully!`,\n            )\n          }\n        } else {\n          const doc = await payload.findByID({\n            id,\n            collection: collectionSlug,\n            depth: 0,\n            fallbackLocale: null,\n            locale: 'all',\n            req,\n            showHiddenFields: true,\n          })\n\n          if (debug) {\n            payload.logger.info(\n              `The collection \"${collectionConfig.slug}\" with ID ${doc.id} will be migrated`,\n            )\n          }\n\n          traverseFields({\n            doc,\n            fields,\n            path: '',\n            rows,\n          })\n\n          try {\n            await upsertRow({\n              id: doc.id,\n              adapter,\n              collectionSlug,\n              data: doc,\n              db,\n              fields,\n              ignoreResult: true,\n              operation: 'update',\n              req,\n              tableName,\n            })\n          } catch (err) {\n            payload.logger.error(\n              `The collection \"${collectionConfig.slug}\" with ID ${doc.id} has FAILED TO MIGRATE`,\n            )\n\n            throw err\n          }\n\n          if (debug) {\n            payload.logger.info(\n              `The collection \"${collectionConfig.slug}\" with ID ${doc.id} has migrated successfully!`,\n            )\n          }\n        }\n      }\n    }\n\n    if (globalSlug) {\n      const globalConfig = payload.config.globals?.find((global) => global.slug === globalSlug)\n\n      if (globalConfig) {\n        if (isVersions) {\n          const { docs } = await payload.findGlobalVersions({\n            slug: globalSlug,\n            depth: 0,\n            fallbackLocale: null,\n            limit: 0,\n            locale: 'all',\n            req,\n            showHiddenFields: true,\n          })\n\n          if (debug) {\n            payload.logger.info(`${docs.length} global \"${globalSlug}\" versions will be migrated`)\n          }\n\n          for (const doc of docs) {\n            traverseFields({\n              doc,\n              fields,\n              path: '',\n              rows,\n            })\n\n            try {\n              await upsertRow({\n                id: doc.id,\n                adapter,\n                data: doc,\n                db,\n                fields,\n                globalSlug,\n                ignoreResult: true,\n                operation: 'update',\n                req,\n                tableName,\n              })\n            } catch (err) {\n              payload.logger.error(`\"${globalSlug}\" version with ID ${doc.id} FAILED TO MIGRATE`)\n\n              throw err\n            }\n\n            if (debug) {\n              payload.logger.info(\n                `\"${globalSlug}\" version with ID ${doc.id} migrated successfully!`,\n              )\n            }\n          }\n        } else {\n          const doc = await payload.findGlobal({\n            slug: globalSlug,\n            depth: 0,\n            fallbackLocale: null,\n            locale: 'all',\n            req,\n            showHiddenFields: true,\n          })\n\n          traverseFields({\n            doc,\n            fields,\n            path: '',\n            rows,\n          })\n\n          try {\n            await upsertRow({\n              adapter,\n              data: doc,\n              db,\n              fields,\n              globalSlug,\n              ignoreResult: true,\n              operation: 'update',\n              req,\n              tableName,\n            })\n          } catch (err) {\n            payload.logger.error(`The global \"${globalSlug}\" has FAILED TO MIGRATE`)\n\n            throw err\n          }\n\n          if (debug) {\n            payload.logger.info(`The global \"${globalSlug}\" has migrated successfully!`)\n          }\n        }\n      }\n    }\n  }\n}\n"],"names":["upsertRow","traverseFields","fetchAndResave","adapter","collectionSlug","db","debug","docsToResave","fields","globalSlug","isVersions","payload","req","tableName","id","rows","Object","entries","collectionConfig","collections","config","doc","findVersionByID","collection","depth","fallbackLocale","locale","showHiddenFields","logger","info","slug","path","data","ignoreResult","operation","err","error","findByID","globalConfig","globals","find","global","docs","findGlobalVersions","limit","length","findGlobal"],"mappings":"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"}