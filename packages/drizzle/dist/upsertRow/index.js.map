{"version":3,"sources":["../../src/upsertRow/index.ts"],"sourcesContent":["import type { LibSQLDatabase } from 'drizzle-orm/libsql'\nimport type { SelectedFields } from 'drizzle-orm/sqlite-core'\nimport type { TypeWithID } from 'payload'\n\nimport { and, desc, eq, isNull, or } from 'drizzle-orm'\n\nimport type { BlockRowToInsert } from '../transform/write/types.js'\nimport type { Args } from './types.js'\n\ntype RelationshipRow = {\n  [key: string]: number | string | undefined // For relationship ID columns like categoriesID, moviesID, etc.\n  id?: number | string\n  locale?: string\n  order: number\n  parent: number | string // Drizzle table uses 'parent' key\n  path: string\n}\n\nimport { buildFindManyArgs } from '../find/buildFindManyArgs.js'\nimport { transform } from '../transform/read/index.js'\nimport { transformForWrite } from '../transform/write/index.js'\nimport { deleteExistingArrayRows } from './deleteExistingArrayRows.js'\nimport { deleteExistingRowsByPath } from './deleteExistingRowsByPath.js'\nimport { handleUpsertError } from './handleUpsertError.js'\nimport { insertArrays } from './insertArrays.js'\nimport { shouldUseOptimizedUpsertRow } from './shouldUseOptimizedUpsertRow.js'\n\n/**\n * If `id` is provided, it will update the row with that ID.\n * If `where` is provided, it will update the row that matches the `where`\n * If neither `id` nor `where` is provided, it will create a new row.\n *\n * adapter function replaces the entire row and does not support partial updates.\n */\nexport const upsertRow = async <T extends Record<string, unknown> | TypeWithID>({\n  id,\n  adapter,\n  collectionSlug,\n  data,\n  db,\n  fields,\n  globalSlug,\n  ignoreResult,\n  // TODO:\n  // When we support joins for write operations (create/update) - pass collectionSlug to the buildFindManyArgs\n  // Make a new argument in upsertRow.ts and pass the slug from every operation.\n  joinQuery: _joinQuery,\n  operation,\n  path = '',\n  req,\n  select,\n  tableName,\n  upsertTarget,\n  where,\n}: Args): Promise<T> => {\n  if (operation === 'create' && !data.createdAt) {\n    data.createdAt = new Date().toISOString()\n  }\n\n  let insertedRow: Record<string, unknown> = { id }\n  if (id && shouldUseOptimizedUpsertRow({ data, fields })) {\n    try {\n      const transformedForWrite = transformForWrite({\n        adapter,\n        data,\n        enableAtomicWrites: true,\n        fields,\n        tableName,\n      })\n      const { row } = transformedForWrite\n      const { arraysToPush } = transformedForWrite\n\n      const drizzle = db as LibSQLDatabase\n\n      // First, handle $push arrays\n\n      if (arraysToPush && Object.keys(arraysToPush)?.length) {\n        await insertArrays({\n          adapter,\n          arrays: [arraysToPush],\n          db,\n          parentRows: [insertedRow],\n          uuidMap: {},\n        })\n      }\n\n      // If row.updatedAt is not set, delete it to avoid triggering hasDataToUpdate. `updatedAt` may be explicitly set to null to\n      // disable triggering hasDataToUpdate.\n      if (typeof row.updatedAt === 'undefined' || row.updatedAt === null) {\n        delete row.updatedAt\n      }\n\n      const hasDataToUpdate = row && Object.keys(row)?.length\n\n      // Then, handle regular row update\n      if (ignoreResult) {\n        if (hasDataToUpdate) {\n          // Only update row if there is something to update.\n          // Example: if the data only consists of a single $push, calling insertArrays is enough - we don't need to update the row.\n          await drizzle\n            .update(adapter.tables[tableName])\n            .set(row)\n            .where(eq(adapter.tables[tableName].id, id))\n        }\n        return ignoreResult === 'idOnly' ? ({ id } as T) : null\n      }\n\n      const findManyArgs = buildFindManyArgs({\n        adapter,\n        depth: 0,\n        fields,\n        joinQuery: false,\n        select,\n        tableName,\n      })\n\n      const findManyKeysLength = Object.keys(findManyArgs).length\n      const hasOnlyColumns = Object.keys(findManyArgs.columns || {}).length > 0\n\n      if (!hasDataToUpdate) {\n        // Nothing to update => just fetch current row and return\n        findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n        const doc = await db.query[tableName].findFirst(findManyArgs)\n\n        return transform<T>({\n          adapter,\n          config: adapter.payload.config,\n          data: doc,\n          fields,\n          joinQuery: false,\n          tableName,\n        })\n      }\n\n      if (findManyKeysLength === 0 || hasOnlyColumns) {\n        // Optimization - No need for joins => can simply use returning(). This is optimal for very simple collections\n        // without complex fields that live in separate tables like blocks, arrays, relationships, etc.\n\n        const selectedFields: SelectedFields = {}\n        if (hasOnlyColumns) {\n          for (const [column, enabled] of Object.entries(findManyArgs.columns)) {\n            if (enabled) {\n              selectedFields[column] = adapter.tables[tableName][column]\n            }\n          }\n        }\n\n        const docs = await drizzle\n          .update(adapter.tables[tableName])\n          .set(row)\n          .where(eq(adapter.tables[tableName].id, id))\n          .returning(Object.keys(selectedFields).length ? selectedFields : undefined)\n\n        return transform<T>({\n          adapter,\n          config: adapter.payload.config,\n          data: docs[0],\n          fields,\n          joinQuery: false,\n          tableName,\n        })\n      }\n\n      // DB Update that needs the result, potentially with joins => need to update first, then find. returning() does not work with joins.\n\n      await drizzle\n        .update(adapter.tables[tableName])\n        .set(row)\n        .where(eq(adapter.tables[tableName].id, id))\n\n      findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n      const doc = await db.query[tableName].findFirst(findManyArgs)\n\n      return transform<T>({\n        adapter,\n        config: adapter.payload.config,\n        data: doc,\n        fields,\n        joinQuery: false,\n        tableName,\n      })\n    } catch (error) {\n      handleUpsertError({ id, adapter, collectionSlug, error, globalSlug, req, tableName })\n    }\n  }\n  // Split out the incoming data into the corresponding:\n  // base row, locales, relationships, blocks, and arrays\n  const rowToInsert = transformForWrite({\n    adapter,\n    data,\n    enableAtomicWrites: false,\n    fields,\n    path,\n    tableName,\n  })\n\n  // First, we insert the main row\n  try {\n    if (operation === 'update') {\n      const target = upsertTarget || adapter.tables[tableName].id\n\n      // Check if we only have relationship operations and no main row data to update\n      // Exclude timestamp-only updates when we only have relationship operations\n      const rowKeys = Object.keys(rowToInsert.row)\n      const hasMainRowData =\n        rowKeys.length > 0 && !rowKeys.every((key) => key === 'updatedAt' || key === 'createdAt')\n\n      if (hasMainRowData) {\n        if (id) {\n          rowToInsert.row.id = id\n          ;[insertedRow] = await adapter.insert({\n            db,\n            onConflictDoUpdate: { set: rowToInsert.row, target },\n            tableName,\n            values: rowToInsert.row,\n          })\n        } else {\n          ;[insertedRow] = await adapter.insert({\n            db,\n            onConflictDoUpdate: { set: rowToInsert.row, target, where },\n            tableName,\n            values: rowToInsert.row,\n          })\n        }\n      } else {\n        // No main row data to update, just use the existing ID\n        insertedRow = { id }\n      }\n    } else {\n      if (adapter.allowIDOnCreate && data.id) {\n        rowToInsert.row.id = data.id\n      }\n      ;[insertedRow] = await adapter.insert({\n        db,\n        tableName,\n        values: rowToInsert.row,\n      })\n    }\n\n    const localesToInsert: Record<string, unknown>[] = []\n    const relationsToInsert: Record<string, unknown>[] = []\n    const textsToInsert: Record<string, unknown>[] = []\n    const numbersToInsert: Record<string, unknown>[] = []\n    const blocksToInsert: { [blockType: string]: BlockRowToInsert[] } = {}\n    const selectsToInsert: { [selectTableName: string]: Record<string, unknown>[] } = {}\n\n    // If there are locale rows with data, add the parent and locale to each\n    if (Object.keys(rowToInsert.locales).length > 0) {\n      Object.entries(rowToInsert.locales).forEach(([locale, localeRow]) => {\n        localeRow._parentID = insertedRow.id\n        localeRow._locale = locale\n        localesToInsert.push(localeRow)\n      })\n    }\n\n    // If there are relationships, add parent to each\n    if (rowToInsert.relationships.length > 0) {\n      rowToInsert.relationships.forEach((relation) => {\n        relation.parent = insertedRow.id\n        relationsToInsert.push(relation)\n      })\n    }\n\n    // If there are texts, add parent to each\n    if (rowToInsert.texts.length > 0) {\n      rowToInsert.texts.forEach((textRow) => {\n        textRow.parent = insertedRow.id\n        textsToInsert.push(textRow)\n      })\n    }\n\n    // If there are numbers, add parent to each\n    if (rowToInsert.numbers.length > 0) {\n      rowToInsert.numbers.forEach((numberRow) => {\n        numberRow.parent = insertedRow.id\n        numbersToInsert.push(numberRow)\n      })\n    }\n\n    // If there are selects, add parent to each, and then\n    // store by table name and rows\n    if (Object.keys(rowToInsert.selects).length > 0) {\n      Object.entries(rowToInsert.selects).forEach(([selectTableName, selectRows]) => {\n        selectsToInsert[selectTableName] = []\n\n        selectRows.forEach((row) => {\n          if (typeof row.parent === 'undefined') {\n            row.parent = insertedRow.id\n          }\n\n          selectsToInsert[selectTableName].push(row)\n        })\n      })\n    }\n\n    // If there are blocks, add parent to each, and then\n    // store by table name and rows\n    Object.keys(rowToInsert.blocks).forEach((tableName) => {\n      rowToInsert.blocks[tableName].forEach((blockRow) => {\n        blockRow.row._parentID = insertedRow.id\n        if (!blocksToInsert[tableName]) {\n          blocksToInsert[tableName] = []\n        }\n        if (blockRow.row.uuid) {\n          delete blockRow.row.uuid\n        }\n        blocksToInsert[tableName].push(blockRow)\n      })\n    })\n\n    // //////////////////////////////////\n    // INSERT LOCALES\n    // //////////////////////////////////\n\n    if (localesToInsert.length > 0) {\n      const localeTableName = `${tableName}${adapter.localesSuffix}`\n      const localeTable = adapter.tables[`${tableName}${adapter.localesSuffix}`]\n\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: localeTableName,\n          where: eq(localeTable._parentID, insertedRow.id),\n        })\n      }\n\n      await adapter.insert({\n        db,\n        tableName: localeTableName,\n        values: localesToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT RELATIONSHIPS\n    // //////////////////////////////////\n\n    const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n    if (operation === 'update') {\n      // Filter out specific item deletions (those with itemToRemove) from general path deletions\n      const generalRelationshipDeletes = rowToInsert.relationshipsToDelete.filter(\n        (rel) => !('itemToRemove' in rel),\n      )\n\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...relationsToInsert, ...generalRelationshipDeletes],\n        tableName: relationshipsTableName,\n      })\n    }\n\n    if (relationsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: relationshipsTableName,\n        values: relationsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // HANDLE RELATIONSHIP $push OPERATIONS\n    // //////////////////////////////////\n\n    if (rowToInsert.relationshipsToAppend.length > 0) {\n      // Prepare all relationships for batch insert (order will be set after max query)\n      const relationshipsToInsert = rowToInsert.relationshipsToAppend.map((rel) => {\n        const parentId = id || insertedRow.id\n        const row: Record<string, unknown> = {\n          parent: parentId as number | string, // Use 'parent' key for Drizzle table\n          path: rel.path,\n        }\n\n        // Only add locale if this relationship table has a locale column\n        const relationshipTable = adapter.rawTables[relationshipsTableName]\n        if (rel.locale && relationshipTable && relationshipTable.columns.locale) {\n          row.locale = rel.locale\n        }\n\n        if (rel.relationTo) {\n          // Use camelCase key for Drizzle table (e.g., categoriesID not categories_id)\n          row[`${rel.relationTo}ID`] = rel.value\n        }\n\n        return row\n      })\n\n      if (relationshipsToInsert.length > 0) {\n        // Check for potential duplicates\n        const relationshipTable = adapter.tables[relationshipsTableName]\n\n        if (relationshipTable) {\n          // Build conditions only if we have relationships to check\n          if (relationshipsToInsert.length === 0) {\n            return // No relationships to insert\n          }\n\n          const conditions = relationshipsToInsert.map((row: RelationshipRow) => {\n            const parts = [\n              eq(relationshipTable.parent, row.parent),\n              eq(relationshipTable.path, row.path),\n            ]\n\n            // Add locale condition\n            if (row.locale !== undefined && relationshipTable.locale) {\n              parts.push(eq(relationshipTable.locale, row.locale))\n            } else if (relationshipTable.locale) {\n              parts.push(isNull(relationshipTable.locale))\n            }\n\n            // Add all relationship ID matches using schema fields\n            for (const [key, value] of Object.entries(row)) {\n              if (key.endsWith('ID') && value != null) {\n                const column = relationshipTable[key]\n                if (column && typeof column === 'object') {\n                  parts.push(eq(column, value))\n                }\n              }\n            }\n\n            return and(...parts)\n          })\n\n          // Get both existing relationships AND max order in a single query\n          let existingRels: Record<string, unknown>[] = []\n          let maxOrder = 0\n\n          if (conditions.length > 0) {\n            // Query for existing relationships\n            existingRels = await (db as any)\n              .select()\n              .from(relationshipTable)\n              .where(or(...conditions))\n          }\n\n          // Get max order for this parent across all paths in a single query\n          const parentId = id || insertedRow.id\n          const maxOrderResult = await (db as any)\n            .select({ maxOrder: relationshipTable.order })\n            .from(relationshipTable)\n            .where(eq(relationshipTable.parent, parentId))\n            .orderBy(desc(relationshipTable.order))\n            .limit(1)\n\n          if (maxOrderResult.length > 0 && maxOrderResult[0].maxOrder) {\n            maxOrder = maxOrderResult[0].maxOrder\n          }\n\n          // Set order values for all relationships based on max order\n          relationshipsToInsert.forEach((row, index) => {\n            row.order = maxOrder + index + 1\n          })\n\n          // Filter out relationships that already exist\n          const relationshipsToActuallyInsert = relationshipsToInsert.filter((newRow) => {\n            return !existingRels.some((existingRow: Record<string, unknown>) => {\n              // Check if this relationship already exists\n              let matches = existingRow.parent === newRow.parent && existingRow.path === newRow.path\n\n              if (newRow.locale !== undefined) {\n                matches = matches && existingRow.locale === newRow.locale\n              }\n\n              // Check relationship value matches - convert to camelCase for comparison\n              for (const key of Object.keys(newRow)) {\n                if (key.endsWith('ID')) {\n                  // Now using camelCase keys\n                  matches = matches && existingRow[key] === newRow[key]\n                }\n              }\n\n              return matches\n            })\n          })\n\n          // Insert only non-duplicate relationships\n          if (relationshipsToActuallyInsert.length > 0) {\n            await adapter.insert({\n              db,\n              tableName: relationshipsTableName,\n              values: relationshipsToActuallyInsert,\n            })\n          }\n        }\n      }\n    }\n\n    // //////////////////////////////////\n    // HANDLE RELATIONSHIP $remove OPERATIONS\n    // //////////////////////////////////\n\n    if (rowToInsert.relationshipsToDelete.some((rel) => 'itemToRemove' in rel)) {\n      const relationshipTable = adapter.tables[relationshipsTableName]\n\n      if (relationshipTable) {\n        for (const relToDelete of rowToInsert.relationshipsToDelete) {\n          if ('itemToRemove' in relToDelete && relToDelete.itemToRemove) {\n            const item = relToDelete.itemToRemove\n            const parentId = (id || insertedRow.id) as number | string\n\n            const conditions = [\n              eq(relationshipTable.parent, parentId),\n              eq(relationshipTable.path, relToDelete.path),\n            ]\n\n            // Add locale condition if this relationship table has a locale column\n            if (adapter.rawTables[relationshipsTableName]?.columns.locale) {\n              if (relToDelete.locale) {\n                conditions.push(eq(relationshipTable.locale, relToDelete.locale))\n              } else {\n                conditions.push(isNull(relationshipTable.locale))\n              }\n            }\n\n            // Handle polymorphic vs simple relationships\n            if (typeof item === 'object' && 'relationTo' in item) {\n              // Polymorphic relationship - convert to camelCase key\n              const camelKey = `${item.relationTo}ID`\n              if (relationshipTable[camelKey]) {\n                conditions.push(eq(relationshipTable[camelKey], item.value))\n              }\n            } else if (relToDelete.relationTo) {\n              // Simple relationship - convert to camelCase key\n              const camelKey = `${relToDelete.relationTo}ID`\n              if (relationshipTable[camelKey]) {\n                conditions.push(eq(relationshipTable[camelKey], item))\n              }\n            }\n\n            // Execute DELETE using Drizzle query builder\n            await adapter.deleteWhere({\n              db,\n              tableName: relationshipsTableName,\n              where: and(...conditions),\n            })\n          }\n        }\n      }\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany TEXTS\n    // //////////////////////////////////\n\n    const textsTableName = `${tableName}_texts`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...textsToInsert, ...rowToInsert.textsToDelete],\n        tableName: textsTableName,\n      })\n    }\n\n    if (textsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: textsTableName,\n        values: textsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany NUMBERS\n    // //////////////////////////////////\n\n    const numbersTableName = `${tableName}_numbers`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...numbersToInsert, ...rowToInsert.numbersToDelete],\n        tableName: numbersTableName,\n      })\n    }\n\n    if (numbersToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: numbersTableName,\n        values: numbersToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT BLOCKS\n    // //////////////////////////////////\n\n    const insertedBlockRows: Record<string, Record<string, unknown>[]> = {}\n\n    if (operation === 'update') {\n      for (const tableName of rowToInsert.blocksToDelete) {\n        const blockTable = adapter.tables[tableName]\n        await adapter.deleteWhere({\n          db,\n          tableName,\n          where: eq(blockTable._parentID, insertedRow.id),\n        })\n      }\n    }\n\n    // When versions are enabled, adapter is used to track mapping between blocks/arrays ObjectID to their numeric generated representation, then we use it for nested to arrays/blocks select hasMany in versions.\n    const arraysBlocksUUIDMap: Record<string, number | string> = {}\n\n    for (const [tableName, blockRows] of Object.entries(blocksToInsert)) {\n      insertedBlockRows[tableName] = await adapter.insert({\n        db,\n        tableName,\n        values: blockRows.map(({ row }) => row),\n      })\n\n      insertedBlockRows[tableName].forEach((row, i) => {\n        blockRows[i].row = row\n        if (\n          typeof row._uuid === 'string' &&\n          (typeof row.id === 'string' || typeof row.id === 'number')\n        ) {\n          arraysBlocksUUIDMap[row._uuid] = row.id\n        }\n      })\n\n      const blockLocaleIndexMap: number[] = []\n\n      const blockLocaleRowsToInsert = blockRows.reduce((acc, blockRow, i) => {\n        if (Object.entries(blockRow.locales).length > 0) {\n          Object.entries(blockRow.locales).forEach(([blockLocale, blockLocaleData]) => {\n            if (Object.keys(blockLocaleData).length > 0) {\n              blockLocaleData._parentID = blockRow.row.id\n              blockLocaleData._locale = blockLocale\n              acc.push(blockLocaleData)\n              blockLocaleIndexMap.push(i)\n            }\n          })\n        }\n\n        return acc\n      }, [])\n\n      if (blockLocaleRowsToInsert.length > 0) {\n        await adapter.insert({\n          db,\n          tableName: `${tableName}${adapter.localesSuffix}`,\n          values: blockLocaleRowsToInsert,\n        })\n      }\n\n      await insertArrays({\n        adapter,\n        arrays: blockRows.map(({ arrays }) => arrays),\n        db,\n        parentRows: insertedBlockRows[tableName],\n        uuidMap: arraysBlocksUUIDMap,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT ARRAYS RECURSIVELY\n    // //////////////////////////////////\n\n    if (operation === 'update') {\n      for (const arrayTableName of Object.keys(rowToInsert.arrays)) {\n        await deleteExistingArrayRows({\n          adapter,\n          db,\n          parentID: insertedRow.id,\n          tableName: arrayTableName,\n        })\n      }\n    }\n\n    await insertArrays({\n      adapter,\n      arrays: [rowToInsert.arrays, rowToInsert.arraysToPush],\n      db,\n      parentRows: [insertedRow, insertedRow],\n      uuidMap: arraysBlocksUUIDMap,\n    })\n\n    // //////////////////////////////////\n    // INSERT hasMany SELECTS\n    // //////////////////////////////////\n\n    for (const [selectTableName, tableRows] of Object.entries(selectsToInsert)) {\n      const selectTable = adapter.tables[selectTableName]\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: selectTableName,\n          where: eq(selectTable.parent, insertedRow.id),\n        })\n      }\n\n      if (Object.keys(arraysBlocksUUIDMap).length > 0) {\n        tableRows.forEach((row: RelationshipRow) => {\n          if (row.parent in arraysBlocksUUIDMap) {\n            row.parent = arraysBlocksUUIDMap[row.parent]\n          }\n        })\n      }\n\n      if (tableRows.length) {\n        await adapter.insert({\n          db,\n          tableName: selectTableName,\n          values: tableRows,\n        })\n      }\n    }\n  } catch (error) {\n    handleUpsertError({ id, adapter, collectionSlug, error, globalSlug, req, tableName })\n  }\n\n  if (ignoreResult === 'idOnly') {\n    return { id: insertedRow.id } as T\n  }\n\n  if (ignoreResult) {\n    return data as T\n  }\n\n  // //////////////////////////////////\n  // RETRIEVE NEWLY UPDATED ROW\n  // //////////////////////////////////\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    depth: 0,\n    fields,\n    joinQuery: false,\n    select,\n    tableName,\n  })\n\n  findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n  const doc = await db.query[tableName].findFirst(findManyArgs)\n\n  // //////////////////////////////////\n  // TRANSFORM DATA\n  // //////////////////////////////////\n\n  const result = transform<T>({\n    adapter,\n    config: adapter.payload.config,\n    data: doc,\n    fields,\n    joinQuery: false,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["and","desc","eq","isNull","or","buildFindManyArgs","transform","transformForWrite","deleteExistingArrayRows","deleteExistingRowsByPath","handleUpsertError","insertArrays","shouldUseOptimizedUpsertRow","upsertRow","id","adapter","collectionSlug","data","db","fields","globalSlug","ignoreResult","joinQuery","_joinQuery","operation","path","req","select","tableName","upsertTarget","where","createdAt","Date","toISOString","insertedRow","transformedForWrite","enableAtomicWrites","row","arraysToPush","drizzle","Object","keys","length","arrays","parentRows","uuidMap","updatedAt","hasDataToUpdate","update","tables","set","findManyArgs","depth","findManyKeysLength","hasOnlyColumns","columns","doc","query","findFirst","config","payload","selectedFields","column","enabled","entries","docs","returning","undefined","error","rowToInsert","target","rowKeys","hasMainRowData","every","key","insert","onConflictDoUpdate","values","allowIDOnCreate","localesToInsert","relationsToInsert","textsToInsert","numbersToInsert","blocksToInsert","selectsToInsert","locales","forEach","locale","localeRow","_parentID","_locale","push","relationships","relation","parent","texts","textRow","numbers","numberRow","selects","selectTableName","selectRows","blocks","blockRow","uuid","localeTableName","localesSuffix","localeTable","deleteWhere","relationshipsTableName","relationshipsSuffix","generalRelationshipDeletes","relationshipsToDelete","filter","rel","localeColumnName","parentColumnName","parentID","pathColumnName","rows","relationshipsToAppend","relationshipsToInsert","map","parentId","relationshipTable","rawTables","relationTo","value","conditions","parts","endsWith","existingRels","maxOrder","from","maxOrderResult","order","orderBy","limit","index","relationshipsToActuallyInsert","newRow","some","existingRow","matches","relToDelete","itemToRemove","item","camelKey","textsTableName","textsToDelete","numbersTableName","numbersToDelete","insertedBlockRows","blocksToDelete","blockTable","arraysBlocksUUIDMap","blockRows","i","_uuid","blockLocaleIndexMap","blockLocaleRowsToInsert","reduce","acc","blockLocale","blockLocaleData","arrayTableName","tableRows","selectTable","result"],"mappings":"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"}