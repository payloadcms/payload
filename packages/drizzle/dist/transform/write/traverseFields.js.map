{"version":3,"sources":["../../../src/transform/write/traverseFields.ts"],"sourcesContent":["import { sql } from 'drizzle-orm'\nimport { APIError, type FlattenedField } from 'payload'\nimport { fieldIsVirtual, fieldShouldBeLocalized } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type {\n  NumberToDelete,\n  RelationshipToAppend,\n  RelationshipToDelete,\n  RowToInsert,\n  TextToDelete,\n} from './types.js'\n\nimport { isArrayOfRows } from '../../utilities/isArrayOfRows.js'\nimport { resolveBlockTableName } from '../../utilities/validateExistingBlockIsIdentical.js'\nimport { transformArray } from './array.js'\nimport { transformBlocks } from './blocks.js'\nimport { transformNumbers } from './numbers.js'\nimport { transformRelationship } from './relationships.js'\nimport { transformSelects } from './selects.js'\nimport { transformTexts } from './texts.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  /**\n   * This will delete the array table and then re-insert all the new array rows.\n   */\n  arrays: RowToInsert['arrays']\n  /**\n   * Array rows to push to the existing array. This will simply create\n   * a new row in the array table.\n   */\n  arraysToPush: RowToInsert['arraysToPush']\n  /**\n   * This is the name of the base table\n   */\n  baseTableName: string\n  blocks: RowToInsert['blocks']\n  blocksToDelete: Set<string>\n  /**\n   * A snake-case field prefix, representing prior fields\n   * Ex: my_group_my_named_tab_\n   */\n  columnPrefix: string\n  data: Record<string, unknown>\n  enableAtomicWrites?: boolean\n  existingLocales?: Record<string, unknown>[]\n  /**\n   * A prefix that will retain camel-case formatting, representing prior fields\n   * Ex: myGroup_myNamedTab_\n   */\n  fieldPrefix: string\n  fields: FlattenedField[]\n  forcedLocale?: string\n  /**\n   * Tracks whether the current traversion context is from array or block.\n   */\n  insideArrayOrBlock?: boolean\n  locales: {\n    [locale: string]: Record<string, unknown>\n  }\n  numbers: Record<string, unknown>[]\n  numbersToDelete: NumberToDelete[]\n  parentIsLocalized: boolean\n  /**\n   * This is the name of the parent table\n   */\n  parentTableName: string\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToAppend: RelationshipToAppend[]\n  relationshipsToDelete: RelationshipToDelete[]\n  row: Record<string, unknown>\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  textsToDelete: TextToDelete[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\n\nexport const traverseFields = ({\n  adapter,\n  arrays,\n  arraysToPush,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  columnPrefix,\n  data,\n  enableAtomicWrites,\n  existingLocales,\n  fieldPrefix,\n  fields,\n  forcedLocale,\n  insideArrayOrBlock = false,\n  locales,\n  numbers,\n  numbersToDelete,\n  parentIsLocalized,\n  parentTableName,\n  path,\n  relationships,\n  relationshipsToAppend,\n  relationshipsToDelete,\n  row,\n  selects,\n  texts,\n  textsToDelete,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  let fieldsMatched = false\n\n  if (row._uuid) {\n    data._uuid = row._uuid\n  }\n\n  fields.forEach((field) => {\n    let columnName = ''\n    let fieldName = ''\n    let fieldData: unknown\n\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    // Mark that we found a matching field\n    if (data[field.name] !== undefined) {\n      fieldsMatched = true\n    }\n\n    columnName = `${columnPrefix || ''}${toSnakeCase(field.name)}`\n    fieldName = `${fieldPrefix || ''}${field.name}`\n    fieldData = data[field.name]\n\n    const isLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    if (field.type === 'array') {\n      const arrayTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n\n      if (isLocalized) {\n        const value = data[field.name]\n\n        if (typeof value === 'object' && value !== null) {\n          Object.entries(value).forEach(([localeKey, localeValue]) => {\n            let localeData = localeValue\n            let push = false\n\n            if (localeValue && typeof localeValue === 'object' && '$push' in localeValue) {\n              localeData = localeValue.$push\n              push = true\n              if (!Array.isArray(localeData)) {\n                localeData = [localeData]\n              }\n            }\n\n            if (Array.isArray(localeData)) {\n              const newRows = transformArray({\n                adapter,\n                arrayTableName,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                numbersToDelete,\n                parentIsLocalized: parentIsLocalized || field.localized,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                textsToDelete,\n                withinArrayOrBlockLocale: localeKey,\n              })\n\n              if (push) {\n                if (!arraysToPush[arrayTableName]) {\n                  arraysToPush[arrayTableName] = []\n                }\n                arraysToPush[arrayTableName] = arraysToPush[arrayTableName].concat(newRows)\n              } else {\n                if (!arrays[arrayTableName]) {\n                  arrays[arrayTableName] = []\n                }\n                arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n              }\n            }\n          })\n        }\n      } else {\n        let value = data[field.name]\n        let push = false\n        if (typeof value === 'object' && '$push' in value) {\n          value = Array.isArray(value.$push) ? value.$push : [value.$push]\n          push = true\n        }\n\n        const newRows = transformArray({\n          adapter,\n          arrayTableName,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: value,\n          field,\n          numbers,\n          numbersToDelete,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          textsToDelete,\n          withinArrayOrBlockLocale,\n        })\n\n        if (push) {\n          if (!arraysToPush[arrayTableName]) {\n            arraysToPush[arrayTableName] = []\n          }\n          arraysToPush[arrayTableName] = arraysToPush[arrayTableName].concat(newRows)\n        } else {\n          if (!arrays[arrayTableName]) {\n            arrays[arrayTableName] = []\n          }\n          arrays[arrayTableName] = arrays[arrayTableName].concat(newRows)\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'blocks' && !adapter.blocksAsJSON) {\n      ;(field.blockReferences ?? field.blocks).forEach((block) => {\n        const matchedBlock =\n          typeof block === 'string'\n            ? adapter.payload.config.blocks.find((each) => each.slug === block)\n            : block\n\n        blocksToDelete.add(\n          resolveBlockTableName(\n            matchedBlock,\n            adapter.tableNameMap.get(`${baseTableName}_blocks_${toSnakeCase(matchedBlock.slug)}`),\n          ),\n        )\n      })\n\n      if (isLocalized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              transformBlocks({\n                adapter,\n                baseTableName,\n                blocks,\n                blocksToDelete,\n                data: localeData,\n                field,\n                locale: localeKey,\n                numbers,\n                numbersToDelete,\n                parentIsLocalized: parentIsLocalized || field.localized,\n                path,\n                relationships,\n                relationshipsToDelete,\n                selects,\n                texts,\n                textsToDelete,\n                withinArrayOrBlockLocale: localeKey,\n              })\n            }\n          })\n        }\n      } else if (isArrayOfRows(fieldData)) {\n        transformBlocks({\n          adapter,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          data: fieldData,\n          field,\n          numbers,\n          numbersToDelete,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          path,\n          relationships,\n          relationshipsToDelete,\n          selects,\n          texts,\n          textsToDelete,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'group' || field.type === 'tab') {\n      if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n        if (isLocalized) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            // preserve array ID if there is\n            localeData._uuid = data.id || data._uuid\n\n            traverseFields({\n              adapter,\n              arrays,\n              arraysToPush,\n              baseTableName,\n              blocks,\n              blocksToDelete,\n              columnPrefix: `${columnName}_`,\n              data: localeData as Record<string, unknown>,\n              enableAtomicWrites,\n              existingLocales,\n              fieldPrefix: `${fieldName}_`,\n              fields: field.flattenedFields,\n              forcedLocale: localeKey,\n              insideArrayOrBlock,\n              locales,\n              numbers,\n              numbersToDelete,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentTableName,\n              path: `${path || ''}${field.name}.`,\n              relationships,\n              relationshipsToAppend,\n              relationshipsToDelete,\n              row,\n              selects,\n              texts,\n              textsToDelete,\n              withinArrayOrBlockLocale: localeKey,\n            })\n          })\n        } else {\n          // preserve array ID if there is\n          const groupData = data[field.name] as Record<string, unknown>\n          groupData._uuid = data.id || data._uuid\n\n          traverseFields({\n            adapter,\n            arrays,\n            arraysToPush,\n            baseTableName,\n            blocks,\n            blocksToDelete,\n            columnPrefix: `${columnName}_`,\n            data: groupData,\n            existingLocales,\n            fieldPrefix: `${fieldName}_`,\n            fields: field.flattenedFields,\n            insideArrayOrBlock,\n            locales,\n            numbers,\n            numbersToDelete,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentTableName,\n            path: `${path || ''}${field.name}.`,\n            relationships,\n            relationshipsToAppend,\n            relationshipsToDelete,\n            row,\n            selects,\n            texts,\n            textsToDelete,\n            withinArrayOrBlockLocale,\n          })\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      const relationshipPath = `${path || ''}${field.name}`\n\n      // Handle $push operation for relationship fields\n      if (\n        fieldData &&\n        typeof fieldData === 'object' &&\n        'hasMany' in field &&\n        field.hasMany &&\n        ('$push' in fieldData ||\n          (field.localized &&\n            Object.values(fieldData).some(\n              (localeValue) =>\n                localeValue &&\n                typeof localeValue === 'object' &&\n                '$push' in (localeValue as Record<string, unknown>),\n            )))\n      ) {\n        let itemsToAppend: unknown[]\n\n        if (field.localized) {\n          let hasLocaleOperations = false\n          Object.entries(fieldData).forEach(([localeKey, localeValue]) => {\n            if (localeValue && typeof localeValue === 'object' && '$push' in localeValue) {\n              hasLocaleOperations = true\n              const push = localeValue.$push\n              const localeItems = Array.isArray(push) ? push : [push]\n\n              localeItems.forEach((item) => {\n                const relationshipToAppend: RelationshipToAppend = {\n                  locale: localeKey,\n                  path: relationshipPath,\n                  value: item,\n                }\n\n                // Handle polymorphic relationships\n                if (\n                  Array.isArray(field.relationTo) &&\n                  item &&\n                  typeof item === 'object' &&\n                  'relationTo' in item\n                ) {\n                  relationshipToAppend.relationTo = item.relationTo\n                  relationshipToAppend.value = item.value\n                } else if (typeof field.relationTo === 'string') {\n                  // Simple relationship\n                  relationshipToAppend.relationTo = field.relationTo\n                  relationshipToAppend.value = item\n                }\n\n                relationshipsToAppend.push(relationshipToAppend)\n              })\n            }\n          })\n\n          if (hasLocaleOperations) {\n            return\n          }\n        } else {\n          // Handle non-localized fields: { field: { $push: data } }\n          itemsToAppend = Array.isArray((fieldData as any).$push)\n            ? (fieldData as any).$push\n            : [(fieldData as any).$push]\n\n          itemsToAppend.forEach((item) => {\n            const relationshipToAppend: RelationshipToAppend = {\n              locale: isLocalized ? withinArrayOrBlockLocale : undefined,\n              path: relationshipPath,\n              value: item,\n            }\n\n            // Handle polymorphic relationships\n            if (\n              Array.isArray(field.relationTo) &&\n              item &&\n              typeof item === 'object' &&\n              'relationTo' in item &&\n              'value' in item\n            ) {\n              relationshipToAppend.relationTo = item.relationTo as string\n              relationshipToAppend.value = item.value as number | string\n            } else if (typeof field.relationTo === 'string') {\n              // Simple relationship\n              relationshipToAppend.relationTo = field.relationTo\n              relationshipToAppend.value = item\n            }\n\n            relationshipsToAppend.push(relationshipToAppend)\n          })\n        }\n        return\n      }\n\n      // Handle $remove operation for relationship fields\n      if (\n        fieldData &&\n        typeof fieldData === 'object' &&\n        'hasMany' in field &&\n        field.hasMany &&\n        ('$remove' in fieldData ||\n          (field.localized &&\n            Object.values(fieldData).some(\n              (localeValue) =>\n                localeValue &&\n                typeof localeValue === 'object' &&\n                '$remove' in (localeValue as Record<string, unknown>),\n            )))\n      ) {\n        // Check for new locale-first syntax: { field: { locale: { $remove: data } } }\n        if (field.localized) {\n          let hasLocaleOperations = false\n          Object.entries(fieldData).forEach(([localeKey, localeValue]) => {\n            if (localeValue && typeof localeValue === 'object' && '$remove' in localeValue) {\n              hasLocaleOperations = true\n              const remove = localeValue.$remove\n              const localeItems = Array.isArray(remove) ? remove : [remove]\n\n              localeItems.forEach((item) => {\n                const relationshipToDelete: RelationshipToDelete = {\n                  itemToRemove: item,\n                  locale: localeKey,\n                  path: relationshipPath,\n                }\n\n                // Store relationTo for simple relationships\n                if (typeof field.relationTo === 'string') {\n                  relationshipToDelete.relationTo = field.relationTo\n                }\n\n                relationshipsToDelete.push(relationshipToDelete)\n              })\n            }\n          })\n\n          if (hasLocaleOperations) {\n            return\n          }\n        } else {\n          // Handle non-localized fields: { field: { $remove: data } }\n          const itemsToRemove = Array.isArray((fieldData as any).$remove)\n            ? (fieldData as any).$remove\n            : [(fieldData as any).$remove]\n\n          itemsToRemove.forEach((item) => {\n            const relationshipToDelete: RelationshipToDelete = {\n              itemToRemove: item,\n              locale: isLocalized ? withinArrayOrBlockLocale : undefined,\n              path: relationshipPath,\n            }\n\n            // Store relationTo for simple relationships\n            if (typeof field.relationTo === 'string') {\n              relationshipToDelete.relationTo = field.relationTo\n            }\n\n            relationshipsToDelete.push(relationshipToDelete)\n          })\n        }\n        return\n      }\n\n      if (\n        isLocalized &&\n        (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany))\n      ) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (localeData === null) {\n              relationshipsToDelete.push({\n                locale: localeKey,\n                path: relationshipPath,\n              })\n              return\n            }\n\n            transformRelationship({\n              baseRow: {\n                locale: localeKey,\n                path: relationshipPath,\n              },\n              data: localeData,\n              field,\n              relationships,\n            })\n          })\n        }\n        return\n      } else if (Array.isArray(field.relationTo) || ('hasMany' in field && field.hasMany)) {\n        if (fieldData === null || (Array.isArray(fieldData) && fieldData.length === 0)) {\n          relationshipsToDelete.push({ path: relationshipPath })\n          return\n        }\n\n        transformRelationship({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: relationshipPath,\n          },\n          data: fieldData,\n          field,\n          relationships,\n        })\n        return\n      } else {\n        if (\n          !isLocalized &&\n          fieldData &&\n          typeof fieldData === 'object' &&\n          'id' in fieldData &&\n          fieldData?.id\n        ) {\n          fieldData = fieldData.id\n        } else if (isLocalized) {\n          if (typeof fieldData === 'object') {\n            Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n              if (typeof localeData === 'object') {\n                if (localeData && 'id' in localeData && localeData?.id) {\n                  fieldData[localeKey] = localeData.id\n                }\n              } else {\n                fieldData[localeKey] = localeData\n              }\n            })\n          }\n        }\n      }\n    }\n\n    if (field.type === 'text' && field.hasMany) {\n      const textPath = `${path || ''}${field.name}`\n\n      if (isLocalized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              if (!localeData.length) {\n                textsToDelete.push({ locale: localeKey, path: textPath })\n                return\n              }\n\n              transformTexts({\n                baseRow: {\n                  locale: localeKey,\n                  path: textPath,\n                },\n                data: localeData,\n                texts,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        if (!fieldData.length) {\n          textsToDelete.push({ locale: withinArrayOrBlockLocale, path: textPath })\n          return\n        }\n\n        transformTexts({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: textPath,\n          },\n          data: fieldData,\n          texts,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'number' && field.hasMany) {\n      const numberPath = `${path || ''}${field.name}`\n\n      if (isLocalized) {\n        if (typeof fieldData === 'object') {\n          Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              if (!localeData.length) {\n                numbersToDelete.push({ locale: localeKey, path: numberPath })\n                return\n              }\n\n              transformNumbers({\n                baseRow: {\n                  locale: localeKey,\n                  path: numberPath,\n                },\n                data: localeData,\n                numbers,\n              })\n            }\n          })\n        }\n      } else if (Array.isArray(fieldData)) {\n        if (!fieldData.length) {\n          numbersToDelete.push({ locale: withinArrayOrBlockLocale, path: numberPath })\n          return\n        }\n\n        transformNumbers({\n          baseRow: {\n            locale: withinArrayOrBlockLocale,\n            path: numberPath,\n          },\n          data: fieldData,\n          numbers,\n        })\n      }\n\n      return\n    }\n\n    if (field.type === 'select' && field.hasMany) {\n      const selectTableName = adapter.tableNameMap.get(`${parentTableName}_${columnName}`)\n      if (!selects[selectTableName]) {\n        selects[selectTableName] = []\n      }\n\n      if (isLocalized) {\n        if (typeof data[field.name] === 'object' && data[field.name] !== null) {\n          Object.entries(data[field.name]).forEach(([localeKey, localeData]) => {\n            if (Array.isArray(localeData)) {\n              const newRows = transformSelects({\n                id: insideArrayOrBlock ? data._uuid || data.id : undefined,\n                data: localeData,\n                locale: localeKey,\n              })\n\n              selects[selectTableName] = selects[selectTableName].concat(newRows)\n            }\n          })\n        }\n      } else if (Array.isArray(data[field.name])) {\n        const newRows = transformSelects({\n          id: insideArrayOrBlock ? data._uuid || data.id : undefined,\n          data: data[field.name],\n          locale: withinArrayOrBlockLocale,\n        })\n\n        selects[selectTableName] = selects[selectTableName].concat(newRows)\n      }\n\n      return\n    }\n\n    const valuesToTransform: { localeKey?: string; ref: unknown; value: unknown }[] = []\n\n    if (isLocalized) {\n      if (typeof fieldData === 'object' && fieldData !== null) {\n        Object.entries(fieldData).forEach(([localeKey, localeData]) => {\n          if (!locales[localeKey]) {\n            locales[localeKey] = {}\n          }\n\n          valuesToTransform.push({\n            localeKey,\n            ref: locales,\n            value: localeData,\n          })\n        })\n      }\n    } else {\n      let ref = row\n\n      if (forcedLocale) {\n        if (!locales[forcedLocale]) {\n          locales[forcedLocale] = {}\n        }\n        ref = locales[forcedLocale]\n      }\n\n      valuesToTransform.push({ ref, value: fieldData })\n    }\n\n    valuesToTransform.forEach(({ localeKey, ref, value }) => {\n      let formattedValue = value\n\n      if (field.type === 'date') {\n        if (fieldName === 'updatedAt' && formattedValue === null) {\n          // If updatedAt is explicitly set to null, skip it entirely - don't add to row\n          // This prevents the timestamp from being updated for session-only operations\n          return // Skip this iteration\n        } else if (fieldName === 'updatedAt' && typeof formattedValue === 'undefined') {\n          // If updatedAt is undefined, set it to current time (normal behavior)\n          formattedValue = new Date().toISOString()\n        } else {\n          if (typeof value === 'number' && !Number.isNaN(value)) {\n            formattedValue = new Date(value).toISOString()\n          } else if (value instanceof Date) {\n            formattedValue = value.toISOString()\n          }\n        }\n      }\n\n      if (typeof value !== 'undefined') {\n        if (value && field.type === 'point' && adapter.name !== 'sqlite') {\n          formattedValue = sql`ST_GeomFromGeoJSON(${JSON.stringify(value)})`\n        }\n\n        if (field.type === 'text' && value && typeof value !== 'string') {\n          formattedValue = JSON.stringify(value)\n        }\n\n        if (\n          field.type === 'number' &&\n          value &&\n          typeof value === 'object' &&\n          '$inc' in value &&\n          typeof value.$inc === 'number'\n        ) {\n          if (!enableAtomicWrites) {\n            throw new APIError(\n              'The passed data must not contain any nested fields for atomic writes',\n            )\n          }\n\n          formattedValue = sql.raw(`${columnName} + ${value.$inc}`)\n        }\n      }\n\n      if (typeof formattedValue !== 'undefined') {\n        if (localeKey) {\n          ref[localeKey][fieldName] = formattedValue\n        } else {\n          ref[fieldName] = formattedValue\n        }\n      }\n    })\n  })\n\n  // Handle dot-notation paths when no fields matched\n  if (!fieldsMatched) {\n    Object.keys(data).forEach((key) => {\n      if (key.includes('.')) {\n        // Split on first dot only\n        const firstDotIndex = key.indexOf('.')\n        const fieldName = key.substring(0, firstDotIndex)\n        const remainingPath = key.substring(firstDotIndex + 1)\n\n        // Create nested structure for this field\n        if (!data[fieldName]) {\n          data[fieldName] = {}\n        }\n\n        const nestedData = data[fieldName] as Record<string, unknown>\n\n        // Move the value to the nested structure\n        nestedData[remainingPath] = data[key]\n        delete data[key]\n\n        // Recursively process the newly created nested structure\n        // The field traversal will naturally handle it if the field exists in the schema\n        traverseFields({\n          adapter,\n          arrays,\n          arraysToPush,\n          baseTableName,\n          blocks,\n          blocksToDelete,\n          columnPrefix,\n          data,\n          enableAtomicWrites,\n          existingLocales,\n          fieldPrefix,\n          fields,\n          forcedLocale,\n          insideArrayOrBlock,\n          locales,\n          numbers,\n          numbersToDelete,\n          parentIsLocalized,\n          parentTableName,\n          path,\n          relationships,\n          relationshipsToAppend,\n          relationshipsToDelete,\n          row,\n          selects,\n          texts,\n          textsToDelete,\n          withinArrayOrBlockLocale,\n        })\n      }\n    })\n  }\n}\n"],"names":["sql","APIError","fieldIsVirtual","fieldShouldBeLocalized","toSnakeCase","isArrayOfRows","resolveBlockTableName","transformArray","transformBlocks","transformNumbers","transformRelationship","transformSelects","transformTexts","traverseFields","adapter","arrays","arraysToPush","baseTableName","blocks","blocksToDelete","columnPrefix","data","enableAtomicWrites","existingLocales","fieldPrefix","fields","forcedLocale","insideArrayOrBlock","locales","numbers","numbersToDelete","parentIsLocalized","parentTableName","path","relationships","relationshipsToAppend","relationshipsToDelete","row","selects","texts","textsToDelete","withinArrayOrBlockLocale","fieldsMatched","_uuid","forEach","field","columnName","fieldName","fieldData","name","undefined","isLocalized","type","arrayTableName","tableNameMap","get","value","Object","entries","localeKey","localeValue","localeData","push","$push","Array","isArray","newRows","locale","localized","concat","blocksAsJSON","blockReferences","block","matchedBlock","payload","config","find","each","slug","add","id","flattenedFields","groupData","relationshipPath","hasMany","values","some","itemsToAppend","hasLocaleOperations","localeItems","item","relationshipToAppend","relationTo","remove","$remove","relationshipToDelete","itemToRemove","itemsToRemove","baseRow","length","textPath","numberPath","selectTableName","valuesToTransform","ref","formattedValue","Date","toISOString","Number","isNaN","JSON","stringify","$inc","raw","keys","key","includes","firstDotIndex","indexOf","substring","remainingPath","nestedData"],"mappings":"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"}