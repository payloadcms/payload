{"version":3,"sources":["../../src/transactions/beginTransaction.ts"],"sourcesContent":["import type { BeginTransaction } from 'payload'\n\nimport { v4 as uuid } from 'uuid'\n\nimport type { DrizzleAdapter, DrizzleTransaction } from '../types.js'\n\nexport const beginTransaction: BeginTransaction = async function beginTransaction(\n  this: DrizzleAdapter,\n  options: DrizzleAdapter['transactionOptions'],\n) {\n  let id\n  try {\n    id = uuid()\n\n    let reject: () => Promise<void>\n    let resolve: () => Promise<void>\n    let transaction: DrizzleTransaction\n\n    let transactionReady: () => void\n\n    // Await initialization here\n    // Prevent race conditions where the adapter may be\n    // re-initializing, and `this.drizzle` is potentially undefined\n    await this.initializing\n\n    // Drizzle only exposes a transactions API that is sufficient if you\n    // can directly pass around the `tx` argument. But our operations are spread\n    // over many files and we don't want to pass the `tx` around like that,\n    // so instead, we \"lift\" up the `resolve` and `reject` methods\n    // and will call them in our respective transaction methods\n    const done = this.drizzle\n      .transaction(async (tx) => {\n        transaction = tx\n        await new Promise<void>((res, rej) => {\n          resolve = () => {\n            res()\n            return done\n          }\n          reject = () => {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            rej()\n            return done\n          }\n          transactionReady()\n        })\n      }, options || this.transactionOptions)\n      .catch(() => {\n        // swallow\n      })\n\n    // Need to wait until the transaction is ready\n    // before binding its `resolve` and `reject` methods below\n    await new Promise<void>((resolve) => (transactionReady = resolve))\n\n    this.sessions[id] = {\n      db: transaction,\n      reject,\n      resolve,\n    }\n  } catch (err) {\n    this.payload.logger.error({ err, msg: `Error: cannot begin transaction: ${err.message}` })\n    throw new Error(`Error: cannot begin transaction: ${err.message}`)\n  }\n\n  return id\n}\n"],"names":["v4","uuid","beginTransaction","options","id","reject","resolve","transaction","transactionReady","initializing","done","drizzle","tx","Promise","res","rej","transactionOptions","catch","sessions","db","err","payload","logger","error","msg","message","Error"],"mappings":"AAEA,SAASA,MAAMC,IAAI,QAAQ,OAAM;AAIjC,OAAO,MAAMC,mBAAqC,eAAeA,iBAE/DC,OAA6C;IAE7C,IAAIC;IACJ,IAAI;QACFA,KAAKH;QAEL,IAAII;QACJ,IAAIC;QACJ,IAAIC;QAEJ,IAAIC;QAEJ,4BAA4B;QAC5B,mDAAmD;QACnD,+DAA+D;QAC/D,MAAM,IAAI,CAACC,YAAY;QAEvB,oEAAoE;QACpE,4EAA4E;QAC5E,uEAAuE;QACvE,8DAA8D;QAC9D,2DAA2D;QAC3D,MAAMC,OAAO,IAAI,CAACC,OAAO,CACtBJ,WAAW,CAAC,OAAOK;YAClBL,cAAcK;YACd,MAAM,IAAIC,QAAc,CAACC,KAAKC;gBAC5BT,UAAU;oBACRQ;oBACA,OAAOJ;gBACT;gBACAL,SAAS;oBACP,2EAA2E;oBAC3EU;oBACA,OAAOL;gBACT;gBACAF;YACF;QACF,GAAGL,WAAW,IAAI,CAACa,kBAAkB,EACpCC,KAAK,CAAC;QACL,UAAU;QACZ;QAEF,8CAA8C;QAC9C,0DAA0D;QAC1D,MAAM,IAAIJ,QAAc,CAACP,UAAaE,mBAAmBF;QAEzD,IAAI,CAACY,QAAQ,CAACd,GAAG,GAAG;YAClBe,IAAIZ;YACJF;YACAC;QACF;IACF,EAAE,OAAOc,KAAK;QACZ,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,KAAK,CAAC;YAAEH;YAAKI,KAAK,CAAC,iCAAiC,EAAEJ,IAAIK,OAAO,EAAE;QAAC;QACxF,MAAM,IAAIC,MAAM,CAAC,iCAAiC,EAAEN,IAAIK,OAAO,EAAE;IACnE;IAEA,OAAOrB;AACT,EAAC"}