{"version":3,"sources":["../../src/types/index.ts"],"sourcesContent":["import type {\n  Access,\n  CollectionConfig,\n  CollectionSlug,\n  DefaultDocumentIDType,\n  Endpoint,\n  Field,\n  FieldAccess,\n  GroupField,\n  PayloadRequest,\n  PopulateType,\n  SelectType,\n  TypedCollection,\n  TypedUser,\n  Where,\n} from 'payload'\nimport type React from 'react'\n\nimport type { TypedEcommerce } from './utilities.js'\n\nexport type FieldsOverride = (args: { defaultFields: Field[] }) => Field[]\n\nexport type CollectionOverride = (args: {\n  defaultCollection: CollectionConfig\n}) => CollectionConfig | Promise<CollectionConfig>\n\nexport type CartItem = {\n  /**\n   * The ID of the cart item. Array item IDs are always strings in Payload,\n   * regardless of the database adapter's default ID type.\n   */\n  id: string\n  product: DefaultDocumentIDType | TypedCollection['products']\n  quantity: number\n  variant?: DefaultDocumentIDType | TypedCollection['variants']\n}\n\ntype DefaultCartType = {\n  currency?: string\n  customer?: DefaultDocumentIDType | TypedCollection['customers']\n  id: DefaultDocumentIDType\n  items: CartItem[]\n  subtotal?: number\n}\n\nexport type Cart = DefaultCartType\n\ntype InitiatePaymentReturnType = {\n  /**\n   * Allows for additional data to be returned, such as payment method specific data\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any\n  message: string\n}\n\ntype InitiatePayment = (args: {\n  /**\n   * The slug of the customers collection, defaults to 'users'.\n   */\n  customersSlug?: string\n  data: {\n    /**\n     * Billing address for the payment.\n     */\n    billingAddress: TypedCollection['addresses']\n    /**\n     * Cart items.\n     */\n    cart: Cart\n    /**\n     * Currency code to use for the payment.\n     */\n    currency: string\n    customerEmail: string\n    /**\n     * Shipping address for the payment.\n     */\n    shippingAddress?: TypedCollection['addresses']\n  }\n  req: PayloadRequest\n  /**\n   * The slug of the transactions collection, defaults to 'transactions'.\n   * For example, this is used to create a record of the payment intent in the transactions collection.\n   */\n  transactionsSlug: string\n}) => InitiatePaymentReturnType | Promise<InitiatePaymentReturnType>\n\ntype ConfirmOrderReturnType = {\n  /**\n   * Allows for additional data to be returned, such as payment method specific data\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any\n  message: string\n  orderID: DefaultDocumentIDType\n  transactionID: DefaultDocumentIDType\n}\n\ntype ConfirmOrder = (args: {\n  /**\n   * The slug of the carts collection, defaults to 'carts'.\n   * For example, this is used to retrieve the cart for the order.\n   */\n  cartsSlug?: string\n  /**\n   * The slug of the customers collection, defaults to 'users'.\n   */\n  customersSlug?: string\n  /**\n   * Data made available to the payment method when confirming an order. You should get the cart items from the transaction.\n   */\n  data: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [key: string]: any // Allows for additional data to be passed through, such as payment method specific data\n    customerEmail?: string\n  }\n  /**\n   * The slug of the orders collection, defaults to 'orders'.\n   */\n  ordersSlug?: string\n  req: PayloadRequest\n  /**\n   * The slug of the transactions collection, defaults to 'transactions'.\n   * For example, this is used to create a record of the payment intent in the transactions collection.\n   */\n  transactionsSlug?: string\n}) => ConfirmOrderReturnType | Promise<ConfirmOrderReturnType>\n\n/**\n * The full payment adapter config expected as part of the config for the Ecommerce plugin.\n *\n * You can insert this type directly or return it from a function constructing it.\n */\nexport type PaymentAdapter = {\n  /**\n   * The function that is called via the `/api/payments/{provider_name}/confirm-order` endpoint to confirm an order after a payment has been made.\n   *\n   * You should handle the order confirmation logic here.\n   *\n   * @example\n   *\n   * ```ts\n   * const confirmOrder: ConfirmOrder = async ({ data: { customerEmail }, ordersSlug, req, transactionsSlug }) => {\n      // Confirm the payment with Stripe or another payment provider here\n      // Create an order in the orders collection here\n      // Update the record of the payment intent in the transactions collection here\n      return {\n        message: 'Order confirmed successfully',\n        orderID: 'order_123',\n        transactionID: 'txn_123',\n        // Include any additional data required for the payment method here\n      }\n    }\n   * ```\n   */\n  confirmOrder: ConfirmOrder\n  /**\n   * An array of endpoints to be bootstrapped to Payload's API in order to support the payment method. All API paths are relative to `/api/payments/{provider_name}`.\n   *\n   * So for example, path `/webhooks` in the Stripe adapter becomes `/api/payments/stripe/webhooks`.\n   *\n   * @example '/webhooks'\n   */\n  endpoints?: Endpoint[]\n  /**\n   * A group configuration to be used in the admin interface to display the payment method.\n   *\n   * @example\n   *\n   * ```ts\n   * const groupField: GroupField = {\n      name: 'stripe',\n      type: 'group',\n      admin: {\n        condition: (data) => data?.paymentMethod === 'stripe',\n      },\n      fields: [\n        {\n          name: 'stripeCustomerID',\n          type: 'text',\n          label: 'Stripe Customer ID',\n          required: true,\n        },\n        {\n          name: 'stripePaymentIntentID',\n          type: 'text',\n          label: 'Stripe PaymentIntent ID',\n          required: true,\n        },\n      ],\n    }\n   * ```\n   */\n  group: GroupField\n  /**\n   * The function that is called via the `/api/payments/{provider_name}/initiate` endpoint to initiate a payment for an order.\n   *\n   * You should handle the payment initiation logic here.\n   *\n   * @example\n   *\n   * ```ts\n   * const initiatePayment: InitiatePayment = async ({ data: { cart, currency, customerEmail, billingAddress, shippingAddress }, req, transactionsSlug }) => {\n      // Create a payment intent with Stripe or another payment provider here\n      // Create a record of the payment intent in the transactions collection here\n      return {\n        message: 'Payment initiated successfully',\n        // Include any additional data required for the payment method here\n      }\n    }\n   * ```\n   */\n  initiatePayment: InitiatePayment\n  /**\n   * The label of the payment method\n   * @example\n   * 'Bank Transfer'\n   */\n  label?: string\n  /**\n   * The name of the payment method\n   * @example 'stripe'\n   */\n  name: string\n}\n\nexport type PaymentAdapterClient = {\n  confirmOrder: boolean\n  initiatePayment: boolean\n} & Pick<PaymentAdapter, 'label' | 'name'>\n\nexport type Currency = {\n  /**\n   * The ISO 4217 currency code\n   * @example 'usd'\n   */\n  code: string\n  /**\n   * The number of decimal places the currency uses\n   * @example 2\n   */\n  decimals: number\n  /**\n   * A user friendly name for the currency.\n   *\n   * @example 'US Dollar'\n   */\n  label: string\n  /**\n   * The symbol of the currency\n   * @example '$'\n   */\n  symbol: string\n}\n\n/**\n * Commonly used arguments for a Payment Adapter function, it's use is entirely optional.\n */\nexport type PaymentAdapterArgs = {\n  /**\n   * Overrides the default fields of the collection. Affects the payment fields on collections such as transactions.\n   */\n  groupOverrides?: { fields?: FieldsOverride } & Partial<Omit<GroupField, 'fields'>>\n  /**\n   * The visually readable label for the payment method.\n   * @example 'Bank Transfer'\n   */\n  label?: string\n}\n\n/**\n * Commonly used arguments for a Payment Adapter function, it's use is entirely optional.\n */\nexport type PaymentAdapterClientArgs = {\n  /**\n   * The visually readable label for the payment method.\n   * @example 'Bank Transfer'\n   */\n  label?: string\n}\n\nexport type VariantsConfig = {\n  /**\n   * Override the default variants collection. If you override the collection, you should ensure it has the required fields for variants or re-use the default fields.\n   *\n   * @example\n   *\n   * ```ts\n   * variants: {\n      variantOptionsCollectionOverride: ({ defaultCollection }) => ({\n        ...defaultCollection,\n        fields: [\n          ...defaultCollection.fields,\n          {\n            name: 'customField',\n            label: 'Custom Field',\n            type: 'text',\n          },\n        ],\n      })\n    }\n  ```\n   */\n  variantOptionsCollectionOverride?: CollectionOverride\n  /**\n   * Override the default variants collection. If you override the collection, you should ensure it has the required fields for variants or re-use the default fields.\n   *\n   * @example\n   *\n   * ```ts\n   * variants: {\n      variantsCollectionOverride: ({ defaultCollection }) => ({\n        ...defaultCollection,\n        fields: [\n          ...defaultCollection.fields,\n          {\n            name: 'customField',\n            label: 'Custom Field',\n            type: 'text',\n          },\n        ],\n      })\n    }\n  ```\n   */\n  variantsCollectionOverride?: CollectionOverride\n  /**\n   * Override the default variants collection. If you override the collection, you should ensure it has the required fields for variants or re-use the default fields.\n   *\n   * @example\n   *\n   * ```ts\n   * variants: {\n      variantTypesCollectionOverride: ({ defaultCollection }) => ({\n        ...defaultCollection,\n        fields: [\n          ...defaultCollection.fields,\n          {\n            name: 'customField',\n            label: 'Custom Field',\n            type: 'text',\n          },\n        ],\n      })\n    }\n  ```\n   */\n  variantTypesCollectionOverride?: CollectionOverride\n}\n\nexport type ProductsConfig = {\n  /**\n   * Override the default products collection. If you override the collection, you should ensure it has the required fields for products or re-use the default fields.\n   *\n   * @example\n   *\n   * ```ts\n    products: {\n      productsCollectionOverride: ({ defaultCollection }) => ({\n        ...defaultCollection,\n        fields: [\n          ...defaultCollection.fields,\n          {\n            name: 'notes',\n            label: 'Notes',\n            type: 'textarea',\n          },\n        ],\n      })\n    }\n    ```\n   */\n  productsCollectionOverride?: CollectionOverride\n  /**\n   * Customise the validation used for checking products or variants before a transaction is created or a payment can be confirmed.\n   */\n  validation?: ProductsValidation\n  /**\n   * Enable variants and provide configuration for the variant collections.\n   *\n   * Defaults to true.\n   */\n  variants?: boolean | VariantsConfig\n}\n\nexport type OrdersConfig = {\n  /**\n   * Override the default orders collection. If you override the collection, you should ensure it has the required fields for orders or re-use the default fields.\n   *\n   * @example\n   *\n   * ```ts\n      orders: {\n        ordersCollectionOverride: ({ defaultCollection }) => ({\n          ...defaultCollection,\n          fields: [\n            ...defaultCollection.fields,\n            {\n              name: 'notes',\n              label: 'Notes',\n              type: 'textarea',\n            },\n          ],\n        })\n      }\n    ```\n   */\n  ordersCollectionOverride?: CollectionOverride\n}\n\nexport type TransactionsConfig = {\n  /**\n   * Override the default transactions collection. If you override the collection, you should ensure it has the required fields for transactions or re-use the default fields.\n   *\n   * @example\n   *\n   * ```ts\n    transactions: {\n      transactionsCollectionOverride: ({ defaultCollection }) => ({\n        ...defaultCollection,\n        fields: [\n          ...defaultCollection.fields,\n          {\n            name: 'notes',\n            label: 'Notes',\n            type: 'textarea',\n          },\n        ],\n      })\n    }\n    ```\n   */\n  transactionsCollectionOverride?: CollectionOverride\n}\n\nexport type CustomQuery = {\n  depth?: number\n  select?: SelectType\n  where?: Where\n}\n\nexport type PaymentsConfig = {\n  paymentMethods?: PaymentAdapter[]\n  productsQuery?: CustomQuery\n  variantsQuery?: CustomQuery\n}\n\nexport type CountryType = {\n  /**\n   * A user friendly name for the country.\n   */\n  label: string\n  /**\n   * The ISO 3166-1 alpha-2 country code.\n   * @example 'US'\n   */\n  value: string\n}\n\n/**\n * Configuration for the addresses used by the Ecommerce plugin. Use this to override the default collection or fields used throughout\n */\ntype AddressesConfig = {\n  /**\n   * Override the default addresses collection. If you override the collection, you should ensure it has the required fields for addresses or re-use the default fields.\n   *\n   * @example\n   * ```ts\n   * addressesCollectionOverride: (defaultCollection) => {\n   *  return {\n   *    ...defaultCollection,\n   *    fields: [\n   *      ...defaultCollection.fields,\n   *      // add custom fields here\n   *    ],\n   *  }\n   * }\n   * ```\n   */\n  addressesCollectionOverride?: CollectionOverride\n  /**\n   * These fields will be applied to all locations where addresses are used, such as Orders and Transactions. Preferred use over the collectionOverride config.\n   */\n  addressFields?: FieldsOverride\n  /**\n   * Provide an array of countries to support for addresses. This will be used in the admin interface to provide a select field of countries.\n   *\n   * Defaults to a set of commonly used countries.\n   *\n   * @example\n   * ```\n   * [\n      { label: 'United States', value: 'US' },\n      { label: 'Canada', value: 'CA' },\n    ]\n   */\n  supportedCountries?: CountryType[]\n}\n\nexport type CustomersConfig = {\n  /**\n   * Slug of the customers collection, defaults to 'users'.\n   * This is used to link carts and orders to customers.\n   */\n  slug: string\n}\n\n/**\n * Arguments for the cart item matcher function.\n */\nexport type CartItemMatcherArgs = {\n  /** The existing cart item to compare against */\n  existingItem: {\n    [key: string]: unknown\n    /**\n     * The ID of the cart item. Array item IDs are always strings in Payload,\n     * regardless of the database adapter's default ID type.\n     */\n    id?: string\n    product: { [key: string]: unknown; id: DefaultDocumentIDType } | DefaultDocumentIDType\n    quantity: number\n    variant?: { [key: string]: unknown; id: DefaultDocumentIDType } | DefaultDocumentIDType\n  }\n  /** The new item being added */\n  newItem: {\n    [key: string]: unknown\n    product: DefaultDocumentIDType\n    quantity?: number\n    variant?: DefaultDocumentIDType\n  }\n}\n\n/**\n * Function to determine if two cart items should be considered the same.\n * When items match, their quantities are combined instead of creating separate entries.\n */\nexport type CartItemMatcher = (args: CartItemMatcherArgs) => boolean\n\nexport type CartsConfig = {\n  /**\n   * Allow guest (unauthenticated) users to create carts.\n   * When enabled, guests can create carts without being logged in.\n   * Defaults to true.\n   */\n  allowGuestCarts?: boolean\n  /**\n   * Custom function to determine if two cart items should be considered the same.\n   * When items match, their quantities are combined instead of creating separate entries.\n   *\n   * Use this to add custom uniqueness criteria beyond product and variant IDs.\n   *\n   * @default defaultCartItemMatcher (matches by product and variant ID only)\n   *\n   * @example\n   * ```ts\n   * cartItemMatcher: ({ existingItem, newItem }) => {\n   *   // Match by product, variant, AND custom delivery option\n   *   const productMatch = existingItem.product === newItem.product\n   *   const variantMatch = existingItem.variant === newItem.variant\n   *   const deliveryMatch = existingItem.deliveryOption === newItem.deliveryOption\n   *   return productMatch && variantMatch && deliveryMatch\n   * }\n   * ```\n   */\n  cartItemMatcher?: CartItemMatcher\n  cartsCollectionOverride?: CollectionOverride\n}\n\nexport type InventoryConfig = {\n  /**\n   * Override the default field used to track inventory levels. Defaults to 'inventory'.\n   */\n  fieldName?: string\n}\n\nexport type CurrenciesConfig = {\n  /**\n   * Defaults to the first supported currency.\n   *\n   * @example 'USD'\n   */\n  defaultCurrency: string\n  /**\n   *\n   */\n  supportedCurrencies: Currency[]\n}\n\n/**\n * A function that validates a product or variant before a transaction is created or completed.\n * This should throw an error if validation fails as it will be caught by the function calling it.\n */\nexport type ProductsValidation = (args: {\n  /**\n   * The full currencies config, allowing you to check against supported currencies and their settings.\n   */\n  currenciesConfig?: CurrenciesConfig\n  /**\n   * The ISO 4217 currency code being usen in this transaction.\n   */\n  currency?: string\n  /**\n   * The full product data.\n   */\n  product: TypedCollection['products']\n  /**\n   * Quantity to check the inventory amount against.\n   */\n  quantity: number\n  /**\n   * The full variant data, if a variant was selected for the product otherwise it will be undefined.\n   */\n  variant?: TypedCollection['variants']\n}) => Promise<void> | void\n\n/**\n * A map of collection slugs used by the Ecommerce plugin.\n * Provides an easy way to track the slugs of collections even when they are overridden.\n * Variant-related slugs are only present when variants are enabled.\n */\nexport type CollectionSlugMap = {\n  addresses: string\n  carts: string\n  customers: string\n  orders: string\n  products: string\n  transactions: string\n  variantOptions?: string\n  variants?: string\n  variantTypes?: string\n}\n\n/**\n * Access control functions used throughout the Ecommerce plugin.\n * Provide atomic access functions that can be composed using or, and, conditional utilities.\n *\n * @example\n * ```ts\n *  access: {\n *    isAdmin: ({ req }) => checkRole(['admin'], req.user),\n *    isAuthenticated: ({ req }) => !!req.user,\n *    isCustomer: ({ req }) => req.user && !checkRole(['admin'], req.user),\n *    isDocumentOwner: ({ req }) => {\n *      if (!req.user) return false\n *      return { customer: { equals: req.user.id } }\n *    },\n *    adminOnlyFieldAccess: ({ req }) => checkRole(['admin'], req.user),\n *    adminOrPublishedStatus: ({ req }) => {\n *      if (checkRole(['admin'], req.user)) return true\n *      return { _status: { equals: 'published' } }\n *    },\n *  }\n * ```\n */\nexport type AccessConfig = {\n  /**\n   * Limited to only admin users, specifically for Field level access control.\n   */\n  adminOnlyFieldAccess: FieldAccess\n  /**\n   * The document status is published or user is admin.\n   */\n  adminOrPublishedStatus: Access\n  /**\n   * @deprecated Will be removed in v4. Use `isCustomer` instead.\n   * Limited to customers only, specifically for Field level access control.\n   */\n  customerOnlyFieldAccess?: FieldAccess\n  /**\n   * Checks if the user is an admin.\n   * @returns true if admin, false otherwise\n   */\n  isAdmin: Access\n  /**\n   * Checks if the user is authenticated (any role).\n   * @returns true if authenticated, false otherwise\n   */\n  isAuthenticated?: Access\n  /**\n   * Checks if the user is a customer (authenticated but not an admin).\n   * Used internally to auto-assign customer ID when creating addresses.\n   * @returns true if user is a non-admin customer, false otherwise\n   *\n   * @example\n   * isCustomer: ({ req }) => req.user && !checkRole(['admin'], req.user)\n   */\n  isCustomer?: FieldAccess\n  /**\n   * Checks if the user owns the document being accessed.\n   * Typically returns a Where query to filter by customer field.\n   * @returns true for full access, false for no access, or Where query for conditional access\n   */\n  isDocumentOwner: Access\n  /**\n   * Entirely public access. Defaults to returning true.\n   *\n   * @example\n   * publicAccess: () => true\n   */\n  publicAccess?: Access\n}\n\nexport type EcommercePluginConfig = {\n  /**\n   * Customise the access control for the plugin.\n   *\n   * @example\n   * ```ts\n   * ```\n   */\n  access: AccessConfig\n  /**\n   * Enable the addresses collection to allow customers, transactions and orders to have multiple addresses for shipping and billing. Accepts an override to customise the addresses collection.\n   * Defaults to supporting a default set of countries.\n   */\n  addresses?: AddressesConfig | boolean\n  /**\n   * Configure the target collection used for carts.\n   *\n   * Defaults to true.\n   */\n  carts?: boolean | CartsConfig\n  /**\n   * Configure supported currencies and default settings.\n   *\n   * Defaults to supporting USD.\n   */\n  currencies?: CurrenciesConfig\n  /**\n   * Configure the target collection used for customers.\n   *\n   * @example\n   * ```ts\n   * customers: {\n   *  slug: 'users', // default\n   * }\n   *\n   */\n  customers: CustomersConfig\n  /**\n   * Enable tracking of inventory for products and variants. Accepts a config object to override the default collection settings.\n   *\n   * Defaults to true.\n   */\n  inventory?: boolean | InventoryConfig\n  /**\n   * Enables orders and accepts a config object to override the default collection settings.\n   *\n   * Defaults to true.\n   */\n  orders?: boolean | OrdersConfig\n  /**\n   * Enable tracking of payments. Accepts a config object to override the default collection settings.\n   *\n   * Defaults to true when the paymentMethods array is provided.\n   */\n  payments?: PaymentsConfig\n  /**\n   * Enables products and variants. Accepts a config object to override the product collection and each variant collection type.\n   *\n   * Defaults to true.\n   */\n  products?: boolean | ProductsConfig\n  /**\n   * Override the default slugs used across the plugin. This lets the plugin know which slugs to use for various internal operations and fields.\n   */\n  slugMap?: Partial<CollectionSlugMap>\n  /**\n   * Enable tracking of transactions. Accepts a config object to override the default collection settings.\n   *\n   * Defaults to true when the paymentMethods array is provided.\n   */\n  transactions?: boolean | TransactionsConfig\n}\n\nexport type SanitizedAccessConfig = Pick<AccessConfig, 'customerOnlyFieldAccess' | 'isCustomer'> &\n  Required<Omit<AccessConfig, 'customerOnlyFieldAccess' | 'isCustomer'>>\n\nexport type SanitizedEcommercePluginConfig = {\n  access: SanitizedAccessConfig\n  addresses: { addressFields: Field[] } & Omit<AddressesConfig, 'addressFields'>\n  currencies: Required<CurrenciesConfig>\n  inventory?: InventoryConfig\n  payments: {\n    paymentMethods: [] | PaymentAdapter[]\n  }\n} & Omit<\n  Required<EcommercePluginConfig>,\n  'access' | 'addresses' | 'currencies' | 'inventory' | 'payments'\n>\n\nexport type EcommerceCollections = TypedEcommerce['collections']\n\nexport type AddressesCollection = EcommerceCollections['addresses']\nexport type CartsCollection = EcommerceCollections['carts']\n\nexport type SyncLocalStorageConfig = {\n  /**\n   * Key to use for localStorage.\n   * Defaults to 'cart'.\n   */\n  key?: string\n}\n\ntype APIProps = {\n  /**\n   * The route for the Payload API, defaults to `/api`.\n   */\n  apiRoute?: string\n  /**\n   * Customise the query used to fetch carts. Use this when you need to fetch additional data and optimise queries using depth, select and populate.\n   *\n   * Defaults to `{ depth: 0 }`.\n   */\n  cartsFetchQuery?: {\n    depth?: number\n    populate?: PopulateType\n    select?: SelectType\n  }\n  /**\n   * The route for the Payload API, defaults to ``. Eg for a Payload app running on `http://localhost:3000`, the default serverURL would be `http://localhost:3000`.\n   */\n  serverURL?: string\n}\n\n/**\n * Memoized configuration object exposed via the useEcommerce hook.\n * Contains collection slugs and API settings for building URLs and queries.\n */\nexport type EcommerceConfig = {\n  /**\n   * The slug for the addresses collection.\n   */\n  addressesSlug: CollectionSlug\n  /**\n   * API configuration including the base route.\n   */\n  api: {\n    /**\n     * The base API route, e.g. '/api'.\n     */\n    apiRoute: string\n  }\n  /**\n   * The slug for the carts collection.\n   */\n  cartsSlug: CollectionSlug\n  /**\n   * The slug for the customers collection.\n   */\n  customersSlug: CollectionSlug\n}\n\nexport type ContextProps = {\n  /**\n   * The slug for the addresses collection.\n   *\n   * Defaults to 'addresses'.\n   */\n  addressesSlug?: CollectionSlug\n  api?: APIProps\n  /**\n   * The slug for the carts collection.\n   *\n   * Defaults to 'carts'.\n   */\n  cartsSlug?: CollectionSlug\n  children?: React.ReactNode\n  /**\n   * The configuration for currencies used in the ecommerce context.\n   * This is used to handle currency formatting and calculations, defaults to USD.\n   */\n  currenciesConfig?: CurrenciesConfig\n  /**\n   * The slug for the customers collection.\n   *\n   * Defaults to 'users'.\n   */\n  customersSlug?: CollectionSlug\n  /**\n   * Enable debug mode for the ecommerce context. This will log additional information to the console.\n   * Defaults to false.\n   */\n  debug?: boolean\n  /**\n   * Whether to enable support for variants in the cart.\n   * This allows adding products with specific variants to the cart.\n   * Defaults to false.\n   */\n  enableVariants?: boolean\n  /**\n   * Supported payment methods for the ecommerce context.\n   */\n  paymentMethods?: PaymentAdapterClient[]\n  /**\n   * Whether to enable localStorage for cart persistence.\n   * Defaults to true.\n   */\n  syncLocalStorage?: boolean | SyncLocalStorageConfig\n}\n\n/**\n * Type used internally to represent the cart item to be added.\n */\ntype CartItemArgument = {\n  /**\n   * The ID of the product to add to the cart. Always required.\n   */\n  product: DefaultDocumentIDType\n  /**\n   * The ID of the variant to add to the cart. Optional, if not provided, the product will be added without a variant.\n   */\n  variant?: DefaultDocumentIDType\n}\n\nexport type EcommerceContextType<T extends EcommerceCollections = EcommerceCollections> = {\n  /**\n   * Add an item to the cart.\n   */\n  addItem: (item: CartItemArgument, quantity?: number) => Promise<void>\n  /**\n   * All current addresses for the current user.\n   * This is used to manage shipping and billing addresses.\n   */\n  addresses?: T['addresses'][]\n  /**\n   * The current data of the cart.\n   */\n  cart?: T['addresses']\n  /**\n   * The ID of the current cart corresponding to the cart in the database or local storage.\n   */\n  cartID?: DefaultDocumentIDType\n  /**\n   * Clear the cart, removing all items.\n   */\n  clearCart: () => Promise<void>\n  /**\n   * Clears all ecommerce session data including cart, addresses, and user state.\n   * Should be called when a user logs out.\n   * This also clears localStorage cart data when syncLocalStorage is enabled.\n   */\n  clearSession: () => void\n  /**\n   * Memoized configuration object containing collection slugs and API settings.\n   * Use this to build URLs and queries with the correct collection slugs.\n   */\n  config: EcommerceConfig\n  /**\n   * Initiate a payment using the selected payment method.\n   * This method should be called after the cart is ready for checkout.\n   * It requires the payment method ID and any necessary payment data.\n   */\n  confirmOrder: (\n    paymentMethodID: string,\n    options?: { additionalData: Record<string, unknown> },\n  ) => Promise<unknown>\n  /**\n   * Create a new address by providing the data.\n   */\n  createAddress: (data: Partial<T['addresses']>) => Promise<void>\n  /**\n   * The configuration for the currencies used in the ecommerce context.\n   */\n  currenciesConfig: CurrenciesConfig\n  /**\n   * The currently selected currency used for the cart and price formatting automatically.\n   */\n  currency: Currency\n  /**\n   * Decrement an item in the cart by its array item ID.\n   * If quantity reaches 0, the item will be removed from the cart.\n   * @param item - The cart item ID (always a string, as array item IDs are strings in Payload)\n   */\n  decrementItem: (item: string) => Promise<void>\n  /**\n   * Increment an item in the cart by its array item ID.\n   * @param item - The cart item ID (always a string, as array item IDs are strings in Payload)\n   */\n  incrementItem: (item: string) => Promise<void>\n  /**\n   * Initiate a payment using the selected payment method.\n   * This method should be called after the cart is ready for checkout.\n   * It requires the payment method ID and any necessary payment data.\n   */\n  initiatePayment: (\n    paymentMethodID: string,\n    options?: { additionalData: Record<string, unknown> },\n  ) => Promise<unknown>\n  /**\n   * Indicates whether any cart operation is currently in progress.\n   * Useful for disabling buttons and preventing race conditions.\n   */\n  isLoading: boolean\n  /**\n   * Merges items from a source cart into a target cart.\n   * Useful for merging a guest cart into a user's existing cart after login.\n   *\n   * @param targetCartID - The ID of the cart to merge items into\n   * @param sourceCartID - The ID of the cart to merge items from\n   * @param sourceSecret - The secret for the source cart (required for guest carts)\n   * @returns The merged cart\n   */\n  mergeCart: (\n    targetCartID: DefaultDocumentIDType,\n    sourceCartID: DefaultDocumentIDType,\n    sourceSecret?: string,\n  ) => Promise<T['carts'] | void>\n  /**\n   * Called after a successful login to handle cart state.\n   * If a guest cart exists, it will be merged with the user's existing cart\n   * or assigned to the user if they have no cart.\n   * Cart secrets are cleared as authenticated users don't need them.\n   *\n   * @returns Promise that resolves when cart state is properly set up for the user.\n   */\n  onLogin: () => Promise<void>\n  /**\n   * Called during logout to clear all ecommerce session data.\n   * Clears cart, addresses, user state, and localStorage cart data.\n   * This is an alias for clearSession() but named for semantic clarity.\n   */\n  onLogout: () => void\n  paymentMethods: PaymentAdapterClient[]\n  /**\n   * Refresh the cart.\n   */\n  refreshCart: () => Promise<void>\n  /**\n   * Remove an item from the cart by its array item ID.\n   * @param item - The cart item ID (always a string, as array item IDs are strings in Payload)\n   */\n  removeItem: (item: string) => Promise<void>\n  /**\n   * The name of the currently selected payment method.\n   * This is used to determine which payment method to use when initiating a payment.\n   */\n  selectedPaymentMethod?: null | string\n  /**\n   * Change the currency for the cart, it defaults to the configured currency.\n   * This will update the currency used for pricing and calculations.\n   */\n  setCurrency: (currency: string) => void\n  /**\n   * Update an address by providing the data and the ID.\n   */\n  updateAddress: (addressID: DefaultDocumentIDType, data: Partial<T['addresses']>) => Promise<void>\n  /**\n   * The current authenticated user, or null if not logged in.\n   */\n  user: null | TypedUser\n}\n"],"names":[],"mappings":"AAo5BA,WAwIC"}