{"version":3,"sources":["../../../../src/collections/carts/operations/mergeCart.ts"],"sourcesContent":["import type { CollectionSlug, DefaultDocumentIDType, Payload, PayloadRequest } from 'payload'\n\nimport type { CartItemData, CartOperationResult } from './types.js'\n\n/**\n * Gets the ID from a product/variant field which can be either an ID or a populated object.\n */\nconst getItemID = (\n  field:\n    | { [key: string]: unknown; id: DefaultDocumentIDType }\n    | DefaultDocumentIDType\n    | null\n    | undefined,\n): DefaultDocumentIDType | undefined => {\n  if (!field) {\n    return undefined\n  }\n  return typeof field === 'object' ? field.id : field\n}\n\n/**\n * Default matcher for merge operations - compares normalized product and variant IDs.\n */\nconst defaultMergeItemMatcher = (args: {\n  existingItem: CartItemData\n  newItem: CartItemData\n}): boolean => {\n  const { existingItem, newItem } = args\n\n  const existingProductID = getItemID(existingItem.product)\n  const newProductID = getItemID(newItem.product)\n\n  if (existingProductID !== newProductID) {\n    return false\n  }\n\n  const existingVariantID = getItemID(existingItem.variant)\n  const newVariantID = getItemID(newItem.variant)\n\n  return existingVariantID === newVariantID\n}\n\nexport type MergeCartArgs = {\n  /**\n   * Optional custom cart item matcher function for merge operations.\n   * Both items are CartItemData (existing cart items).\n   */\n  cartItemMatcher?: (args: { existingItem: CartItemData; newItem: CartItemData }) => boolean\n  /**\n   * The collection slug for carts.\n   */\n  cartsSlug: CollectionSlug\n  /**\n   * The Payload instance.\n   */\n  payload: Payload\n  /**\n   * The PayloadRequest object for transaction safety.\n   */\n  req?: PayloadRequest\n  /**\n   * The ID of the source (guest) cart to merge from.\n   */\n  sourceCartID: DefaultDocumentIDType\n  /**\n   * The secret for accessing the source guest cart.\n   */\n  sourceSecret: string\n  /**\n   * The ID of the target (user's) cart to merge into.\n   */\n  targetCartID: DefaultDocumentIDType\n}\n\n/**\n * Merges items from a source cart (typically a guest cart) into a target cart (typically a user's cart).\n * Items are merged intelligently - matching items have their quantities combined.\n * After successful merge, the source cart is deleted.\n *\n * @example\n * ```ts\n * const result = await mergeCart({\n *   payload,\n *   cartsSlug: 'carts',\n *   targetCartID: 'user-cart-123',\n *   sourceCartID: 'guest-cart-456',\n *   sourceSecret: 'abc123secret',\n * })\n * ```\n */\nexport const mergeCart = async (args: MergeCartArgs): Promise<CartOperationResult> => {\n  const {\n    cartItemMatcher = defaultMergeItemMatcher,\n    cartsSlug,\n    payload,\n    req,\n    sourceCartID,\n    sourceSecret,\n    targetCartID,\n  } = args\n\n  // Fetch the source (guest) cart with secret verification\n  // Using overrideAccess: true here because we're manually verifying the secret in the where clause\n  const sourceCart = await payload.find({\n    collection: cartsSlug,\n    depth: 0,\n    limit: 1,\n    overrideAccess: true,\n    req,\n    where: {\n      and: [{ id: { equals: sourceCartID } }, { secret: { equals: sourceSecret } }],\n    },\n  })\n\n  if (!sourceCart.docs || sourceCart.docs.length === 0) {\n    return {\n      cart: null,\n      message: `Source cart with ID ${sourceCartID} not found or secret mismatch`,\n      success: false,\n    }\n  }\n\n  const guestCart = sourceCart.docs[0]\n\n  // Fetch the target (user's) cart\n  const targetCart = await payload.findByID({\n    id: targetCartID,\n    collection: cartsSlug,\n    depth: 0,\n    overrideAccess: false,\n    req,\n  })\n\n  if (!targetCart) {\n    return {\n      cart: null,\n      message: `Target cart with ID ${targetCartID} not found`,\n      success: false,\n    }\n  }\n\n  const sourceItems: CartItemData[] = (guestCart?.items as CartItemData[]) || []\n  const targetItems: CartItemData[] = (targetCart.items as CartItemData[]) || []\n\n  // Merge items from source into target\n  const mergedItems: CartItemData[] = [...targetItems]\n\n  for (const sourceItem of sourceItems) {\n    // Find if this item already exists in target cart\n    const existingIndex = mergedItems.findIndex((targetItem) =>\n      cartItemMatcher({ existingItem: targetItem, newItem: sourceItem }),\n    )\n\n    if (existingIndex !== -1) {\n      // Item exists in target - add quantities\n      const existingItem = mergedItems[existingIndex]!\n      mergedItems[existingIndex] = {\n        ...existingItem,\n        quantity: existingItem.quantity + sourceItem.quantity,\n      }\n    } else {\n      // Item doesn't exist in target - add it\n      // Omit the source item's array row `id` so Payload generates a new one.\n      // In SQL, array items are stored in separate tables with their own IDs,\n      // and using IDs from another cart's array would cause conflicts.\n      const { id: _omit, ...sourceItemWithoutId } = sourceItem\n      mergedItems.push(sourceItemWithoutId as CartItemData)\n    }\n  }\n\n  // Update the target cart with merged items\n  const updatedCart = await payload.update({\n    id: targetCartID,\n    collection: cartsSlug,\n    data: {\n      items: mergedItems,\n    },\n    depth: 0,\n    overrideAccess: false,\n    req,\n  })\n\n  // Delete the source (guest) cart after successful merge\n  // Using overrideAccess: true because we've already verified the secret above\n  try {\n    await payload.delete({\n      id: sourceCartID,\n      collection: cartsSlug,\n      overrideAccess: true,\n      req,\n    })\n  } catch {\n    // Silently fail on delete - the merge was still successful\n    // The cart may have already been deleted or access denied\n  }\n\n  return {\n    cart: updatedCart,\n    message: `Merged ${sourceItems.length} items from guest cart`,\n    success: true,\n  }\n}\n"],"names":["getItemID","field","undefined","id","defaultMergeItemMatcher","args","existingItem","newItem","existingProductID","product","newProductID","existingVariantID","variant","newVariantID","mergeCart","cartItemMatcher","cartsSlug","payload","req","sourceCartID","sourceSecret","targetCartID","sourceCart","find","collection","depth","limit","overrideAccess","where","and","equals","secret","docs","length","cart","message","success","guestCart","targetCart","findByID","sourceItems","items","targetItems","mergedItems","sourceItem","existingIndex","findIndex","targetItem","quantity","_omit","sourceItemWithoutId","push","updatedCart","update","data","delete"],"mappings":"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"}