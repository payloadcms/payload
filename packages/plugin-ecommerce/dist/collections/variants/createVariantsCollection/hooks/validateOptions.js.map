{"version":3,"sources":["../../../../../src/collections/variants/createVariantsCollection/hooks/validateOptions.ts"],"sourcesContent":["import type { Validate } from 'payload'\n\ntype Props = {\n  productsCollectionSlug?: string\n}\n\nexport const validateOptions: (props?: Props) => Validate =\n  (props) =>\n  async (values, { data, req }) => {\n    const { productsCollectionSlug = 'products' } = props || {}\n    const { t } = req\n\n    if (!values || values.length === 0) {\n      // @ts-expect-error - TODO: Fix types\n      return t('ecommerce:variantOptionsRequired')\n    }\n\n    const productID = data.product\n\n    if (!productID) {\n      // @ts-expect-error - TODO: Fix types\n      return t('ecommerce:productRequired')\n    }\n\n    const product = await req.payload.findByID({\n      id: productID,\n      collection: productsCollectionSlug,\n      depth: 1,\n      joins: {\n        variants: {\n          where: {\n            ...(data.id && {\n              id: {\n                not_equals: data.id, // exclude the current variant from the search\n              },\n            }),\n          },\n        },\n      },\n      select: {\n        variants: true,\n        variantTypes: true,\n      },\n      user: req.user,\n    })\n\n    // @ts-expect-error - TODO: Fix types\n    const variants = product.variants?.docs ?? []\n\n    // @ts-expect-error - TODO: Fix types\n    if (values.length < product?.variantTypes?.length) {\n      // @ts-expect-error - TODO: Fix types\n      return t('ecommerce:variantOptionsRequiredAll')\n    }\n\n    if (variants.length > 0) {\n      const existingOptions: (number | string)[][] = []\n\n      variants.forEach((variant: any) => {\n        existingOptions.push(variant.options)\n      })\n\n      const exists = existingOptions.some(\n        (combo) => combo.length === values.length && combo.every((val) => values.includes(val)),\n      )\n\n      if (exists) {\n        // @ts-expect-error - TODO: Fix types\n        return t('ecommerce:variantOptionsAlreadyExists')\n      }\n    }\n\n    return true\n  }\n"],"names":["validateOptions","props","values","data","req","productsCollectionSlug","t","length","productID","product","payload","findByID","id","collection","depth","joins","variants","where","not_equals","select","variantTypes","user","docs","existingOptions","forEach","variant","push","options","exists","some","combo","every","val","includes"],"mappings":"AAMA,OAAO,MAAMA,kBACX,CAACC,QACD,OAAOC,QAAQ,EAAEC,IAAI,EAAEC,GAAG,EAAE;QAC1B,MAAM,EAAEC,yBAAyB,UAAU,EAAE,GAAGJ,SAAS,CAAC;QAC1D,MAAM,EAAEK,CAAC,EAAE,GAAGF;QAEd,IAAI,CAACF,UAAUA,OAAOK,MAAM,KAAK,GAAG;YAClC,qCAAqC;YACrC,OAAOD,EAAE;QACX;QAEA,MAAME,YAAYL,KAAKM,OAAO;QAE9B,IAAI,CAACD,WAAW;YACd,qCAAqC;YACrC,OAAOF,EAAE;QACX;QAEA,MAAMG,UAAU,MAAML,IAAIM,OAAO,CAACC,QAAQ,CAAC;YACzCC,IAAIJ;YACJK,YAAYR;YACZS,OAAO;YACPC,OAAO;gBACLC,UAAU;oBACRC,OAAO;wBACL,GAAId,KAAKS,EAAE,IAAI;4BACbA,IAAI;gCACFM,YAAYf,KAAKS,EAAE;4BACrB;wBACF,CAAC;oBACH;gBACF;YACF;YACAO,QAAQ;gBACNH,UAAU;gBACVI,cAAc;YAChB;YACAC,MAAMjB,IAAIiB,IAAI;QAChB;QAEA,qCAAqC;QACrC,MAAML,WAAWP,QAAQO,QAAQ,EAAEM,QAAQ,EAAE;QAE7C,qCAAqC;QACrC,IAAIpB,OAAOK,MAAM,GAAGE,SAASW,cAAcb,QAAQ;YACjD,qCAAqC;YACrC,OAAOD,EAAE;QACX;QAEA,IAAIU,SAAST,MAAM,GAAG,GAAG;YACvB,MAAMgB,kBAAyC,EAAE;YAEjDP,SAASQ,OAAO,CAAC,CAACC;gBAChBF,gBAAgBG,IAAI,CAACD,QAAQE,OAAO;YACtC;YAEA,MAAMC,SAASL,gBAAgBM,IAAI,CACjC,CAACC,QAAUA,MAAMvB,MAAM,KAAKL,OAAOK,MAAM,IAAIuB,MAAMC,KAAK,CAAC,CAACC,MAAQ9B,OAAO+B,QAAQ,CAACD;YAGpF,IAAIJ,QAAQ;gBACV,qCAAqC;gBACrC,OAAOtB,EAAE;YACX;QACF;QAEA,OAAO;IACT,EAAC"}