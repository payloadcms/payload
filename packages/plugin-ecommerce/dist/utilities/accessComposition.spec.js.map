{"version":3,"sources":["../../src/utilities/accessComposition.spec.ts"],"sourcesContent":["import { describe, it, expect } from 'vitest'\nimport type { Access, AccessArgs, Where } from 'payload'\n\nimport { accessAND, conditional, accessOR } from './accessComposition'\n\n// Mock access args for testing\nconst mockArgs: AccessArgs = {\n  req: {\n    user: null,\n    headers: new Headers(),\n    payload: {} as any,\n    context: {},\n  } as any,\n}\n\nconst mockArgsWithUser: AccessArgs = {\n  req: {\n    user: { id: '123', email: 'test@example.com' },\n    headers: new Headers(),\n    payload: {} as any,\n    context: {},\n  } as any,\n}\n\ndescribe('Access Composition Utilities', () => {\n  describe('or', () => {\n    it('should return true when first checker returns true', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => false\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return true when any checker returns true', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => true\n      const checker3: Access = async () => false\n\n      const result = await accessOR(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return false when all checkers return false', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => false\n      const checker3: Access = async () => false\n\n      const result = await accessOR(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should combine Where queries with OR logic', async () => {\n      const checker1: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker2: Access = async () => ({\n        status: { equals: 'published' },\n      })\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      expect(result).toEqual({\n        or: [{ customer: { equals: '123' } }, { status: { equals: 'published' } }],\n      })\n    })\n\n    it('should return true when one checker returns true and others return Where queries', async () => {\n      const checker1: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker2: Access = async () => true\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should ignore false values when combining Where queries', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker3: Access = async () => false\n      const checker4: Access = async () => ({\n        status: { equals: 'published' },\n      })\n\n      const result = await accessOR(checker1, checker2, checker3, checker4)(mockArgs)\n\n      expect(result).toEqual({\n        or: [{ customer: { equals: '123' } }, { status: { equals: 'published' } }],\n      })\n    })\n\n    it('should return a single Where query when only one checker returns a Where query', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker3: Access = async () => false\n\n      const result = await accessOR(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toEqual({\n        or: [{ customer: { equals: '123' } }],\n      })\n    })\n\n    it('should short-circuit on first true result for performance', async () => {\n      let secondCheckerCalled = false\n\n      const checker1: Access = async () => true\n      const checker2: Access = async () => {\n        secondCheckerCalled = true\n        return false\n      }\n\n      await accessOR(checker1, checker2)(mockArgs)\n\n      expect(secondCheckerCalled).toBe(false)\n    })\n\n    it('should handle empty checkers array', async () => {\n      const result = await accessOR()(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should handle complex nested Where queries', async () => {\n      const checker1: Access = async () =>\n        ({\n          and: [{ customer: { equals: '123' } }, { status: { equals: 'active' } }],\n        }) as Where\n      const checker2: Access = async () => ({\n        role: { equals: 'admin' },\n      })\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      expect(result).toEqual({\n        or: [\n          { and: [{ customer: { equals: '123' } }, { status: { equals: 'active' } }] },\n          { role: { equals: 'admin' } },\n        ],\n      })\n    })\n  })\n\n  describe('and', () => {\n    it('should return false when any checker returns false', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => false\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should return true when all checkers return true', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => true\n      const checker3: Access = async () => true\n\n      const result = await accessAND(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should combine Where queries with AND logic', async () => {\n      const checker1: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker2: Access = async () => ({\n        status: { equals: 'published' },\n      })\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toEqual({\n        and: [{ customer: { equals: '123' } }, { status: { equals: 'published' } }],\n      })\n    })\n\n    it('should return false when one checker returns false and others return Where queries', async () => {\n      const checker1: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker2: Access = async () => false\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should return Where query when all checkers return Where queries except one returns true', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker3: Access = async () => ({\n        status: { equals: 'published' },\n      })\n\n      const result = await accessAND(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toEqual({\n        and: [{ customer: { equals: '123' } }, { status: { equals: 'published' } }],\n      })\n    })\n\n    it('should short-circuit on first false result for performance', async () => {\n      let secondCheckerCalled = false\n\n      const checker1: Access = async () => false\n      const checker2: Access = async () => {\n        secondCheckerCalled = true\n        return true\n      }\n\n      await accessAND(checker1, checker2)(mockArgs)\n\n      expect(secondCheckerCalled).toBe(false)\n    })\n\n    it('should handle empty checkers array', async () => {\n      const result = await accessAND()(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return a single Where query when only one checker returns a Where query', async () => {\n      const checker1: Access = async () => true\n      const checker2: Access = async () => ({\n        customer: { equals: '123' },\n      })\n      const checker3: Access = async () => true\n\n      const result = await accessAND(checker1, checker2, checker3)(mockArgs)\n\n      expect(result).toEqual({\n        and: [{ customer: { equals: '123' } }],\n      })\n    })\n\n    it('should handle complex nested Where queries', async () => {\n      const checker1: Access = async () => ({\n        or: [{ customer: { equals: '123' } }, { customer: { equals: '456' } }],\n      })\n      const checker2: Access = async () => ({\n        status: { equals: 'active' },\n      })\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toEqual({\n        and: [\n          { or: [{ customer: { equals: '123' } }, { customer: { equals: '456' } }] },\n          { status: { equals: 'active' } },\n        ],\n      })\n    })\n\n    it('should return false immediately when first checker returns false', async () => {\n      const checker1: Access = async () => false\n      const checker2: Access = async () => {\n        throw new Error('Should not be called')\n      }\n\n      const result = await accessAND(checker1, checker2)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n  })\n\n  describe('conditional', () => {\n    it('should apply checker when condition is true', async () => {\n      const checker: Access = async () => true\n\n      const result = await conditional(true, checker)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return false when condition is false', async () => {\n      const checker: Access = async () => true\n\n      const result = await conditional(false, checker)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should apply checker when condition function returns true', async () => {\n      const condition = ({ req }: AccessArgs) => !!req.user\n      const checker: Access = async () => true\n\n      const result = await conditional(condition, checker)(mockArgsWithUser)\n\n      expect(result).toBe(true)\n    })\n\n    it('should return false when condition function returns false', async () => {\n      const condition = ({ req }: AccessArgs) => !!req.user\n      const checker: Access = async () => true\n\n      const result = await conditional(condition, checker)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n\n    it('should pass Where query through when condition is true', async () => {\n      const checker: Access = async () => ({\n        customer: { equals: '123' },\n      })\n\n      const result = await conditional(true, checker)(mockArgs)\n\n      expect(result).toEqual({\n        customer: { equals: '123' },\n      })\n    })\n\n    it('should not call checker when condition is false', async () => {\n      let checkerCalled = false\n\n      const checker: Access = async () => {\n        checkerCalled = true\n        return true\n      }\n\n      await conditional(false, checker)(mockArgs)\n\n      expect(checkerCalled).toBe(false)\n    })\n\n    it('should evaluate condition function each time', async () => {\n      const condition = ({ req }: AccessArgs) => !!req.user\n      const checker: Access = async () => true\n\n      // First call without user\n      const result1 = await conditional(condition, checker)(mockArgs)\n      expect(result1).toBe(false)\n\n      // Second call with user\n      const result2 = await conditional(condition, checker)(mockArgsWithUser)\n      expect(result2).toBe(true)\n    })\n\n    it('should work with false checker result when condition is true', async () => {\n      const checker: Access = async () => false\n\n      const result = await conditional(true, checker)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n  })\n\n  describe('combined composition', () => {\n    it('should compose or, and, and conditional together', async () => {\n      const isAdmin: Access = async ({ req }) => req.user?.role === 'admin'\n      const isOwner: Access = async ({ req }) => ({\n        customer: { equals: req.user?.id },\n      })\n      const isGuest: Access = async ({ req }) => !req.user\n\n      const allowGuestCarts = true\n\n      const access = accessOR(isAdmin, accessAND(isOwner), conditional(allowGuestCarts, isGuest))\n\n      // Guest user (no user)\n      const guestResult = await access(mockArgs)\n      expect(guestResult).toBe(true)\n\n      // Admin user\n      const adminResult = await access({\n        req: {\n          user: { id: '123', role: 'admin' },\n          headers: new Headers(),\n          payload: {} as any,\n          context: {},\n        } as any,\n      })\n      expect(adminResult).toBe(true)\n\n      // Regular user (owner)\n      const ownerResult = await access({\n        req: {\n          user: { id: '123', role: 'customer' },\n          headers: new Headers(),\n          payload: {} as any,\n          context: {},\n        } as any,\n      })\n      expect(ownerResult).toEqual({\n        or: [{ and: [{ customer: { equals: '123' } }] }],\n      })\n    })\n\n    it('should handle complex nested compositions', async () => {\n      const checker1: Access = async () => ({\n        status: { equals: 'published' },\n      })\n      const checker2: Access = async () => ({\n        visibility: { equals: 'public' },\n      })\n      const checker3: Access = async ({ req }) => !!req.user\n      const checker4: Access = async () => ({\n        customer: { equals: '123' },\n      })\n\n      // ((published AND public) OR (authenticated AND customer=123))\n      const access = accessOR(accessAND(checker1, checker2), accessAND(checker3, checker4))\n\n      // Without user\n      const result1 = await access(mockArgs)\n      expect(result1).toEqual({\n        or: [\n          {\n            and: [{ status: { equals: 'published' } }, { visibility: { equals: 'public' } }],\n          },\n        ],\n      })\n\n      // With user\n      const result2 = await access(mockArgsWithUser)\n      expect(result2).toEqual({\n        or: [\n          {\n            and: [{ status: { equals: 'published' } }, { visibility: { equals: 'public' } }],\n          },\n          {\n            and: [{ customer: { equals: '123' } }],\n          },\n        ],\n      })\n    })\n\n    it('should handle conditional inside or composition', async () => {\n      const isAdmin: Access = async () => false\n      const isGuest: Access = async () => true\n      const allowGuestAccess = true\n\n      const access = accessOR(isAdmin, conditional(allowGuestAccess, isGuest))\n\n      const result = await access(mockArgs)\n      expect(result).toBe(true)\n    })\n\n    it('should handle conditional inside and composition', async () => {\n      const hasPermission: Access = async () => ({\n        permissions: { contains: 'read' },\n      })\n      const isActiveUser: Access = async () => true\n      const featureFlagEnabled = true\n\n      const access = accessAND(hasPermission, conditional(featureFlagEnabled, isActiveUser))\n\n      const result = await access(mockArgs)\n      expect(result).toEqual({\n        and: [{ permissions: { contains: 'read' } }],\n      })\n    })\n\n    it('should correctly handle multiple levels of nesting', async () => {\n      const a: Access = async () => true\n      const b: Access = async () => false\n      const c: Access = async () => ({ field1: { equals: 'value1' } })\n      const d: Access = async () => ({ field2: { equals: 'value2' } })\n\n      // (a AND (b OR (c AND d)))\n      const access = accessAND(a, accessOR(b, accessAND(c, d)))\n\n      const result = await access(mockArgs)\n      expect(result).toEqual({\n        and: [\n          { or: [{ and: [{ field1: { equals: 'value1' } }, { field2: { equals: 'value2' } }] }] },\n        ],\n      })\n    })\n  })\n\n  describe('edge cases and failure scenarios', () => {\n    it('should handle checker that throws an error', async () => {\n      const checker1: Access = async () => {\n        throw new Error('Access check failed')\n      }\n      const checker2: Access = async () => true\n\n      await expect(accessOR(checker1, checker2)(mockArgs)).rejects.toThrow('Access check failed')\n    })\n\n    it('should handle null or undefined returns gracefully', async () => {\n      const checker1: Access = async () => null as any\n      const checker2: Access = async () => undefined as any\n      const checker3: Access = async () => true\n\n      const result = await accessOR(checker1, checker2, checker3)(mockArgs)\n      expect(result).toBe(true)\n    })\n\n    it('should handle deeply nested Where queries', async () => {\n      const checker: Access = async () =>\n        ({\n          and: [\n            {\n              or: [\n                { field1: { equals: 'value1' } },\n                {\n                  and: [{ field2: { equals: 'value2' } }, { field3: { equals: 'value3' } }],\n                },\n              ],\n            },\n            { field4: { not_equals: 'value4' } },\n          ],\n        }) as Where\n\n      const result = await accessOR(checker)(mockArgs)\n\n      expect(result).toEqual({\n        or: [\n          {\n            and: [\n              {\n                or: [\n                  { field1: { equals: 'value1' } },\n                  {\n                    and: [{ field2: { equals: 'value2' } }, { field3: { equals: 'value3' } }],\n                  },\n                ],\n              },\n              { field4: { not_equals: 'value4' } },\n            ],\n          },\n        ],\n      })\n    })\n\n    it('should handle all checkers returning null/undefined', async () => {\n      const checker1: Access = async () => null as any\n      const checker2: Access = async () => undefined as any\n\n      const result = await accessOR(checker1, checker2)(mockArgs)\n\n      // null and undefined should be treated as false\n      expect(result).toBe(false)\n    })\n\n    it('should handle Where query with empty object', async () => {\n      const checker: Access = async () => ({}) as Where\n\n      const result = await accessOR(checker)(mockArgs)\n\n      expect(result).toEqual({})\n    })\n\n    it('should handle conditional with complex condition function', async () => {\n      const condition = ({ req }: AccessArgs): boolean => {\n        return !!(req.user && req.user.email && req.user.email.endsWith('@admin.com'))\n      }\n\n      const checker: Access = async () => true\n\n      // Non-admin email\n      const result1 = await conditional(\n        condition,\n        checker,\n      )({\n        req: {\n          user: { id: '123', email: 'user@example.com' },\n          headers: new Headers(),\n          payload: {} as any,\n          context: {},\n        } as any,\n      })\n      expect(result1).toBe(false)\n\n      // Admin email\n      const result2 = await conditional(\n        condition,\n        checker,\n      )({\n        req: {\n          user: { id: '123', email: 'admin@admin.com' },\n          headers: new Headers(),\n          payload: {} as any,\n          context: {},\n        } as any,\n      })\n      expect(result2).toBe(true)\n    })\n\n    it('should handle alternating true/false in or correctly', async () => {\n      const checkers: Access[] = [\n        async () => false,\n        async () => false,\n        async () => false,\n        async () => true, // This should cause short-circuit\n        async () => {\n          throw new Error('Should not be called')\n        },\n      ]\n\n      const result = await accessOR(...checkers)(mockArgs)\n\n      expect(result).toBe(true)\n    })\n\n    it('should handle alternating true/false in and correctly', async () => {\n      const checkers: Access[] = [\n        async () => true,\n        async () => true,\n        async () => false, // This should cause short-circuit\n        async () => {\n          throw new Error('Should not be called')\n        },\n      ]\n\n      const result = await accessAND(...checkers)(mockArgs)\n\n      expect(result).toBe(false)\n    })\n  })\n})\n"],"names":["describe","it","expect","accessAND","conditional","accessOR","mockArgs","req","user","headers","Headers","payload","context","mockArgsWithUser","id","email","checker1","checker2","result","toBe","checker3","customer","equals","status","toEqual","or","checker4","secondCheckerCalled","and","role","Error","checker","condition","checkerCalled","result1","result2","isAdmin","isOwner","isGuest","allowGuestCarts","access","guestResult","adminResult","ownerResult","visibility","allowGuestAccess","hasPermission","permissions","contains","isActiveUser","featureFlagEnabled","a","b","c","field1","d","field2","rejects","toThrow","undefined","field3","field4","not_equals","endsWith","checkers"],"mappings":"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"}