{"version":3,"sources":["../../src/fields/getFields.ts"],"sourcesContent":["import type { CollectionConfig, Field, GroupField, TextField } from 'payload'\n\nimport path from 'path'\n\nimport type { GeneratedAdapter, GenerateFileURL } from '../types.js'\n\nimport { getAfterReadHook } from '../hooks/afterRead.js'\n\ninterface Args {\n  adapter?: GeneratedAdapter\n  /**\n   * When true, always insert the prefix field regardless of whether a prefix is configured.\n   */\n  alwaysInsertFields?: boolean\n  collection: CollectionConfig\n  disablePayloadAccessControl?: true\n  generateFileURL?: GenerateFileURL\n  prefix?: string\n}\n\nexport const getFields = ({\n  adapter,\n  alwaysInsertFields,\n  collection,\n  disablePayloadAccessControl,\n  generateFileURL,\n  prefix,\n}: Args): Field[] => {\n  const baseURLField: TextField = {\n    name: 'url',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'URL',\n  }\n\n  const basePrefixField: TextField = {\n    name: 'prefix',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n  }\n\n  const fields = [...collection.fields, ...(adapter?.fields || [])]\n\n  // Inject a hook into all URL fields to generate URLs\n\n  let existingURLFieldIndex = -1\n\n  const existingURLField = fields.find((existingField, i) => {\n    if ('name' in existingField && existingField.name === 'url') {\n      existingURLFieldIndex = i\n      return true\n    }\n    return false\n  }) as TextField\n\n  if (existingURLFieldIndex > -1) {\n    fields.splice(existingURLFieldIndex, 1)\n  }\n\n  // Only add afterRead hook if adapter is provided\n  if (adapter) {\n    fields.push({\n      ...baseURLField,\n      ...(existingURLField || {}),\n      hooks: {\n        afterRead: [\n          getAfterReadHook({ adapter, collection, disablePayloadAccessControl, generateFileURL }),\n          ...(existingURLField?.hooks?.afterRead || []),\n        ],\n      },\n    } as TextField)\n  } else {\n    fields.push({\n      ...baseURLField,\n      ...(existingURLField || {}),\n    } as TextField)\n  }\n\n  if (typeof collection.upload === 'object' && collection.upload.imageSizes) {\n    let existingSizesFieldIndex = -1\n\n    const existingSizesField = fields.find((existingField, i) => {\n      if ('name' in existingField && existingField.name === 'sizes') {\n        existingSizesFieldIndex = i\n        return true\n      }\n\n      return false\n    }) as GroupField\n\n    if (existingSizesFieldIndex > -1) {\n      fields.splice(existingSizesFieldIndex, 1)\n    }\n\n    const sizesField: Field = {\n      ...(existingSizesField || {}),\n      name: 'sizes',\n      type: 'group',\n      admin: {\n        hidden: true,\n      },\n      fields: collection.upload.imageSizes.map((size) => {\n        const existingSizeField = existingSizesField?.fields.find(\n          (existingField) => 'name' in existingField && existingField.name === size.name,\n        ) as GroupField\n\n        const existingSizeURLField = existingSizeField?.fields.find(\n          (existingField) => 'name' in existingField && existingField.name === 'url',\n        ) as TextField\n\n        // Only add afterRead hook if adapter is provided\n        const sizeURLField: TextField = adapter\n          ? ({\n              ...(existingSizeURLField || {}),\n              ...baseURLField,\n              hooks: {\n                afterRead: [\n                  getAfterReadHook({\n                    adapter,\n                    collection,\n                    disablePayloadAccessControl,\n                    generateFileURL,\n                    size,\n                  }),\n                  ...((typeof existingSizeURLField === 'object' &&\n                    'hooks' in existingSizeURLField &&\n                    existingSizeURLField?.hooks?.afterRead) ||\n                    []),\n                ],\n              },\n            } as TextField)\n          : ({\n              ...(existingSizeURLField || {}),\n              ...baseURLField,\n            } as TextField)\n\n        return {\n          ...existingSizeField,\n          name: size.name,\n          type: 'group',\n          fields: [...(adapter?.fields || []), sizeURLField],\n        } as Field\n      }),\n    }\n\n    fields.push(sizesField)\n  }\n\n  // If prefix is enabled or alwaysInsertFields is true, save it to db\n  if (typeof prefix !== 'undefined' || alwaysInsertFields) {\n    let existingPrefixFieldIndex = -1\n\n    const existingPrefixField = fields.find((existingField, i) => {\n      if ('name' in existingField && existingField.name === 'prefix') {\n        existingPrefixFieldIndex = i\n        return true\n      }\n      return false\n    }) as TextField\n\n    if (existingPrefixFieldIndex > -1) {\n      fields.splice(existingPrefixFieldIndex, 1)\n    }\n\n    fields.push({\n      ...basePrefixField,\n      ...(existingPrefixField || {}),\n      defaultValue: prefix ? path.posix.join(prefix) : '',\n    } as TextField)\n  }\n\n  return fields\n}\n"],"names":["path","getAfterReadHook","getFields","adapter","alwaysInsertFields","collection","disablePayloadAccessControl","generateFileURL","prefix","baseURLField","name","type","admin","hidden","readOnly","label","basePrefixField","fields","existingURLFieldIndex","existingURLField","find","existingField","i","splice","push","hooks","afterRead","upload","imageSizes","existingSizesFieldIndex","existingSizesField","sizesField","map","size","existingSizeField","existingSizeURLField","sizeURLField","existingPrefixFieldIndex","existingPrefixField","defaultValue","posix","join"],"mappings":"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"}