{"version":3,"sources":["../../../src/admin/fields/getFields.ts"],"sourcesContent":["import type { CollectionConfig, Field, GroupField, TextField } from 'payload'\n\nimport path from 'path'\n\ninterface Args {\n  /**\n   * When true, always insert the prefix field regardless of whether a prefix is configured.\n   */\n  alwaysInsertFields?: boolean\n  collection: CollectionConfig\n  prefix?: string\n}\n\nexport const getFields = ({ alwaysInsertFields, collection, prefix }: Args): Field[] => {\n  const baseURLField: TextField = {\n    name: 'url',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n    label: 'URL',\n  }\n\n  const basePrefixField: TextField = {\n    name: 'prefix',\n    type: 'text',\n    admin: {\n      hidden: true,\n      readOnly: true,\n    },\n  }\n\n  const fields = [...collection.fields]\n\n  // Inject a hook into all URL fields to generate URLs\n\n  let existingURLFieldIndex = -1\n\n  const existingURLField = fields.find((existingField, i) => {\n    if ('name' in existingField && existingField.name === 'url') {\n      existingURLFieldIndex = i\n      return true\n    }\n    return false\n  }) as TextField\n\n  if (existingURLFieldIndex > -1) {\n    fields.splice(existingURLFieldIndex, 1)\n  }\n\n  fields.push({\n    ...baseURLField,\n    ...(existingURLField || {}),\n  } as TextField)\n\n  if (typeof collection.upload === 'object' && collection.upload.imageSizes) {\n    let existingSizesFieldIndex = -1\n\n    const existingSizesField = fields.find((existingField, i) => {\n      if ('name' in existingField && existingField.name === 'sizes') {\n        existingSizesFieldIndex = i\n        return true\n      }\n\n      return false\n    }) as GroupField\n\n    if (existingSizesFieldIndex > -1) {\n      fields.splice(existingSizesFieldIndex, 1)\n    }\n\n    const sizesField: Field = {\n      ...(existingSizesField || {}),\n      name: 'sizes',\n      type: 'group',\n      admin: {\n        hidden: true,\n      },\n      fields: collection.upload.imageSizes.map((size) => {\n        const existingSizeField = existingSizesField?.fields.find(\n          (existingField) => 'name' in existingField && existingField.name === size.name,\n        ) as GroupField\n\n        const existingSizeURLField = existingSizeField?.fields.find(\n          (existingField) => 'name' in existingField && existingField.name === 'url',\n        ) as GroupField\n\n        return {\n          ...existingSizeField,\n          name: size.name,\n          type: 'group',\n          fields: [\n            {\n              ...(existingSizeURLField || {}),\n              ...baseURLField,\n            },\n          ],\n        } as Field\n      }),\n    }\n\n    fields.push(sizesField)\n  }\n\n  // If prefix is enabled or alwaysInsertFields is true, save it to db\n  if (typeof prefix !== 'undefined' || alwaysInsertFields) {\n    let existingPrefixFieldIndex = -1\n\n    const existingPrefixField = fields.find((existingField, i) => {\n      if ('name' in existingField && existingField.name === 'prefix') {\n        existingPrefixFieldIndex = i\n        return true\n      }\n      return false\n    }) as TextField\n\n    if (existingPrefixFieldIndex > -1) {\n      fields.splice(existingPrefixFieldIndex, 1)\n    }\n\n    fields.push({\n      ...basePrefixField,\n      ...(existingPrefixField || {}),\n      defaultValue: prefix ? path.posix.join(prefix) : '',\n    } as TextField)\n  }\n\n  return fields\n}\n"],"names":["path","getFields","alwaysInsertFields","collection","prefix","baseURLField","name","type","admin","hidden","readOnly","label","basePrefixField","fields","existingURLFieldIndex","existingURLField","find","existingField","i","splice","push","upload","imageSizes","existingSizesFieldIndex","existingSizesField","sizesField","map","size","existingSizeField","existingSizeURLField","existingPrefixFieldIndex","existingPrefixField","defaultValue","posix","join"],"mappings":"AAEA,OAAOA,UAAU,OAAM;AAWvB,OAAO,MAAMC,YAAY,CAAC,EAAEC,kBAAkB,EAAEC,UAAU,EAAEC,MAAM,EAAQ;IACxE,MAAMC,eAA0B;QAC9BC,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,QAAQ;YACRC,UAAU;QACZ;QACAC,OAAO;IACT;IAEA,MAAMC,kBAA6B;QACjCN,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,QAAQ;YACRC,UAAU;QACZ;IACF;IAEA,MAAMG,SAAS;WAAIV,WAAWU,MAAM;KAAC;IAErC,qDAAqD;IAErD,IAAIC,wBAAwB,CAAC;IAE7B,MAAMC,mBAAmBF,OAAOG,IAAI,CAAC,CAACC,eAAeC;QACnD,IAAI,UAAUD,iBAAiBA,cAAcX,IAAI,KAAK,OAAO;YAC3DQ,wBAAwBI;YACxB,OAAO;QACT;QACA,OAAO;IACT;IAEA,IAAIJ,wBAAwB,CAAC,GAAG;QAC9BD,OAAOM,MAAM,CAACL,uBAAuB;IACvC;IAEAD,OAAOO,IAAI,CAAC;QACV,GAAGf,YAAY;QACf,GAAIU,oBAAoB,CAAC,CAAC;IAC5B;IAEA,IAAI,OAAOZ,WAAWkB,MAAM,KAAK,YAAYlB,WAAWkB,MAAM,CAACC,UAAU,EAAE;QACzE,IAAIC,0BAA0B,CAAC;QAE/B,MAAMC,qBAAqBX,OAAOG,IAAI,CAAC,CAACC,eAAeC;YACrD,IAAI,UAAUD,iBAAiBA,cAAcX,IAAI,KAAK,SAAS;gBAC7DiB,0BAA0BL;gBAC1B,OAAO;YACT;YAEA,OAAO;QACT;QAEA,IAAIK,0BAA0B,CAAC,GAAG;YAChCV,OAAOM,MAAM,CAACI,yBAAyB;QACzC;QAEA,MAAME,aAAoB;YACxB,GAAID,sBAAsB,CAAC,CAAC;YAC5BlB,MAAM;YACNC,MAAM;YACNC,OAAO;gBACLC,QAAQ;YACV;YACAI,QAAQV,WAAWkB,MAAM,CAACC,UAAU,CAACI,GAAG,CAAC,CAACC;gBACxC,MAAMC,oBAAoBJ,oBAAoBX,OAAOG,KACnD,CAACC,gBAAkB,UAAUA,iBAAiBA,cAAcX,IAAI,KAAKqB,KAAKrB,IAAI;gBAGhF,MAAMuB,uBAAuBD,mBAAmBf,OAAOG,KACrD,CAACC,gBAAkB,UAAUA,iBAAiBA,cAAcX,IAAI,KAAK;gBAGvE,OAAO;oBACL,GAAGsB,iBAAiB;oBACpBtB,MAAMqB,KAAKrB,IAAI;oBACfC,MAAM;oBACNM,QAAQ;wBACN;4BACE,GAAIgB,wBAAwB,CAAC,CAAC;4BAC9B,GAAGxB,YAAY;wBACjB;qBACD;gBACH;YACF;QACF;QAEAQ,OAAOO,IAAI,CAACK;IACd;IAEA,oEAAoE;IACpE,IAAI,OAAOrB,WAAW,eAAeF,oBAAoB;QACvD,IAAI4B,2BAA2B,CAAC;QAEhC,MAAMC,sBAAsBlB,OAAOG,IAAI,CAAC,CAACC,eAAeC;YACtD,IAAI,UAAUD,iBAAiBA,cAAcX,IAAI,KAAK,UAAU;gBAC9DwB,2BAA2BZ;gBAC3B,OAAO;YACT;YACA,OAAO;QACT;QAEA,IAAIY,2BAA2B,CAAC,GAAG;YACjCjB,OAAOM,MAAM,CAACW,0BAA0B;QAC1C;QAEAjB,OAAOO,IAAI,CAAC;YACV,GAAGR,eAAe;YAClB,GAAImB,uBAAuB,CAAC,CAAC;YAC7BC,cAAc5B,SAASJ,KAAKiC,KAAK,CAACC,IAAI,CAAC9B,UAAU;QACnD;IACF;IAEA,OAAOS;AACT,EAAC"}