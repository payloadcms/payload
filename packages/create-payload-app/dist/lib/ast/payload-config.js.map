{"version":3,"sources":["../../../src/lib/ast/payload-config.ts"],"sourcesContent":["import { execSync } from 'child_process'\nimport path from 'path'\nimport { Project, QuoteKind, type SourceFile, SyntaxKind } from 'ts-morph'\n\nimport type {\n  ConfigureOptions,\n  DatabaseAdapter,\n  DetectionResult,\n  Modification,\n  StorageAdapter,\n  TransformationResult,\n  WriteOptions,\n  WriteResult,\n} from './types.js'\n\nimport { debug } from '../../utils/log.js'\nimport { DB_ADAPTER_CONFIG, STORAGE_ADAPTER_CONFIG } from './adapter-config.js'\nimport {\n  addImportDeclaration,\n  cleanupOrphanedImports,\n  formatError,\n  removeImportDeclaration,\n} from './utils.js'\n\nexport function detectPayloadConfigStructure(sourceFile: SourceFile): DetectionResult {\n  debug(`[AST] Detecting payload config structure in ${sourceFile.getFilePath()}`)\n\n  // First find the actual name being used (might be aliased)\n  const payloadImport = sourceFile\n    .getImportDeclarations()\n    .find((imp) => imp.getModuleSpecifierValue() === 'payload')\n\n  const buildConfigImportSpec = payloadImport\n    ?.getNamedImports()\n    .find((spec) => spec.getName() === 'buildConfig')\n\n  const aliasNode = buildConfigImportSpec?.getAliasNode()\n  const buildConfigName = aliasNode ? aliasNode.getText() : 'buildConfig'\n\n  debug(`[AST] Looking for function call: ${buildConfigName}`)\n\n  // Find buildConfig call expression (using actual name in code)\n  const buildConfigCall = sourceFile\n    .getDescendantsOfKind(SyntaxKind.CallExpression)\n    .find((call) => {\n      const expression = call.getExpression()\n      return expression.getText() === buildConfigName\n    })\n\n  if (!buildConfigCall) {\n    debug(`[AST] ✗ ${buildConfigName} call not found`)\n    return {\n      error: formatError({\n        actual: `No ${buildConfigName} call found in file`,\n        context: 'buildConfig call',\n        expected: `export default ${buildConfigName}({ ... })`,\n        technicalDetails: `Could not find CallExpression with identifier \"${buildConfigName}\"`,\n      }),\n      success: false,\n    }\n  }\n\n  debug(`[AST] ✓ ${buildConfigName} call found`)\n\n  // Get import statements\n  const importStatements = sourceFile.getImportDeclarations()\n  debug(`[AST] Found ${importStatements.length} import statements`)\n\n  // Find db property if it exists\n  const configObject = buildConfigCall.getArguments()[0]\n  let dbProperty\n  if (configObject && configObject.getKind() === SyntaxKind.ObjectLiteralExpression) {\n    dbProperty = configObject\n      .asKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n      .getProperty('db')\n      ?.asKind(SyntaxKind.PropertyAssignment)\n  }\n\n  debug(`[AST] db property: ${dbProperty ? '✓ found' : '✗ not found'}`)\n\n  // Find plugins array if it exists\n  let pluginsArray\n  if (configObject && configObject.getKind() === SyntaxKind.ObjectLiteralExpression) {\n    const objLiteral = configObject.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n    const pluginsProperty = objLiteral.getProperty('plugins')\n\n    // Handle PropertyAssignment (e.g., plugins: [...])\n    const propertyAssignment = pluginsProperty?.asKind(SyntaxKind.PropertyAssignment)\n    if (propertyAssignment) {\n      const initializer = propertyAssignment.getInitializer()\n      if (initializer?.getKind() === SyntaxKind.ArrayLiteralExpression) {\n        pluginsArray = initializer.asKind(SyntaxKind.ArrayLiteralExpression)\n      }\n    }\n    // For ShorthandPropertyAssignment (e.g., plugins), we can't get the array directly\n    // but we'll detect it in addStorageAdapter\n  }\n\n  debug(`[AST] plugins array: ${pluginsArray ? '✓ found' : '✗ not found'}`)\n\n  // Find all buildConfig calls for edge case detection (using actual name)\n  const allBuildConfigCalls = sourceFile\n    .getDescendantsOfKind(SyntaxKind.CallExpression)\n    .filter((call) => {\n      const expression = call.getExpression()\n      return expression.getText() === buildConfigName\n    })\n\n  const hasImportAlias = !!aliasNode\n\n  // Check for other Payload imports\n  const payloadImports = payloadImport?.getNamedImports() || []\n  const hasOtherPayloadImports =\n    payloadImports.length > 1 || payloadImports.some((imp) => imp.getName() !== 'buildConfig')\n\n  // Track database adapter imports\n  let dbAdapterImportInfo\n  for (const [, config] of Object.entries(DB_ADAPTER_CONFIG)) {\n    const importDecl = sourceFile\n      .getImportDeclarations()\n      .find((imp) => imp.getModuleSpecifierValue() === config.packageName)\n\n    if (importDecl) {\n      const namedImports = importDecl.getNamedImports()\n      dbAdapterImportInfo = {\n        hasOtherImports: namedImports.length > 1,\n        importDeclaration: importDecl,\n        packageName: config.packageName,\n      }\n      break\n    }\n  }\n\n  // Track storage adapter imports\n  const storageAdapterImports = []\n  for (const [, config] of Object.entries(STORAGE_ADAPTER_CONFIG)) {\n    if (!config.packageName || !config.adapterName) {\n      continue\n    }\n\n    const importDecl = sourceFile\n      .getImportDeclarations()\n      .find((imp) => imp.getModuleSpecifierValue() === config.packageName)\n\n    if (importDecl) {\n      const namedImports = importDecl.getNamedImports()\n      storageAdapterImports.push({\n        hasOtherImports: namedImports.length > 1,\n        importDeclaration: importDecl,\n        packageName: config.packageName,\n      })\n    }\n  }\n\n  const needsManualIntervention = hasImportAlias || allBuildConfigCalls.length > 2\n\n  debug(\n    `[AST] Edge cases: alias=${hasImportAlias}, multiple=${allBuildConfigCalls.length > 1}, otherImports=${hasOtherPayloadImports}, manual=${needsManualIntervention}`,\n  )\n\n  return {\n    edgeCases: {\n      hasImportAlias,\n      hasOtherPayloadImports,\n      multipleBuildConfigCalls: allBuildConfigCalls.length > 1,\n      needsManualIntervention,\n    },\n    importSources: {\n      dbAdapter: dbAdapterImportInfo,\n      storageAdapters: storageAdapterImports.length > 0 ? storageAdapterImports : undefined,\n    },\n    sourceFile,\n    structures: {\n      buildConfigCall,\n      dbProperty,\n      importStatements,\n      pluginsArray,\n    },\n    success: true,\n  }\n}\n\nexport function addDatabaseAdapter({\n  adapter,\n  envVarName = 'DATABASE_URL',\n  sourceFile,\n}: {\n  adapter: DatabaseAdapter\n  envVarName?: string\n  sourceFile: SourceFile\n}): TransformationResult {\n  debug(`[AST] Adding database adapter: ${adapter} (envVar: ${envVarName})`)\n\n  const modifications: Modification[] = []\n\n  const detection = detectPayloadConfigStructure(sourceFile)\n\n  if (!detection.success || !detection.structures) {\n    return {\n      error: detection.error,\n      modifications: [],\n      modified: false,\n      success: false,\n    }\n  }\n\n  const { buildConfigCall, dbProperty } = detection.structures\n  const config = DB_ADAPTER_CONFIG[adapter]\n\n  // Remove old db adapter imports and track position for replacement\n  const oldAdapters = Object.values(DB_ADAPTER_CONFIG)\n  const removedAdapters: string[] = []\n  let importInsertIndex: number | undefined\n  oldAdapters.forEach((oldConfig) => {\n    if (oldConfig.packageName !== config.packageName) {\n      const { removedIndex } = removeImportDeclaration({\n        moduleSpecifier: oldConfig.packageName,\n        sourceFile,\n      })\n      if (removedIndex !== undefined) {\n        // Use the first removed adapter's position\n        if (importInsertIndex === undefined) {\n          importInsertIndex = removedIndex\n        }\n        removedAdapters.push(oldConfig.packageName)\n        modifications.push({\n          type: 'import-removed',\n          description: `Removed import from '${oldConfig.packageName}'`,\n        })\n      }\n    }\n  })\n\n  if (removedAdapters.length > 0) {\n    debug(`[AST] Removed old adapter imports: ${removedAdapters.join(', ')}`)\n  }\n\n  // Add new import at the position of the removed one (or default position)\n  addImportDeclaration({\n    insertIndex: importInsertIndex,\n    moduleSpecifier: config.packageName,\n    namedImports: [config.adapterName],\n    sourceFile,\n  })\n  modifications.push({\n    type: 'import-added',\n    description: `Added import: { ${config.adapterName} } from '${config.packageName}'`,\n  })\n\n  // Add special imports for specific adapters\n  if (adapter === 'd1-sqlite') {\n    debug('[AST] Adding special import: ./db/migrations')\n    addImportDeclaration({\n      defaultImport: 'migrations',\n      moduleSpecifier: './db/migrations',\n      sourceFile,\n    })\n    modifications.push({\n      type: 'import-added',\n      description: `Added import: migrations from './db/migrations'`,\n    })\n  }\n\n  // Get config object\n  const configObject = buildConfigCall.getArguments()[0]\n  if (!configObject || configObject.getKind() !== SyntaxKind.ObjectLiteralExpression) {\n    return {\n      error: formatError({\n        actual: 'buildConfig has no object literal argument',\n        context: 'database adapter configuration',\n        expected: 'buildConfig({ ... })',\n        technicalDetails: 'buildConfig call must have an object literal as first argument',\n      }),\n      modifications: [],\n      modified: false,\n      success: false,\n    }\n  }\n\n  const objLiteral = configObject.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n\n  const newDbCode = `db: ${config.configTemplate(envVarName)}`\n\n  if (dbProperty) {\n    // Replace existing db property\n    // NOTE: Using replaceWithText() instead of remove() + insertPropertyAssignment()\n    // to avoid double comma issues. When remove() is called, ts-morph doesn't always\n    // clean up trailing commas correctly, which can result in syntax like \"},,\" when\n    // inserting a new property at that position. replaceWithText() preserves the\n    // surrounding punctuation correctly.\n    debug(`[AST] Replacing existing db property`)\n    dbProperty.replaceWithText(newDbCode)\n    modifications.push({\n      type: 'property-added',\n      description: `Replaced db property with ${adapter} adapter`,\n    })\n  } else {\n    // No existing db property - insert at end\n    const insertIndex = objLiteral.getProperties().length\n    debug(`[AST] Adding db property at index ${insertIndex}`)\n    objLiteral.insertPropertyAssignment(insertIndex, {\n      name: 'db',\n      initializer: config.configTemplate(envVarName),\n    })\n    modifications.push({\n      type: 'property-added',\n      description: `Added db property with ${adapter} adapter`,\n    })\n  }\n\n  debug(`[AST] ✓ Database adapter ${adapter} added successfully`)\n\n  return {\n    modifications,\n    modified: true,\n    success: true,\n  }\n}\n\nexport function addStorageAdapter({\n  adapter,\n  sourceFile,\n}: {\n  adapter: StorageAdapter\n  sourceFile: SourceFile\n}): TransformationResult {\n  debug(`[AST] Adding storage adapter: ${adapter}`)\n\n  const modifications: Modification[] = []\n\n  const detection = detectPayloadConfigStructure(sourceFile)\n\n  if (!detection.success || !detection.structures) {\n    return {\n      error: detection.error,\n      modifications: [],\n      modified: false,\n      success: false,\n    }\n  }\n\n  const config = STORAGE_ADAPTER_CONFIG[adapter]\n\n  // Local disk doesn't need any imports or plugins\n  if (adapter === 'localDisk') {\n    debug('[AST] localDisk storage adapter - no imports or plugins needed')\n    return {\n      modifications: [],\n      modified: false,\n      success: true,\n    }\n  }\n\n  // Add import\n  if (config.packageName && config.adapterName) {\n    addImportDeclaration({\n      moduleSpecifier: config.packageName,\n      namedImports: [config.adapterName],\n      sourceFile,\n    })\n    modifications.push({\n      type: 'import-added',\n      description: `Added import: { ${config.adapterName} } from '${config.packageName}'`,\n    })\n  }\n\n  const { buildConfigCall } = detection.structures\n  const configObject = buildConfigCall.getArguments()[0]\n\n  if (!configObject || configObject.getKind() !== SyntaxKind.ObjectLiteralExpression) {\n    return {\n      error: formatError({\n        actual: 'buildConfig has no object literal argument',\n        context: 'storage adapter configuration',\n        expected: 'buildConfig({ ... })',\n        technicalDetails: 'buildConfig call must have an object literal as first argument',\n      }),\n      modifications: [],\n      modified: false,\n      success: false,\n    }\n  }\n\n  const objLiteral = configObject.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n\n  // Find or create plugins array\n  const pluginsPropertyRaw = objLiteral.getProperty('plugins')\n  let pluginsProperty = pluginsPropertyRaw?.asKind(SyntaxKind.PropertyAssignment)\n\n  // Check if it's a shorthand property (e.g., `plugins` referencing an imported variable)\n  const shorthandProperty = pluginsPropertyRaw?.asKind(SyntaxKind.ShorthandPropertyAssignment)\n\n  if (shorthandProperty) {\n    debug('[AST] Found shorthand plugins property, converting to long form with spread')\n    // Get the identifier name (usually 'plugins')\n    const identifierName = shorthandProperty.getName()\n\n    // Find insert position before removing\n    const allProperties = objLiteral.getProperties()\n    const insertIndex = allProperties.indexOf(shorthandProperty)\n\n    // Remove the shorthand property\n    shorthandProperty.remove()\n\n    // Create new property with spread operator: plugins: [...plugins, newAdapter]\n    objLiteral.insertPropertyAssignment(insertIndex, {\n      name: 'plugins',\n      initializer: `[...${identifierName}]`,\n    })\n\n    pluginsProperty = objLiteral.getProperty('plugins')?.asKind(SyntaxKind.PropertyAssignment)\n    modifications.push({\n      type: 'property-added',\n      description: `Converted shorthand plugins property to array with spread syntax`,\n    })\n  } else if (!pluginsProperty) {\n    debug('[AST] Creating new plugins array')\n    // Create plugins array\n    objLiteral.addPropertyAssignment({\n      name: 'plugins',\n      initializer: '[]',\n    })\n    pluginsProperty = objLiteral.getProperty('plugins')?.asKind(SyntaxKind.PropertyAssignment)\n    modifications.push({\n      type: 'property-added',\n      description: `Created plugins array`,\n    })\n  } else {\n    debug('[AST] Reusing existing plugins array')\n  }\n\n  if (!pluginsProperty) {\n    return {\n      error: formatError({\n        actual: 'Failed to create or find plugins property',\n        context: 'storage adapter configuration',\n        expected: 'plugins array property',\n        technicalDetails: 'Could not create or access plugins property',\n      }),\n      modifications: [],\n      modified: false,\n      success: false,\n    }\n  }\n\n  const initializer = pluginsProperty.getInitializer()\n  if (!initializer || initializer.getKind() !== SyntaxKind.ArrayLiteralExpression) {\n    return {\n      error: formatError({\n        actual: 'plugins property is not an array',\n        context: 'storage adapter configuration',\n        expected: 'plugins: [...]',\n        technicalDetails: 'plugins property must be an array literal expression',\n      }),\n      modifications: [],\n      modified: false,\n      success: false,\n    }\n  }\n\n  const pluginsArray = initializer.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)\n\n  // Add storage adapter call\n  const configText = config.configTemplate()\n  if (configText) {\n    pluginsArray.addElement(configText)\n    modifications.push({\n      type: 'property-added',\n      description: `Added ${adapter} to plugins array`,\n    })\n  }\n\n  debug(`[AST] ✓ Storage adapter ${adapter} added successfully`)\n\n  return {\n    modifications,\n    modified: true,\n    success: true,\n  }\n}\n\nexport function removeSharp(sourceFile: SourceFile): TransformationResult {\n  debug('[AST] Removing sharp import and property')\n\n  const modifications: Modification[] = []\n\n  // Remove import\n  const { removedIndex } = removeImportDeclaration({ moduleSpecifier: 'sharp', sourceFile })\n  if (removedIndex !== undefined) {\n    modifications.push({\n      type: 'import-removed',\n      description: `Removed import from 'sharp'`,\n    })\n  }\n\n  // Find and remove sharp property from buildConfig\n  const detection = detectPayloadConfigStructure(sourceFile)\n\n  if (!detection.success || !detection.structures) {\n    // If detection failed but we removed import, still count as partial success\n    if (modifications.length > 0) {\n      return {\n        modifications,\n        modified: true,\n        success: true,\n        warnings: ['Could not detect config structure to remove sharp property'],\n      }\n    }\n    return {\n      error: detection.error,\n      modifications: [],\n      modified: false,\n      success: false,\n    }\n  }\n\n  const { buildConfigCall } = detection.structures\n  const configObject = buildConfigCall.getArguments()[0]\n\n  if (!configObject || configObject.getKind() !== SyntaxKind.ObjectLiteralExpression) {\n    return {\n      modifications,\n      modified: modifications.length > 0,\n      success: true,\n      warnings: ['buildConfig has no object literal argument - could not remove sharp property'],\n    }\n  }\n\n  const objLiteral = configObject.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)\n  const sharpProperty = objLiteral.getProperty('sharp')\n\n  if (sharpProperty) {\n    sharpProperty.remove()\n    modifications.push({\n      type: 'property-removed',\n      description: `Removed sharp property from config`,\n    })\n    debug('[AST] ✓ Sharp property removed from config')\n  } else {\n    debug('[AST] Sharp property not found (already absent)')\n  }\n\n  return {\n    modifications,\n    modified: modifications.length > 0,\n    success: true,\n  }\n}\n\n/** This shouldn't be necessary once the templates are updated. Can't hurt to keep in, though */\nexport function removeCommentMarkers(sourceFile: SourceFile): SourceFile {\n  // Get the full text and replace comment markers\n  let text = sourceFile.getFullText()\n\n  // Remove inline comment markers from imports\n  text = text.replace(/\\s*\\/\\/\\s*database-adapter-import\\s*$/gm, '')\n  text = text.replace(/\\s*\\/\\/\\s*storage-adapter-import-placeholder\\s*$/gm, '')\n\n  // Remove standalone comment lines\n  text = text.replace(/^\\s*\\/\\/\\s*database-adapter-config-start\\s*\\n/gm, '')\n  text = text.replace(/^\\s*\\/\\/\\s*database-adapter-config-end\\s*\\n/gm, '')\n  text = text.replace(/^\\s*\\/\\/\\s*storage-adapter-placeholder\\s*\\n/gm, '')\n\n  // Also remove the placeholder line from template (storage-adapter-import-placeholder at top)\n  text = text.replace(/^\\/\\/\\s*storage-adapter-import-placeholder\\s*\\n/gm, '')\n\n  // Replace the entire source file content\n  sourceFile.replaceWithText(text)\n\n  return sourceFile\n}\n\n/**\n * Validates payload config structure has required elements after transformation.\n * Checks that buildConfig() call exists and has a db property configured.\n */\nexport function validateStructure(sourceFile: SourceFile): WriteResult {\n  debug('[AST] Validating payload config structure')\n\n  const detection = detectPayloadConfigStructure(sourceFile)\n\n  if (!detection.success) {\n    debug('[AST] ✗ Validation failed: detection unsuccessful')\n    return {\n      error: detection.error,\n      success: false,\n    }\n  }\n\n  const { structures } = detection\n\n  // Validate db property exists\n  if (!structures?.dbProperty) {\n    debug('[AST] ✗ Validation failed: db property missing')\n    return {\n      error: formatError({\n        actual: 'No db property found',\n        context: 'database configuration',\n        expected: 'buildConfig must have a db property',\n        technicalDetails: 'PropertyAssignment with name \"db\" not found in buildConfig object',\n      }),\n      success: false,\n    }\n  }\n\n  debug('[AST] ✓ Validation passed')\n  return { success: true }\n}\n\nexport async function writeTransformedFile(\n  sourceFile: SourceFile,\n  options: WriteOptions = {},\n): Promise<WriteResult> {\n  const { formatWithPrettier = true, validateStructure: shouldValidate = true } = options\n\n  debug(`[AST] Writing transformed file: ${sourceFile.getFilePath()}`)\n\n  // Validate if requested\n  if (shouldValidate) {\n    const validation = validateStructure(sourceFile)\n    if (!validation.success) {\n      return validation\n    }\n  }\n\n  // Get file path and save to disk\n  const filePath = sourceFile.getFilePath()\n\n  // Format with ts-morph before saving (fixes trailing commas, indentation)\n  debug('[AST] Formatting with ts-morph')\n  sourceFile.formatText()\n\n  // Write file\n  debug('[AST] Writing file to disk')\n  await sourceFile.save()\n\n  // Format with prettier if requested\n  if (formatWithPrettier) {\n    debug('[AST] Running prettier formatting via CLI')\n    try {\n      // Detect project directory (go up from file until we find package.json or use dirname)\n      const projectDir = path.dirname(filePath)\n\n      // Run prettier via CLI (avoids Jest/ESM compatibility issues)\n      const prettierCmd = `npx prettier --write \"${filePath}\"`\n\n      debug(`[AST] Executing: ${prettierCmd}`)\n      execSync(prettierCmd, {\n        cwd: projectDir,\n        stdio: 'pipe', // Suppress output\n      })\n      debug('[AST] ✓ Prettier formatting successful')\n    } catch (error) {\n      // Log but don't fail if prettier fails (might not be installed)\n      debug(\n        `[AST] ⚠ Prettier formatting failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      )\n      debug('[AST] Continuing with unformatted output')\n    }\n  } else {\n    debug('[AST] Skipping prettier formatting (disabled)')\n  }\n\n  debug('[AST] ✓ File written successfully')\n\n  return { success: true }\n}\n\nexport async function configurePayloadConfig(\n  filePath: string,\n  options: ConfigureOptions = {},\n): Promise<WriteResult> {\n  debug(`[AST] Configuring payload config: ${filePath}`)\n  debug(\n    `[AST] Options: db=${options.db?.type}, storage=${options.storage}, removeSharp=${options.removeSharp}`,\n  )\n\n  const allModifications: Modification[] = []\n  const allWarnings: string[] = []\n\n  try {\n    // Create Project and load source file with proper settings\n    const project = new Project({\n      manipulationSettings: {\n        quoteKind: QuoteKind.Single,\n      },\n    })\n    let sourceFile = project.addSourceFileAtPath(filePath)\n\n    // Run detection\n    const detection = detectPayloadConfigStructure(sourceFile)\n    if (!detection.success) {\n      return detection\n    }\n\n    // Apply transformations based on options\n    if (options.db) {\n      debug('[AST] Applying database adapter transformation')\n      const result = addDatabaseAdapter({\n        adapter: options.db.type,\n        envVarName: options.db.envVarName,\n        sourceFile,\n      })\n\n      if (!result.success) {\n        return {\n          error: result.error,\n          success: false,\n        }\n      }\n\n      allModifications.push(...result.modifications)\n      if (result.warnings) {\n        allWarnings.push(...result.warnings)\n      }\n    }\n\n    if (options.storage) {\n      debug('[AST] Applying storage adapter transformation')\n      const result = addStorageAdapter({ adapter: options.storage, sourceFile })\n\n      if (!result.success) {\n        return {\n          error: result.error,\n          success: false,\n        }\n      }\n\n      allModifications.push(...result.modifications)\n      if (result.warnings) {\n        allWarnings.push(...result.warnings)\n      }\n    }\n\n    if (options.removeSharp) {\n      debug('[AST] Applying sharp removal')\n      const result = removeSharp(sourceFile)\n\n      if (!result.success) {\n        return {\n          error: result.error,\n          success: false,\n        }\n      }\n\n      allModifications.push(...result.modifications)\n      if (result.warnings) {\n        allWarnings.push(...result.warnings)\n      }\n    }\n\n    // Remove comment markers from template\n    sourceFile = removeCommentMarkers(sourceFile)\n\n    // Cleanup orphaned imports after all transformations\n    debug('[AST] Cleaning up orphaned imports')\n\n    // Cleanup database adapter imports if db was removed\n    for (const [, config] of Object.entries(DB_ADAPTER_CONFIG)) {\n      if (options.db && config.packageName !== DB_ADAPTER_CONFIG[options.db.type].packageName) {\n        const cleanup = cleanupOrphanedImports({\n          importNames: [config.adapterName],\n          moduleSpecifier: config.packageName,\n          sourceFile,\n        })\n        if (cleanup.removed.length > 0) {\n          cleanup.removed.forEach((importName) => {\n            allModifications.push({\n              type: 'import-removed',\n              description: `Cleaned up unused import '${importName}' from '${config.packageName}'`,\n            })\n          })\n        }\n      }\n    }\n\n    // Log summary of modifications\n    if (allModifications.length > 0) {\n      debug(`[AST] Applied ${allModifications.length} modification(s):`)\n      allModifications.forEach((mod) => {\n        debug(`[AST]   - ${mod.type}: ${mod.description}`)\n      })\n    }\n\n    if (allWarnings.length > 0) {\n      debug(`[AST] ${allWarnings.length} warning(s):`)\n      allWarnings.forEach((warning) => {\n        debug(`[AST]   - ${warning}`)\n      })\n    }\n\n    // Write transformed file with validation and formatting\n    return await writeTransformedFile(sourceFile, {\n      formatWithPrettier: options.formatWithPrettier,\n      validateStructure: options.validateStructure ?? true,\n    })\n  } catch (error) {\n    debug(`[AST] ✗ Configuration failed: ${error instanceof Error ? error.message : String(error)}`)\n    return {\n      error: formatError({\n        actual: error instanceof Error ? error.message : String(error),\n        context: 'configurePayloadConfig',\n        expected: 'Successful file transformation',\n        technicalDetails: error instanceof Error ? error.stack || error.message : String(error),\n      }),\n      success: false,\n    }\n  }\n}\n"],"names":["execSync","path","Project","QuoteKind","SyntaxKind","debug","DB_ADAPTER_CONFIG","STORAGE_ADAPTER_CONFIG","addImportDeclaration","cleanupOrphanedImports","formatError","removeImportDeclaration","detectPayloadConfigStructure","sourceFile","getFilePath","payloadImport","getImportDeclarations","find","imp","getModuleSpecifierValue","buildConfigImportSpec","getNamedImports","spec","getName","aliasNode","getAliasNode","buildConfigName","getText","buildConfigCall","getDescendantsOfKind","CallExpression","call","expression","getExpression","error","actual","context","expected","technicalDetails","success","importStatements","length","configObject","getArguments","dbProperty","getKind","ObjectLiteralExpression","asKindOrThrow","getProperty","asKind","PropertyAssignment","pluginsArray","objLiteral","pluginsProperty","propertyAssignment","initializer","getInitializer","ArrayLiteralExpression","allBuildConfigCalls","filter","hasImportAlias","payloadImports","hasOtherPayloadImports","some","dbAdapterImportInfo","config","Object","entries","importDecl","packageName","namedImports","hasOtherImports","importDeclaration","storageAdapterImports","adapterName","push","needsManualIntervention","edgeCases","multipleBuildConfigCalls","importSources","dbAdapter","storageAdapters","undefined","structures","addDatabaseAdapter","adapter","envVarName","modifications","detection","modified","oldAdapters","values","removedAdapters","importInsertIndex","forEach","oldConfig","removedIndex","moduleSpecifier","type","description","join","insertIndex","defaultImport","newDbCode","configTemplate","replaceWithText","getProperties","insertPropertyAssignment","name","addStorageAdapter","pluginsPropertyRaw","shorthandProperty","ShorthandPropertyAssignment","identifierName","allProperties","indexOf","remove","addPropertyAssignment","configText","addElement","removeSharp","warnings","sharpProperty","removeCommentMarkers","text","getFullText","replace","validateStructure","writeTransformedFile","options","formatWithPrettier","shouldValidate","validation","filePath","formatText","save","projectDir","dirname","prettierCmd","cwd","stdio","Error","message","configurePayloadConfig","db","storage","allModifications","allWarnings","project","manipulationSettings","quoteKind","Single","addSourceFileAtPath","result","cleanup","importNames","removed","importName","mod","warning","String","stack"],"mappings":"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"}