{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type {\n  ApplyDisableErrors,\n  AuthCollectionSlug,\n  CollectionSlug,\n  ErrorResult,\n  GlobalSlug,\n  PaginatedDocs,\n  PayloadTypes,\n  PayloadTypesShape,\n  SelectType,\n  TypeWithVersion,\n} from 'payload'\n\nexport { PayloadSDKError } from './errors/PayloadSDKError.js'\n\nimport type { ForgotPasswordOptions } from './auth/forgotPassword.js'\nimport type { LoginOptions, LoginResult } from './auth/login.js'\nimport type { MeOptions, MeResult } from './auth/me.js'\nimport type { ResetPasswordOptions, ResetPasswordResult } from './auth/resetPassword.js'\nimport type { CountOptions } from './collections/count.js'\nimport type { CreateOptions } from './collections/create.js'\nimport type { DeleteByIDOptions, DeleteManyOptions, DeleteOptions } from './collections/delete.js'\nimport type { FindOptions } from './collections/find.js'\nimport type { FindByIDOptions } from './collections/findByID.js'\nimport type { FindVersionByIDOptions } from './collections/findVersionByID.js'\nimport type { FindVersionsOptions } from './collections/findVersions.js'\nimport type { RestoreVersionByIDOptions } from './collections/restoreVersion.js'\nimport type { FindGlobalVersionByIDOptions } from './globals/findVersionByID.js'\nimport type { FindGlobalVersionsOptions } from './globals/findVersions.js'\nimport type { RestoreGlobalVersionByIDOptions } from './globals/restoreVersion.js'\nimport type { UpdateGlobalOptions } from './globals/update.js'\nimport type {\n  BulkOperationResult,\n  DataFromCollectionSlug,\n  DataFromGlobalSlug,\n  SelectFromCollectionSlug,\n  SelectFromGlobalSlug,\n  TransformCollectionWithSelect,\n  TransformGlobalWithSelect,\n} from './types.js'\nimport type { OperationArgs } from './utilities/buildSearchParams.js'\n\nimport { forgotPassword } from './auth/forgotPassword.js'\nimport { login } from './auth/login.js'\nimport { me } from './auth/me.js'\nimport { type RefreshOptions, type RefreshResult, refreshToken } from './auth/refreshToken.js'\nimport { resetPassword } from './auth/resetPassword.js'\nimport { verifyEmail, type VerifyEmailOptions } from './auth/verifyEmail.js'\nimport { count } from './collections/count.js'\nimport { create } from './collections/create.js'\nimport { deleteOperation } from './collections/delete.js'\nimport { find } from './collections/find.js'\nimport { findByID } from './collections/findByID.js'\nimport { findVersionByID } from './collections/findVersionByID.js'\nimport { findVersions } from './collections/findVersions.js'\nimport { restoreVersion } from './collections/restoreVersion.js'\nimport {\n  update,\n  type UpdateByIDOptions,\n  type UpdateManyOptions,\n  type UpdateOptions,\n} from './collections/update.js'\nimport { PayloadSDKError } from './errors/PayloadSDKError.js'\nimport { findGlobal, type FindGlobalOptions } from './globals/findOne.js'\nimport { findGlobalVersionByID } from './globals/findVersionByID.js'\nimport { findGlobalVersions } from './globals/findVersions.js'\nimport { restoreGlobalVersion } from './globals/restoreVersion.js'\nimport { updateGlobal } from './globals/update.js'\nimport { buildSearchParams } from './utilities/buildSearchParams.js'\n\ntype Args = {\n  /** Base passed `RequestInit` to `fetch`. For base headers / credentials include etc. */\n  baseInit?: RequestInit\n\n  /**\n   * Base API URL for requests.\n   * @example 'https://example.com/api'\n   */\n  baseURL: string\n\n  /**\n   * This option allows you to pass a custom `fetch` implementation.\n   * The function always receives `path` as the first parameter and `RequestInit` as the second.\n   * @example For testing without needing an HTTP server:\n   * ```typescript\n   * import type { GeneratedTypes, SanitizedConfig } from 'payload';\n   * import config from '@payload-config';\n   * import { REST_DELETE, REST_GET, REST_PATCH, REST_POST, REST_PUT } from '@payloadcms/next/routes';\n   * import { PayloadSDK } from '@payloadcms/sdk';\n   *\n   * export type TypedPayloadSDK = PayloadSDK<GeneratedTypes>;\n   *\n   * const api = {\n   *   GET: REST_GET(config),\n   *   POST: REST_POST(config),\n   *   PATCH: REST_PATCH(config),\n   *   DELETE: REST_DELETE(config),\n   *   PUT: REST_PUT(config),\n   * };\n   *\n   * const awaitedConfig = await config;\n   *\n   * export const sdk = new PayloadSDK<GeneratedTypes>({\n   *   baseURL: '',\n   *   fetch: (path: string, init: RequestInit) => {\n   *     const [slugs, search] = path.slice(1).split('?');\n   *     const url = `${awaitedConfig.serverURL || 'http://localhost:3000'}${awaitedConfig.routes.api}/${slugs}${search ? `?${search}` : ''}`;\n   *\n   *     if (init.body instanceof FormData) {\n   *       const file = init.body.get('file') as Blob;\n   *       if (file && init.headers instanceof Headers) {\n   *         init.headers.set('Content-Length', file.size.toString());\n   *       }\n   *     }\n   *\n   *     const request = new Request(url, init);\n   *\n   *     const params = {\n   *       params: Promise.resolve({\n   *         slug: slugs.split('/'),\n   *       }),\n   *     };\n   *\n   *     return api[init.method.toUpperCase()](request, params);\n   *   },\n   * });\n   * ```\n   */\n  fetch?: typeof fetch\n}\n\n/**\n * @experimental\n */\nexport class PayloadSDK<T extends PayloadTypesShape = PayloadTypes> {\n  baseInit: RequestInit\n\n  baseURL: string\n\n  fetch: typeof fetch\n  constructor(args: Args) {\n    this.baseURL = args.baseURL\n    this.fetch = args.fetch ?? globalThis.fetch.bind(globalThis)\n    this.baseInit = args.baseInit ?? {}\n  }\n\n  /**\n   * @description Performs count operation\n   * @param options\n   * @returns count of documents satisfying query\n   */\n  count<TSlug extends CollectionSlug<T>>(\n    options: CountOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<{ totalDocs: number }> {\n    return count(this, options, init)\n  }\n\n  /**\n   * @description Performs create operation\n   * @param options\n   * @returns created document\n   */\n  create<TSlug extends CollectionSlug<T>, TSelect extends SelectType>(\n    options: CreateOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<TransformCollectionWithSelect<T, TSlug, TSelect>> {\n    return create(this, options, init)\n  }\n\n  delete<TSlug extends CollectionSlug<T>, TSelect extends SelectFromCollectionSlug<T, TSlug>>(\n    options: DeleteManyOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<BulkOperationResult<T, TSlug, TSelect>>\n  delete<TSlug extends CollectionSlug<T>, TSelect extends SelectFromCollectionSlug<T, TSlug>>(\n    options: DeleteByIDOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<TransformCollectionWithSelect<T, TSlug, TSelect>>\n\n  /**\n   * @description Update one or more documents\n   * @param options\n   * @returns Updated document(s)\n   */\n  delete<TSlug extends CollectionSlug<T>, TSelect extends SelectFromCollectionSlug<T, TSlug>>(\n    options: DeleteOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<\n    BulkOperationResult<T, TSlug, TSelect> | TransformCollectionWithSelect<T, TSlug, TSelect>\n  > {\n    return deleteOperation(this, options, init)\n  }\n\n  /**\n   * @description Find documents with criteria\n   * @param options\n   * @returns documents satisfying query\n   */\n  find<TSlug extends CollectionSlug<T>, TSelect extends SelectType>(\n    options: FindOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<PaginatedDocs<TransformCollectionWithSelect<T, TSlug, TSelect>>> {\n    return find(this, options, init)\n  }\n\n  /**\n   * @description Find document by ID\n   * @param options\n   * @returns document with specified ID\n   */\n  findByID<\n    TSlug extends CollectionSlug<T>,\n    TDisableErrors extends boolean,\n    TSelect extends SelectType,\n  >(\n    options: FindByIDOptions<T, TSlug, TDisableErrors, TSelect>,\n    init?: RequestInit,\n  ): Promise<ApplyDisableErrors<TransformCollectionWithSelect<T, TSlug, TSelect>, TDisableErrors>> {\n    return findByID(this, options, init)\n  }\n\n  findGlobal<TSlug extends GlobalSlug<T>, TSelect extends SelectFromGlobalSlug<T, TSlug>>(\n    options: FindGlobalOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<TransformGlobalWithSelect<T, TSlug, TSelect>> {\n    return findGlobal(this, options, init)\n  }\n\n  findGlobalVersionByID<TSlug extends GlobalSlug<T>, TDisableErrors extends boolean>(\n    options: FindGlobalVersionByIDOptions<T, TSlug, TDisableErrors>,\n    init?: RequestInit,\n  ): Promise<ApplyDisableErrors<TypeWithVersion<DataFromGlobalSlug<T, TSlug>>, TDisableErrors>> {\n    return findGlobalVersionByID(this, options, init)\n  }\n\n  findGlobalVersions<TSlug extends GlobalSlug<T>>(\n    options: FindGlobalVersionsOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<PaginatedDocs<TypeWithVersion<DataFromGlobalSlug<T, TSlug>>>> {\n    return findGlobalVersions(this, options, init)\n  }\n  findVersionByID<TSlug extends CollectionSlug<T>, TDisableErrors extends boolean>(\n    options: FindVersionByIDOptions<T, TSlug, TDisableErrors>,\n    init?: RequestInit,\n  ): Promise<\n    ApplyDisableErrors<TypeWithVersion<DataFromCollectionSlug<T, TSlug>>, TDisableErrors>\n  > {\n    return findVersionByID(this, options, init)\n  }\n\n  findVersions<TSlug extends CollectionSlug<T>>(\n    options: FindVersionsOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<PaginatedDocs<TypeWithVersion<DataFromCollectionSlug<T, TSlug>>>> {\n    return findVersions(this, options, init)\n  }\n  forgotPassword<TSlug extends AuthCollectionSlug<T>>(\n    options: ForgotPasswordOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<{ message: string }> {\n    return forgotPassword(this, options, init)\n  }\n\n  login<TSlug extends AuthCollectionSlug<T>>(\n    options: LoginOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<LoginResult<T, TSlug>> {\n    return login(this, options, init)\n  }\n\n  me<TSlug extends AuthCollectionSlug<T>>(\n    options: MeOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<MeResult<T, TSlug>> {\n    return me(this, options, init)\n  }\n\n  refreshToken<TSlug extends AuthCollectionSlug<T>>(\n    options: RefreshOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<RefreshResult<T, TSlug>> {\n    return refreshToken(this, options, init)\n  }\n\n  async request({\n    args = {},\n    file,\n    init: incomingInit,\n    json,\n    method,\n    path,\n  }: {\n    args?: OperationArgs\n    file?: Blob\n    init?: RequestInit\n    json?: unknown\n    method: 'DELETE' | 'GET' | 'PATCH' | 'POST' | 'PUT'\n    path: string\n  }): Promise<Response> {\n    const headers = new Headers({ ...this.baseInit.headers, ...incomingInit?.headers })\n\n    const init: RequestInit = {\n      method,\n      ...this.baseInit,\n      ...incomingInit,\n      headers,\n    }\n\n    if (json) {\n      if (file) {\n        const formData = new FormData()\n        formData.append('file', file)\n        formData.append('_payload', JSON.stringify(json))\n        init.body = formData\n      } else {\n        headers.set('Content-Type', 'application/json')\n        init.body = JSON.stringify(json)\n      }\n    }\n\n    const response = await this.fetch(`${this.baseURL}${path}${buildSearchParams(args)}`, init)\n\n    if (!response.ok) {\n      let errorData: {\n        message?: string\n      } & Partial<ErrorResult> = {}\n\n      try {\n        errorData = await response.json()\n      } catch {\n        // Response body may not be JSON\n      }\n\n      const errors: ErrorResult['errors'] = errorData.errors ?? [\n        { message: errorData.message ?? response.statusText },\n      ]\n\n      const message = errors[0]?.message ?? response.statusText\n\n      throw new PayloadSDKError({\n        errors,\n        message,\n        response,\n        status: response.status,\n      })\n    }\n\n    return response\n  }\n\n  resetPassword<TSlug extends AuthCollectionSlug<T>>(\n    options: ResetPasswordOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<ResetPasswordResult<T, TSlug>> {\n    return resetPassword(this, options, init)\n  }\n\n  restoreGlobalVersion<TSlug extends GlobalSlug<T>>(\n    options: RestoreGlobalVersionByIDOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<TypeWithVersion<DataFromGlobalSlug<T, TSlug>>> {\n    return restoreGlobalVersion(this, options, init)\n  }\n\n  restoreVersion<TSlug extends CollectionSlug<T>>(\n    options: RestoreVersionByIDOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<DataFromCollectionSlug<T, TSlug>> {\n    return restoreVersion(this, options, init)\n  }\n\n  update<TSlug extends CollectionSlug<T>, TSelect extends SelectFromCollectionSlug<T, TSlug>>(\n    options: UpdateManyOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<BulkOperationResult<T, TSlug, TSelect>>\n\n  update<TSlug extends CollectionSlug<T>, TSelect extends SelectFromCollectionSlug<T, TSlug>>(\n    options: UpdateByIDOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<TransformCollectionWithSelect<T, TSlug, TSelect>>\n\n  /**\n   * @description Update one or more documents\n   * @param options\n   * @returns Updated document(s)\n   */\n  update<TSlug extends CollectionSlug<T>, TSelect extends SelectFromCollectionSlug<T, TSlug>>(\n    options: UpdateOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<\n    BulkOperationResult<T, TSlug, TSelect> | TransformCollectionWithSelect<T, TSlug, TSelect>\n  > {\n    return update(this, options, init)\n  }\n\n  updateGlobal<TSlug extends GlobalSlug<T>, TSelect extends SelectFromGlobalSlug<T, TSlug>>(\n    options: UpdateGlobalOptions<T, TSlug, TSelect>,\n    init?: RequestInit,\n  ): Promise<TransformGlobalWithSelect<T, TSlug, TSelect>> {\n    return updateGlobal(this, options, init)\n  }\n\n  verifyEmail<TSlug extends AuthCollectionSlug<T>>(\n    options: VerifyEmailOptions<T, TSlug>,\n    init?: RequestInit,\n  ): Promise<{ message: string }> {\n    return verifyEmail(this, options, init)\n  }\n}\n"],"names":["PayloadSDKError","forgotPassword","login","me","refreshToken","resetPassword","verifyEmail","count","create","deleteOperation","find","findByID","findVersionByID","findVersions","restoreVersion","update","findGlobal","findGlobalVersionByID","findGlobalVersions","restoreGlobalVersion","updateGlobal","buildSearchParams","PayloadSDK","baseInit","baseURL","fetch","args","globalThis","bind","options","init","delete","request","file","incomingInit","json","method","path","headers","Headers","formData","FormData","append","JSON","stringify","body","set","response","ok","errorData","errors","message","statusText","status"],"mappings":"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"}