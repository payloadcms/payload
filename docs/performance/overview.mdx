---
title: Performance
label: Overview
order: 10
desc: Ensure your Payload app runs as quickly and efficiently as possible.
keywords: performance, optimization, indexes, depth, select, block references, documentation, Content Management System, cms, headless, javascript, node, react, nextjs
---

Payload is designed with performance in mind, but its customizability means that there are many ways to configure your app that can impact performance.

With this in mind, Payload provides several options and best practices to help you optimize your app's specific performance needs.

Whether you're building an app or troubleshooting an existing one, follow these guidelines to ensure that it runs as quickly and efficiently as possibleâ€”from the API to the Admin Panel.

## Database proximity

The proximity of your database to your server can significantly impact performance. Ensure that your database is hosted in the same region as your server to minimize latency and improve response times.

## Indexing your fields

If a particular field is queried often, build an [Index](../database/overview) for that field to produce faster queries.

When your query runs, the database will not search the entire document to find that one field, but will instead use the index to quickly locate the data.

This is done on the field level by setting the `index` option to `true` in your field's config:

```ts
import type { CollectionConfig } from 'payload'

export MyCollection: CollectionConfig = {
  // ...
  fields: [
    // ...
    {
      name: 'title',
      type: 'text',
      // highlight-start
      index: true,
      // highlight-end
    },
  ]
}
```

<Banner type="success">
  **Tip:** If you're using MongoDB, you can use [MongoDB
  Compass](https://www.mongodb.com/products/compass) to visualize and manage
  your indexes.
</Banner>

## Querying your data

There are several ways to optimize your [Queries](../queries/overview). Many of these options directly impact overall database overhead, response sizes, and/or computational load and can significantly improve performance.

When building queries, combine as many of these options together as possible. This will ensure your queries are as efficient as they can be.

### Depth

Use [Depth](../queries/depth) to only populate the necessary levels of relationships. This will skip any unnecessary population of nested relationships.

For example, a depth of `0` means no relationships are populated. Only the IDs of those related documents are returned. Those relationships are not queried, processed, or returned in the response.

To do this, set `depth: 0` in your query:

```ts
await payload.find({
  collection: 'posts',
  // highlight-start
  depth: 0,
  // highlight-end
})
```

This will return:

```json
{
  "docs": [
    {
      "id": "123",
      "title": "My Post",
      "author": "456" // only the ID of the related document is returned
    }
  ]
}
```

Similarly, you can set `defaultDepth` in your root config to set the default depth for all queries.

```ts
import { buildConfig } from 'payload'

const config = buildConfig({
  // ...
  // highlight-start
  defaultDepth: 0,
  // highlight-end
})
```

### Select

Use the [Select API](../queries/select) to limit the fields returned in your queries. This will skip the processing of any unspecified fields, e.g. running field hooks, and will significantly reduce the size of the response by returning only specified fields.

To do this, set the `select` option in your query:

```ts
await payload.find({
  collection: 'posts',
  // highlight-start
  select: {
    title: true,
  },
  // highlight-end
})
```

This will return:

```json
{
  "docs": [
    {
      "id": "123", // The ID is always returned
      "title": "My Post" // only the title field is returned
    }
  ]
}
```

### Populate

// populate on the request
// per-collection: `defaultPopulate`

### Pagination

For queries that do not require pagination, you can [disable it to improve performance](../queries/pagination##disabling-pagination-within-local-api). This will reduce the overhead of pagination calculations.

For example, if you are querying for a specific document by an exact slug, you might want to disable pagination as you can reliably expect only one document to match.

To do this, set `pagination: false` in your query:

```ts
import type { Payload } from 'payload'

const getPost = async (payload: Payload) => {
  const posts = await payload.find({
    collection: 'posts',
    where: {
      slug: {
        equals: 'post-1',
      },
    },
    // highlight-start
    pagination: false,
    // highlight-end
  })

  return posts
}
```

<Banner type="warning">
  **Note:** This only applies to `find` operations within the Local API.
</Banner>

### Limit

Use the `limit` option in your queries to restrict the number of documents returned. This will reduce the number database lookups.

Similar to disabling pagination, if you are querying for a specific document and can reliably expect only one document to match, you can set a limit of `1`.

To do this, set the `limit` option in your query:

```ts
await payload.find({
  collection: 'posts',
  where: {
    slug: {
      equals: 'post-1',
    },
  },
  // highlight-start
  limit: 1,
  // highlight-end
})
```

<Banner type="success">
  **Tip:** Combine `limit` with `pagination: false` to further optimize your
  queries.
</Banner>

### Make direct database calls

<Banner type="warning">
  **Warning:** Direct database calls bypass all hooks and validations. Only use
  this method when you are certain that the operation is safe and does not
  require any of these features.
</Banner>

Making direct database calls can significantly improve performance by bypassing much of the request lifecycle such as hooks, validations, and other overhead associated with Payload APIs.

For example, this can be especially useful for the `update` operation, where Payload would otherwise need to make multiple API calls to fetch, update, and fetch again. Making a direct database call can reduce this to a single operation.

To do this, use the `payload.db` methods:

```ts
await payload.db.updateOne({
  collection: 'posts',
  id: post.id,
  data: {
    title: 'New Title',
  },
})
```

<Banner type="warning">
  **Note:** Direct database methods do not start a
  [transaction](../database/transactions). You have to start that yourself.
</Banner>

#### Returning

To prevent unnecessary database computation and reduce the size of the response, you can also set `returning: false` in your direct database calls if you don't need the updated document returned to you.

```ts
await payload.db.updateOne({
  collection: 'posts',
  id: post.id,
  data: { title: 'New Title' }, // See note above ^ about Postgres
  // highlight-start
  returning: false,
  // highlight-end
})
```

<Banner type="warning">
  **Note:** The `returning` option is only available on direct-to-db methods.
  E.g. those on the `payload.db` object. It is not exposed to the Local API.
</Banner>

## Optimizing your APIs

When querying data through Payload APIs, the request lifecycle includes running hooks, access control, validations, and other operations that can add significant overhead to the request.

To optimize your APIs, any custom logic should be as efficient as possible. This includes writing lightweight hooks, preventing memory leaks, offloading long-running tasks, and optimizing custom validations.

### Write lightweight hooks

[Hooks](../hooks/overview) are a powerful way to customize the behavior of your APIs, but some hooks are run very often and can add significant overhead to your requests if not optimized.

For example, the `read` operation runs on every read request, so avoid putting expensive logic in a `beforeRead` or `afterRead` hook.

```ts
{
  hooks: {
    beforeRead: [
      async () => {
        // avoid expensive logic here
      },
    ],
  },
}
```

Instead, you could defer some expensive operations to a `beforeChange` or `afterChange` hook, which only run on write operations.

```ts
{
  hooks: {
    beforeChange: [
      async () => {
        // expensive logic is "better" here, but should still be avoided if possible
      },
    ],
  },
}
```

To take this one step further, if your hook executes a long-running task that doesn't affect the response in any way, consider [offloading it to the job queue](#offloading-long-running-tasks). That will free up the request to continue processing without waiting for the task to complete.

### Prevent memory leaks

Use [Hook Context](../hooks/context) to prevent hooks from calling themselves recursively, which can lead to memory leaks and potentially crash your server.

For example, if you make a Payload API call within a hook that queries the same collection, it could trigger that same hook again.

To prevent this, use the `context` object to track the state of your hooks:

```ts
{
  hooks: {
    beforeChange: [
      async ({ context }) => {
        if (context.myHookRan) {
          return
        }

        context.myHookRan = true

        // your hook logic here
      },
    ],
  },
}
```

### Offload long-running tasks

For long running tasks that don't directly affect the API responses, you can offload them to the [Job Queue](../jobs-queue/overview).

For example, if you need to send an email or process a large file, you can queue a job to handle that task instead of doing it in the hook.

This will allow the request to continue processing without waiting for the task to complete.

<Banner type="success">
  **Tip:** To go even further, run your jobs on another server. This will free
  up your main server to handle requests without being bogged down by jobs.
</Banner>

### Optimize custom validations

If your validation functions are asynchronous or computationally expensive, [ensure they only run when necessary](../field/overview#async-field-validations).

For example, if your validation needs to query the database or some external API, ensure it only runs when the document is saved, not on every change in the Admin.

To do this, use the `event` arg in your validation function:

```ts
{
  name: 'title',
  type: 'text',
  validate: async (value, { event }) => {
    if (event === 'submit') {
      // perform expensive validation
    }
    return true;
  },
}
```

## Use a cached Payload instance

Ensure that you do not instantiate Payload unnecessarily. Instead, Payload provides a caching mechanism to reuse the same instance across your app.

To do this, use the `getPayload` function to get the cached instance of Payload:

```ts
import { getPayload } from 'payload'
import config from '@payload-config'

const myFunction = async () => {
  const payload = await getPayload({ config })

  // use payload here
}
```

## Block references

Use [Block References](../fields/blocks#block-references) to share the same block across multiple fields without bloating the config. This will reduce the number of fields to traverse when processing permissions, etc. and can can significantly reduce the amount of data sent from the server to the client in the Admin Panel.

For example, if you have a block that is used in multiple fields, you can define it once and reference it in each field.

To do this, use the `blockReferences` option in your blocks field:

```ts
import { buildConfig } from 'payload'

const config = buildConfig({
  // ...
  blocks: [
    {
      slug: 'TextBlock',
      fields: [
        {
          name: 'text',
          type: 'text',
        },
      ],
    },
  ],
  collections: [
    {
      slug: 'posts',
      fields: [
        {
          name: 'content',
          type: 'blocks',
          // highlight-start
          blockReferences: ['TextBlock'],
          blocks: [], // Required to be empty, for compatibility reasons
          // highlight-end
        },
      ],
    },
    {
      slug: 'pages',
      fields: [
        {
          name: 'content',
          type: 'blocks',
          // highlight-start
          blockReferences: ['TextBlock'],
          blocks: [], // Required to be empty, for compatibility reasons
          // highlight-end
        },
      ],
    },
  ],
})
```

## Selectively bundle UI components in your front-end

If your front-end imports from `@payloadcms/ui`, ensure that you do not bundle the entire package as this can significantly increase your bundle size.

To do this, use direct imports from the package instead:

```ts
import { Button } from '@payloadcms/ui/elements/Button'
```

If building custom components within the Admin Panel, however, this does not apply and will actually cause duplicate modules and React conflicts.

Use the standard import:

```ts
import { Button } from '@payloadcms/ui'
```

<Banner type="success">
  **Tip:** Use
  [`@next/bundle-analyzer`](https://nextjs.org/docs/app/guides/package-bundling)
  to analyze your component tree and identify unnecessary re-renders or large
  components that could be optimized.
</Banner>

## Optimizing custom components

### Reduce initial HTML size

With Server Components, be aware of what is being sent to through the server/client boundary.

For example, all props sent from the server to the client are serialized and sent through the network. To avoid this, you must be explicit about what props are sent to the client.

To do this, prefer server components and only send the necessary props to the client. This will also offset some JS execution to the server.

<Banner type="success">
  **Tip:** Use [React Suspense](https://react.dev/reference/react/Suspense) to
  progressively load components and improve perceived performance.
</Banner>

### Prevent unnecessary re-renders

Subscribing your component to form state can cause unnecessary re-renders if the entire form state is subscribed to.

To do this, use the [`useFormFields`](../admin/react-hooks) hook instead of `useFields` when you only need to access specific fields.

```ts
'use client'
import { useFormFields } from '@payloadcms/ui'

const MyComponent: TextFieldClientComponent = ({ path }) => {
  const value = useFormFields(([fields, dispatch]) => fields[path])

  // ...
}
```

## Optimizing local development

Everything mentioned above applies to local development as well, but there are a few additional steps you can take to optimize your local development experience.

### Enable Turbopack

<Banner type="warning">
  **Note:** In the future this will be the default. Use as your own risk.
</Banner>

Add `--turbo` to your dev script to significantly speed up your local development server start time.

```json
{
  "scripts": {
    "dev": "next dev --turbo"
  }
}
```

### Only bundle server packages in production

<Banner type="warning">
  **Note:** This is enabled by default in `create-payload-app` since v3.28.0. If
  you created your app after this version, you don't need to do anything.
</Banner>

By default, Next.js bundles both server and client code. However, during development, bundling certain server packages isn't necessary.

Payload has thousands of modules, slowing down compilation.

Setting this option skips bundling Payload server modules during development. Fewer files to compile means faster compilation speeds.

To do this, add the `devBundleServerPackages` option to `withPayload` in your `next.config.js` file:

```ts
const nextConfig = {
  // your existing next config
}

export default withPayload(nextConfig, { devBundleServerPackages: false })
```
