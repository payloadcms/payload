---
title: Lexical Converters
label: Converters
order: 20
desc: Conversion between lexical, markdown, jsx and html
keywords: lexical, rich text, editor, headless cms, convert, html, mdx, markdown, md, conversion, export, jsx
---

Richtext fields save data in JSON - this is great for storage and flexibility and allows you to easily to convert it to other formats:

- [Converting JSX](/docs/rich-text/converting-jsx)
- [Converting HTML](/docs/rich-text/converting-html)
- [Converting Plaintext](/docs/rich-text/converting-plaintext)
- [Converting Markdown and MDX](/docs/rich-text/converting-markdown)

### Getting the editor config

The editor config is required for some converters, as some converters are stored on the lexical nodes directly. The editor config will then decide which nodes & features are enabled, and which converters are used.

To get the editor config, import the `editorConfigFactory` factory - this factory provides a variety of ways to get the editor config, depending on your use case.

```ts
import type { SanitizedConfig } from 'payload'

import {
  editorConfigFactory,
  FixedToolbarFeature,
  lexicalEditor,
} from '@payloadcms/richtext-lexical'

// Your config needs to be available in order to retrieve the default editor config
const config: SanitizedConfig = {} as SanitizedConfig

// Version 1 - use the default editor config
const yourEditorConfig = await editorConfigFactory.default({ config })

// Version 2 - if you have access to a lexical fields, you can extract the editor config from it
const yourEditorConfig2 = editorConfigFactory.fromField({
  field: collectionConfig.fields[1],
})

// Version 3 - create a new editor config - behaves just like instantiating a new `lexicalEditor`
const yourEditorConfig3 = await editorConfigFactory.fromFeatures({
  config,
  features: ({ defaultFeatures }) => [...defaultFeatures, FixedToolbarFeature()],
})

// Version 4 - if you have instantiated a lexical editor and are accessing it outside a field (=> this is the unsanitized editor),
// you can extract the editor config from it.
// This is common if you define the editor in a re-usable module scope variable and pass it to the richText field.
// This is the least efficient way to get the editor config, and not recommended. It is recommended to extract the `features` arg
// into a separate variable and use `fromFeatures` instead.
const editor = lexicalEditor({
  features: ({ defaultFeatures }) => [...defaultFeatures, FixedToolbarFeature()],
})

const yourEditorConfig4 = await editorConfigFactory.fromEditor({
  config,
  editor,
})
```

### Example - Getting the editor config from an existing field

If you have access to the sanitized collection config, you can get access to the lexical sanitized editor config & features, as every lexical richText field returns it. Here is an example how you can get it from another field's afterRead hook:

```ts
import type { CollectionConfig, RichTextField } from 'payload'

import { editorConfigFactory, getEnabledNodes, lexicalEditor } from '@payloadcms/richtext-lexical'
import { createHeadlessEditor } from '@payloadcms/richtext-lexical/lexical/headless'

export const MyCollection: CollectionConfig = {
  slug: 'slug',
  fields: [
    {
      name: 'text',
      type: 'text',
      hooks: {
        afterRead: [
          ({ siblingFields, value }) => {
            const field: RichTextField = siblingFields.find(
              (field) => 'name' in field && field.name === 'richText',
            ) as RichTextField

            const editorConfig = editorConfigFactory.fromField({
              field,
            })

            // Now you can use the editor config

            return value
          },
        ],
      },
    },
    {
      name: 'richText',
      type: 'richText',
      editor: lexicalEditor(),
    },
  ],
}
```


